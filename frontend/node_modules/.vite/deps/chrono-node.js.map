{
  "version": 3,
  "sources": ["../../chrono-node/src/locales/en/index.ts", "../../chrono-node/src/types.ts", "../../chrono-node/src/utils/dates.ts", "../../chrono-node/src/timezone.ts", "../../chrono-node/src/calculation/duration.ts", "../../chrono-node/src/results.ts", "../../chrono-node/src/utils/pattern.ts", "../../chrono-node/src/calculation/years.ts", "../../chrono-node/src/locales/en/constants.ts", "../../chrono-node/src/common/parsers/AbstractParserWithWordBoundary.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/en/parsers/ENMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/en/parsers/ENMonthNameMiddleEndianParser.ts", "../../chrono-node/src/locales/en/parsers/ENMonthNameParser.ts", "../../chrono-node/src/locales/en/parsers/ENYearMonthDayParser.ts", "../../chrono-node/src/locales/en/parsers/ENSlashMonthFormatParser.ts", "../../chrono-node/src/common/parsers/AbstractTimeExpressionParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeExpressionParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitLaterFormatParser.ts", "../../chrono-node/src/common/abstractRefiners.ts", "../../chrono-node/src/common/refiners/AbstractMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENMergeDateRangeRefiner.ts", "../../chrono-node/src/calculation/mergingCalculation.ts", "../../chrono-node/src/common/refiners/AbstractMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENMergeDateTimeRefiner.ts", "../../chrono-node/src/common/refiners/ExtractTimezoneAbbrRefiner.ts", "../../chrono-node/src/common/refiners/ExtractTimezoneOffsetRefiner.ts", "../../chrono-node/src/common/refiners/OverlapRemovalRefiner.ts", "../../chrono-node/src/common/refiners/ForwardDateRefiner.ts", "../../chrono-node/src/common/refiners/UnlikelyFormatFilter.ts", "../../chrono-node/src/common/parsers/ISOFormatParser.ts", "../../chrono-node/src/common/refiners/MergeWeekdayComponentRefiner.ts", "../../chrono-node/src/configurations.ts", "../../chrono-node/src/common/casualReferences.ts", "../../chrono-node/src/locales/en/parsers/ENCasualDateParser.ts", "../../chrono-node/src/locales/en/parsers/ENCasualTimeParser.ts", "../../chrono-node/src/calculation/weekdays.ts", "../../chrono-node/src/locales/en/parsers/ENWeekdayParser.ts", "../../chrono-node/src/locales/en/parsers/ENRelativeDateFormatParser.ts", "../../chrono-node/src/common/parsers/SlashDateFormatParser.ts", "../../chrono-node/src/locales/en/parsers/ENTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/en/refiners/ENMergeRelativeAfterDateRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENMergeRelativeFollowByDateRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENExtractYearSuffixRefiner.ts", "../../chrono-node/src/locales/en/refiners/ENUnlikelyFormatFilter.ts", "../../chrono-node/src/locales/en/configuration.ts", "../../chrono-node/src/chrono.ts", "../../chrono-node/src/locales/de/index.ts", "../../chrono-node/src/locales/de/parsers/DETimeExpressionParser.ts", "../../chrono-node/src/locales/de/constants.ts", "../../chrono-node/src/locales/de/parsers/DEWeekdayParser.ts", "../../chrono-node/src/locales/de/parsers/DESpecificTimeExpressionParser.ts", "../../chrono-node/src/locales/de/refiners/DEMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/de/refiners/DEMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/de/parsers/DECasualTimeParser.ts", "../../chrono-node/src/locales/de/parsers/DECasualDateParser.ts", "../../chrono-node/src/locales/de/parsers/DEMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/de/parsers/DETimeUnitRelativeFormatParser.ts", "../../chrono-node/src/locales/de/parsers/DETimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/fr/index.ts", "../../chrono-node/src/locales/fr/parsers/FRCasualDateParser.ts", "../../chrono-node/src/locales/fr/parsers/FRCasualTimeParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeExpressionParser.ts", "../../chrono-node/src/locales/fr/refiners/FRMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/fr/refiners/FRMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/fr/constants.ts", "../../chrono-node/src/locales/fr/parsers/FRWeekdayParser.ts", "../../chrono-node/src/locales/fr/parsers/FRSpecificTimeExpressionParser.ts", "../../chrono-node/src/locales/fr/parsers/FRMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/fr/parsers/FRTimeUnitRelativeFormatParser.ts", "../../chrono-node/src/locales/ja/index.ts", "../../chrono-node/src/locales/ja/constants.ts", "../../chrono-node/src/locales/ja/parsers/JPStandardParser.ts", "../../chrono-node/src/locales/ja/refiners/JPMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/ja/parsers/JPCasualDateParser.ts", "../../chrono-node/src/locales/ja/parsers/JPWeekdayParser.ts", "../../chrono-node/src/locales/ja/parsers/JPSlashDateFormatParser.ts", "../../chrono-node/src/locales/ja/parsers/JPTimeExpressionParser.ts", "../../chrono-node/src/locales/ja/refiners/JPMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/ja/refiners/JPMergeWeekdayComponentRefiner.ts", "../../chrono-node/src/locales/ja/parsers/JPWeekdayWithParenthesesParser.ts", "../../chrono-node/src/locales/pt/index.ts", "../../chrono-node/src/locales/pt/constants.ts", "../../chrono-node/src/locales/pt/parsers/PTWeekdayParser.ts", "../../chrono-node/src/locales/pt/parsers/PTTimeExpressionParser.ts", "../../chrono-node/src/locales/pt/refiners/PTMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/pt/refiners/PTMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/pt/parsers/PTMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/pt/parsers/PTCasualDateParser.ts", "../../chrono-node/src/locales/pt/parsers/PTCasualTimeParser.ts", "../../chrono-node/src/locales/nl/index.ts", "../../chrono-node/src/locales/nl/refiners/NLMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/nl/refiners/NLMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualDateParser.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualTimeParser.ts", "../../chrono-node/src/locales/nl/constants.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLWeekdayParser.ts", "../../chrono-node/src/locales/nl/parsers/NLMonthNameMiddleEndianParser.ts", "../../chrono-node/src/locales/nl/parsers/NLMonthNameParser.ts", "../../chrono-node/src/locales/nl/parsers/NLSlashMonthFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeExpressionParser.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualYearMonthDayParser.ts", "../../chrono-node/src/locales/nl/parsers/NLCasualDateTimeParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLRelativeDateFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/nl/parsers/NLTimeUnitLaterFormatParser.ts", "../../chrono-node/src/locales/zh/index.ts", "../../chrono-node/src/locales/zh/hans/constants.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansDateParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansDeadlineFormatParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansRelationWeekdayParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansTimeExpressionParser.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansWeekdayParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantCasualDateParser.ts", "../../chrono-node/src/locales/zh/hant/constants.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantDateParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantDeadlineFormatParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantRelationWeekdayParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantTimeExpressionParser.ts", "../../chrono-node/src/locales/zh/hant/parsers/ZHHantWeekdayParser.ts", "../../chrono-node/src/locales/zh/hant/refiners/ZHHantMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/zh/hant/refiners/ZHHantMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/zh/hant/index.ts", "../../chrono-node/src/locales/zh/hans/index.ts", "../../chrono-node/src/locales/zh/hans/parsers/ZHHansCasualDateParser.ts", "../../chrono-node/src/locales/zh/hans/refiners/ZHHansMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/zh/hans/refiners/ZHHansMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/ru/index.ts", "../../chrono-node/src/locales/ru/constants.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/ru/parsers/AbstractParserWithWordBoundaryChecking.ts", "../../chrono-node/src/locales/ru/parsers/RUMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/ru/parsers/RUMonthNameParser.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeExpressionParser.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/ru/refiners/RUMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/ru/refiners/RUMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/ru/parsers/RUCasualDateParser.ts", "../../chrono-node/src/locales/ru/parsers/RUCasualTimeParser.ts", "../../chrono-node/src/locales/ru/parsers/RUWeekdayParser.ts", "../../chrono-node/src/locales/ru/parsers/RURelativeDateFormatParser.ts", "../../chrono-node/src/locales/ru/parsers/RUTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/es/index.ts", "../../chrono-node/src/locales/es/constants.ts", "../../chrono-node/src/locales/es/parsers/ESWeekdayParser.ts", "../../chrono-node/src/locales/es/parsers/ESTimeExpressionParser.ts", "../../chrono-node/src/locales/es/refiners/ESMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/es/refiners/ESMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/es/parsers/ESMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/es/parsers/ESCasualDateParser.ts", "../../chrono-node/src/locales/es/parsers/ESCasualTimeParser.ts", "../../chrono-node/src/locales/es/parsers/ESTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/uk/index.ts", "../../chrono-node/src/locales/uk/constants.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/uk/parsers/AbstractParserWithWordBoundaryChecking.ts", "../../chrono-node/src/locales/uk/parsers/UKMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/uk/parsers/UKMonthNameParser.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeExpressionParser.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/uk/refiners/UKMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/uk/refiners/UKMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/uk/parsers/UKCasualDateParser.ts", "../../chrono-node/src/locales/uk/parsers/UKCasualTimeParser.ts", "../../chrono-node/src/locales/uk/parsers/UKWeekdayParser.ts", "../../chrono-node/src/locales/uk/parsers/UKRelativeDateFormatParser.ts", "../../chrono-node/src/locales/uk/parsers/UKTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/it/index.ts", "../../chrono-node/src/locales/it/constants.ts", "../../chrono-node/src/locales/it/parsers/ITTimeUnitWithinFormatParser.ts", "../../chrono-node/src/locales/it/parsers/ITMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/it/parsers/ITMonthNameMiddleEndianParser.ts", "../../chrono-node/src/locales/it/parsers/ITMonthNameParser.ts", "../../chrono-node/src/locales/it/parsers/ITCasualYearMonthDayParser.ts", "../../chrono-node/src/locales/it/parsers/ITSlashMonthFormatParser.ts", "../../chrono-node/src/locales/it/parsers/ITTimeExpressionParser.ts", "../../chrono-node/src/locales/it/parsers/ITTimeUnitAgoFormatParser.ts", "../../chrono-node/src/locales/it/parsers/ITTimeUnitLaterFormatParser.ts", "../../chrono-node/src/locales/it/refiners/ITMergeDateRangeRefiner.ts", "../../chrono-node/src/locales/it/refiners/ITMergeDateTimeRefiner.ts", "../../chrono-node/src/locales/it/parsers/ITCasualDateParser.ts", "../../chrono-node/src/locales/it/parsers/ITCasualTimeParser.ts", "../../chrono-node/src/locales/it/parsers/ITWeekdayParser.ts", "../../chrono-node/src/locales/it/parsers/ITRelativeDateFormatParser.ts", "../../chrono-node/src/locales/it/parsers/ITTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/it/refiners/ITMergeRelativeDateRefiner.ts", "../../chrono-node/src/locales/sv/index.ts", "../../chrono-node/src/locales/sv/constants.ts", "../../chrono-node/src/locales/sv/parsers/SVWeekdayParser.ts", "../../chrono-node/src/locales/sv/parsers/SVMonthNameLittleEndianParser.ts", "../../chrono-node/src/locales/sv/parsers/SVTimeUnitCasualRelativeFormatParser.ts", "../../chrono-node/src/locales/sv/parsers/SVCasualDateParser.ts", "../../chrono-node/src/index.ts"],
  "sourcesContent": ["/**\n * Chrono components for English support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { Chrono, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\n\nimport ENDefaultConfiguration from \"./configuration\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\nexport const configuration = new ENDefaultConfiguration();\n\n/**\n * Chrono object configured for parsing *casual* English\n */\nexport const casual = new Chrono(configuration.createCasualConfiguration(false));\n\n/**\n * Chrono object configured for parsing *strict* English\n */\nexport const strict = new Chrono(configuration.createConfiguration(true, false));\n\n/**\n * Chrono object configured for parsing *UK-style* English\n */\nexport const GB = new Chrono(configuration.createCasualConfiguration(true));\n\n/**\n * A shortcut for en.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for en.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n", "import { DebugConsume, DebugHandler } from \"./debugging\";\n\nexport interface ParsingOption {\n    /**\n     * To parse only forward dates (the results should be after the reference date).\n     * This effects date/time implication (e.g. weekday or time mentioning)\n     */\n    forwardDate?: boolean;\n\n    /**\n     * Additional timezone keywords for the parsers to recognize.\n     * Any value provided will override the default handling of that value.\n     */\n    timezones?: TimezoneAbbrMap;\n\n    /**\n     * Internal debug event handler.\n     * @internal\n     */\n    debug?: DebugHandler | DebugConsume;\n}\n\n/**\n * Some timezone abbreviations are ambiguous in that they refer to different offsets\n * depending on the time of year — daylight savings time (DST), or non-DST. This interface\n * allows defining such timezones\n */\nexport interface AmbiguousTimezoneMap {\n    timezoneOffsetDuringDst: number;\n    timezoneOffsetNonDst: number;\n    /**\n     * Return the start date of DST for the given year.\n     * timezone.ts contains helper methods for common such rules.\n     */\n    dstStart: (year: number) => Date;\n    /**\n     * Return the end date of DST for the given year.\n     * timezone.ts contains helper methods for common such rules.\n     */\n    dstEnd: (year: number) => Date;\n}\n\n/**\n * A map describing how timezone abbreviations should map to time offsets.\n * Supports both unambigous mappings abbreviation => offset,\n * and ambiguous mappings, where the offset will depend on whether the\n * time in question is during daylight savings time or not.\n */\nexport type TimezoneAbbrMap = { [key: string]: number | AmbiguousTimezoneMap };\n\nexport interface ParsingReference {\n    /**\n     * Reference date. The instant (JavaScript Date object) when the input is written or mention.\n     * This effect date/time implication (e.g. weekday or time mentioning).\n     * (default = now)\n     */\n    instant?: Date;\n\n    /**\n     * Reference timezone. The timezone where the input is written or mention.\n     * Date/time implication will account the difference between input timezone and the current system timezone.\n     * (default = current timezone)\n     */\n    timezone?: string | number;\n}\n\n/**\n * Parsed result or final output.\n * Each result object represents a date/time (or date/time-range) mentioning in the input.\n */\nexport interface ParsedResult {\n    readonly refDate: Date;\n    readonly index: number;\n    readonly text: string;\n\n    readonly start: ParsedComponents;\n    readonly end?: ParsedComponents;\n\n    /**\n     * @return a javascript date object created from the `result.start`.\n     */\n    date(): Date;\n\n    /**\n     * @return debugging tags combined of the `result.start` and `result.end`.\n     */\n    tags(): Set<string>;\n}\n\n/**\n * A collection of parsed date/time components (e.g. day, hour, minute, ..., etc).\n *\n * Each parsed component has three different levels of certainty.\n * - *Certain* (or *Known*): The component is directly mentioned and parsed.\n * - *Implied*: The component is not directly mentioned, but implied by other parsed information.\n * - *Unknown*: Completely no mention of the component.\n */\nexport interface ParsedComponents {\n    /**\n     * Check the component certainly if the component is *Certain* (or *Known*)\n     */\n    isCertain(component: Component): boolean;\n\n    /**\n     * Get the component value for either *Certain* or *Implied* value.\n     */\n    get(component: Component): number | null;\n\n    /**\n     * @return a javascript date object.\n     */\n    date(): Date;\n\n    /**\n     * @return debugging tags of the parsed component.\n     */\n    tags(): Set<string>;\n}\n\nexport type Component =\n    | \"year\"\n    | \"month\"\n    | \"day\"\n    | \"weekday\"\n    | \"hour\"\n    | \"minute\"\n    | \"second\"\n    | \"millisecond\"\n    | \"meridiem\"\n    | \"timezoneOffset\";\n\nexport type Timeunit = \"year\" | \"month\" | \"week\" | \"day\" | \"hour\" | \"minute\" | \"second\" | \"millisecond\" | \"quarter\";\n\nexport enum Meridiem {\n    AM = 0,\n    PM = 1,\n}\n\nexport enum Weekday {\n    SUNDAY = 0,\n    MONDAY = 1,\n    TUESDAY = 2,\n    WEDNESDAY = 3,\n    THURSDAY = 4,\n    FRIDAY = 5,\n    SATURDAY = 6,\n}\n\nexport enum Month {\n    JANUARY = 1,\n    FEBRUARY = 2,\n    MARCH = 3,\n    APRIL = 4,\n    MAY = 5,\n    JUNE = 6,\n    JULY = 7,\n    AUGUST = 8,\n    SEPTEMBER = 9,\n    OCTOBER = 10,\n    NOVEMBER = 11,\n    DECEMBER = 12,\n}\n", "import { ParsingComponents } from \"../results\";\nimport { Meridiem } from \"../types\";\n\n/**\n * Assign (force update) the parsing component to the same day as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function assignSimilarDate(component: ParsingComponents, target: Date) {\n    component.assign(\"day\", target.getDate());\n    component.assign(\"month\", target.getMonth() + 1);\n    component.assign(\"year\", target.getFullYear());\n}\n\n/**\n * Assign (force update) the parsing component to the same time as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function assignSimilarTime(component: ParsingComponents, target: Date) {\n    component.assign(\"hour\", target.getHours());\n    component.assign(\"minute\", target.getMinutes());\n    component.assign(\"second\", target.getSeconds());\n    component.assign(\"millisecond\", target.getMilliseconds());\n    component.assign(\"meridiem\", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);\n}\n\n/**\n * Imply (weakly update) the parsing component to the same day as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function implySimilarDate(component: ParsingComponents, target: Date) {\n    component.imply(\"day\", target.getDate());\n    component.imply(\"month\", target.getMonth() + 1);\n    component.imply(\"year\", target.getFullYear());\n}\n\n/**\n * Imply (weakly update) the parsing component to the same time as the `target`.\n * @param component the component to be updated.\n * @param target the target date with timezone adjusted.\n */\nexport function implySimilarTime(component: ParsingComponents, target: Date) {\n    component.imply(\"hour\", target.getHours());\n    component.imply(\"minute\", target.getMinutes());\n    component.imply(\"second\", target.getSeconds());\n    component.imply(\"millisecond\", target.getMilliseconds());\n    component.imply(\"meridiem\", target.getHours() < 12 ? Meridiem.AM : Meridiem.PM);\n}\n", "import { TimezoneAbbrMap, Weekday, Month } from \"./types\";\n\nexport const TIMEZONE_ABBR_MAP: TimezoneAbbrMap = {\n    ACDT: 630,\n    ACST: 570,\n    ADT: -180,\n    AEDT: 660,\n    AEST: 600,\n    AFT: 270,\n    AKDT: -480,\n    AKST: -540,\n    ALMT: 360,\n    AMST: -180,\n    AMT: -240,\n    ANAST: 720,\n    ANAT: 720,\n    AQTT: 300,\n    ART: -180,\n    AST: -240,\n    AWDT: 540,\n    AWST: 480,\n    AZOST: 0,\n    AZOT: -60,\n    AZST: 300,\n    AZT: 240,\n    BNT: 480,\n    BOT: -240,\n    BRST: -120,\n    BRT: -180,\n    BST: 60,\n    BTT: 360,\n    CAST: 480,\n    CAT: 120,\n    CCT: 390,\n    CDT: -300,\n    CEST: 120,\n    // Note: Many sources define CET as a constant UTC+1. In common usage, however,\n    // CET usually refers to the time observed in most of Europe, be it standard time or daylight saving time.\n    CET: {\n        timezoneOffsetDuringDst: 2 * 60,\n        timezoneOffsetNonDst: 60,\n        dstStart: (year: number) => getLastWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2),\n        dstEnd: (year: number) => getLastWeekdayOfMonth(year, Month.OCTOBER, Weekday.SUNDAY, 3),\n    },\n    CHADT: 825,\n    CHAST: 765,\n    CKT: -600,\n    CLST: -180,\n    CLT: -240,\n    COT: -300,\n    CST: -360,\n    CT: {\n        timezoneOffsetDuringDst: -5 * 60,\n        timezoneOffsetNonDst: -6 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    CVT: -60,\n    CXT: 420,\n    ChST: 600,\n    DAVT: 420,\n    EASST: -300,\n    EAST: -360,\n    EAT: 180,\n    ECT: -300,\n    EDT: -240,\n    EEST: 180,\n    EET: 120,\n    EGST: 0,\n    EGT: -60,\n    EST: -300,\n    ET: {\n        timezoneOffsetDuringDst: -4 * 60,\n        timezoneOffsetNonDst: -5 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    FJST: 780,\n    FJT: 720,\n    FKST: -180,\n    FKT: -240,\n    FNT: -120,\n    GALT: -360,\n    GAMT: -540,\n    GET: 240,\n    GFT: -180,\n    GILT: 720,\n    GMT: 0,\n    GST: 240,\n    GYT: -240,\n    HAA: -180,\n    HAC: -300,\n    HADT: -540,\n    HAE: -240,\n    HAP: -420,\n    HAR: -360,\n    HAST: -600,\n    HAT: -90,\n    HAY: -480,\n    HKT: 480,\n    HLV: -210,\n    HNA: -240,\n    HNC: -360,\n    HNE: -300,\n    HNP: -480,\n    HNR: -420,\n    HNT: -150,\n    HNY: -540,\n    HOVT: 420,\n    ICT: 420,\n    IDT: 180,\n    IOT: 360,\n    IRDT: 270,\n    IRKST: 540,\n    IRKT: 540,\n    IRST: 210,\n    IST: 330,\n    JST: 540,\n    KGT: 360,\n    KRAST: 480,\n    KRAT: 480,\n    KST: 540,\n    KUYT: 240,\n    LHDT: 660,\n    LHST: 630,\n    LINT: 840,\n    MAGST: 720,\n    MAGT: 720,\n    MART: -510,\n    MAWT: 300,\n    MDT: -360,\n    MESZ: 120,\n    MEZ: 60,\n    MHT: 720,\n    MMT: 390,\n    MSD: 240,\n    MSK: 180,\n    MST: -420,\n    MT: {\n        timezoneOffsetDuringDst: -6 * 60,\n        timezoneOffsetNonDst: -7 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    MUT: 240,\n    MVT: 300,\n    MYT: 480,\n    NCT: 660,\n    NDT: -90,\n    NFT: 690,\n    NOVST: 420,\n    NOVT: 360,\n    NPT: 345,\n    NST: -150,\n    NUT: -660,\n    NZDT: 780,\n    NZST: 720,\n    OMSST: 420,\n    OMST: 420,\n    PDT: -420,\n    PET: -300,\n    PETST: 720,\n    PETT: 720,\n    PGT: 600,\n    PHOT: 780,\n    PHT: 480,\n    PKT: 300,\n    PMDT: -120,\n    PMST: -180,\n    PONT: 660,\n    PST: -480,\n    PT: {\n        timezoneOffsetDuringDst: -7 * 60,\n        timezoneOffsetNonDst: -8 * 60,\n        dstStart: (year: number) => getNthWeekdayOfMonth(year, Month.MARCH, Weekday.SUNDAY, 2, 2),\n        dstEnd: (year: number) => getNthWeekdayOfMonth(year, Month.NOVEMBER, Weekday.SUNDAY, 1, 2),\n    },\n    PWT: 540,\n    PYST: -180,\n    PYT: -240,\n    RET: 240,\n    SAMT: 240,\n    SAST: 120,\n    SBT: 660,\n    SCT: 240,\n    SGT: 480,\n    SRT: -180,\n    SST: -660,\n    TAHT: -600,\n    TFT: 300,\n    TJT: 300,\n    TKT: 780,\n    TLT: 540,\n    TMT: 300,\n    TVT: 720,\n    ULAT: 480,\n    UTC: 0,\n    UYST: -120,\n    UYT: -180,\n    UZT: 300,\n    VET: -210,\n    VLAST: 660,\n    VLAT: 660,\n    VUT: 660,\n    WAST: 120,\n    WAT: 60,\n    WEST: 60,\n    WESZ: 60,\n    WET: 0,\n    WEZ: 0,\n    WFT: 720,\n    WGST: -120,\n    WGT: -180,\n    WIB: 420,\n    WIT: 540,\n    WITA: 480,\n    WST: 780,\n    WT: 0,\n    YAKST: 600,\n    YAKT: 600,\n    YAPT: 600,\n    YEKST: 360,\n    YEKT: 360,\n};\n\n/**\n * Get the date which is the nth occurence of a given weekday in a given month and year.\n *\n * @param year The year for which to find the date\n * @param month The month in which the date occurs\n * @param weekday The weekday on which the date occurs\n * @param n The nth occurence of the given weekday on the month to return\n * @param hour The hour of day which should be set on the returned date\n * @return The date which is the nth occurence of a given weekday in a given\n *         month and year, at the given hour of day\n */\nexport function getNthWeekdayOfMonth(year: number, month: Month, weekday: Weekday, n: 1 | 2 | 3 | 4, hour = 0): Date {\n    let dayOfMonth = 0;\n    let i = 0;\n    while (i < n) {\n        dayOfMonth++;\n        const date = new Date(year, month - 1, dayOfMonth);\n        if (date.getDay() === weekday) i++;\n    }\n    return new Date(year, month - 1, dayOfMonth, hour);\n}\n\n/**\n * Get the date which is the last occurence of a given weekday in a given month and year.\n *\n * @param year The year for which to find the date\n * @param month The month in which the date occurs\n * @param weekday The weekday on which the date occurs\n * @param hour The hour of day which should be set on the returned date\n * @return The date which is the last occurence of a given weekday in a given\n *         month and year, at the given hour of day\n */\nexport function getLastWeekdayOfMonth(year: number, month: Month, weekday: Weekday, hour = 0): Date {\n    // Procedure: Find the first weekday of the next month, compare with the given weekday,\n    // and use the difference to determine how many days to subtract from the first of the next month.\n    const oneIndexedWeekday = weekday === 0 ? 7 : weekday;\n    const date = new Date(year, month - 1 + 1, 1, 12);\n    const firstWeekdayNextMonth = date.getDay() === 0 ? 7 : date.getDay();\n    let dayDiff;\n    if (firstWeekdayNextMonth === oneIndexedWeekday) dayDiff = 7;\n    else if (firstWeekdayNextMonth < oneIndexedWeekday) dayDiff = 7 + firstWeekdayNextMonth - oneIndexedWeekday;\n    else dayDiff = firstWeekdayNextMonth - oneIndexedWeekday;\n    date.setDate(date.getDate() - dayDiff);\n    return new Date(year, month - 1, date.getDate(), hour);\n}\n\n/**\n * Finds and returns timezone offset. If timezoneInput is numeric, it is returned. Otherwise, look for timezone offsets\n * in the following order: timezoneOverrides -> {@link TIMEZONE_ABBR_MAP}.\n *\n * @param timezoneInput Uppercase timezone abbreviation or numeric offset in minutes\n * @param date The date to use to determine whether to return DST offsets for ambiguous timezones\n * @param timezoneOverrides Overrides for timezones\n * @return timezone offset in minutes\n */\nexport function toTimezoneOffset(\n    timezoneInput?: string | number,\n    date?: Date,\n    timezoneOverrides: TimezoneAbbrMap = {}\n): number | null {\n    if (timezoneInput == null) {\n        return null;\n    }\n\n    if (typeof timezoneInput === \"number\") {\n        return timezoneInput;\n    }\n\n    const matchedTimezone = timezoneOverrides[timezoneInput] ?? TIMEZONE_ABBR_MAP[timezoneInput];\n    if (matchedTimezone == null) {\n        return null;\n    }\n    // This means that we have matched an unambiguous timezone\n    if (typeof matchedTimezone == \"number\") {\n        return matchedTimezone;\n    }\n\n    // The matched timezone is an ambiguous timezone, where the offset depends on whether the context (refDate)\n    // is during daylight savings or not.\n\n    // Without refDate as context, there's no way to know if DST or non-DST offset should be used. Return null instead.\n    if (date == null) {\n        return null;\n    }\n\n    // Return DST offset if the refDate is during daylight savings\n    if (date > matchedTimezone.dstStart(date.getFullYear()) && !(date > matchedTimezone.dstEnd(date.getFullYear()))) {\n        return matchedTimezone.timezoneOffsetDuringDst;\n    }\n\n    // refDate is not during DST => return non-DST offset\n    return matchedTimezone.timezoneOffsetNonDst;\n}\n", "import { Timeunit } from \"../types\";\n\nexport type TimeunitShorten = \"y\" | \"mo\" | \"M\" | \"w\" | \"d\" | \"h\" | \"m\" | \"s\" | \"ms\";\nexport type TimeunitSpecial = \"quarter\";\n\n/**\n * A type represent a directed time duration as a set of values by timeunits.\n * The positive values mean the time duration into the future.\n */\nexport type Duration = { [c in Timeunit | TimeunitSpecial | TimeunitShorten]?: number };\n\n/**\n * An explicit empty duration (not just empty duration object).\n * This is defined as zero day and second.\n */\nexport const EmptyDuration = {\n    day: 0,\n    second: 0,\n    millisecond: 0,\n};\n\n/**\n * Returns the date after adding the given `duration` to `ref`.\n * @param ref\n * @param duration\n */\nexport function addDuration(ref: Date, duration: Duration): Date {\n    let date = new Date(ref);\n\n    // Replace short timeunit keys with full timeunit keys\n    if (duration[\"y\"]) {\n        duration[\"year\"] = duration[\"y\"];\n        delete duration[\"y\"];\n    }\n    if (duration[\"mo\"]) {\n        duration[\"month\"] = duration[\"mo\"];\n        delete duration[\"mo\"];\n    }\n    if (duration[\"M\"]) {\n        duration[\"month\"] = duration[\"M\"];\n        delete duration[\"M\"];\n    }\n    if (duration[\"w\"]) {\n        duration[\"week\"] = duration[\"w\"];\n        delete duration[\"w\"];\n    }\n    if (duration[\"d\"]) {\n        duration[\"day\"] = duration[\"d\"];\n        delete duration[\"d\"];\n    }\n    if (duration[\"h\"]) {\n        duration[\"hour\"] = duration[\"h\"];\n        delete duration[\"h\"];\n    }\n    if (duration[\"m\"]) {\n        duration[\"minute\"] = duration[\"m\"];\n        delete duration[\"m\"];\n    }\n    if (duration[\"s\"]) {\n        duration[\"second\"] = duration[\"s\"];\n        delete duration[\"s\"];\n    }\n    if (duration[\"ms\"]) {\n        duration[\"millisecond\"] = duration[\"ms\"];\n        delete duration[\"ms\"];\n    }\n\n    if (\"year\" in duration) {\n        const floor = Math.floor(duration[\"year\"]);\n        date.setFullYear(date.getFullYear() + floor);\n        const remainingFraction = duration[\"year\"] - floor;\n        if (remainingFraction > 0) {\n            duration.month = duration?.month ?? 0;\n            duration.month += remainingFraction * 12;\n        }\n    }\n    if (\"quarter\" in duration) {\n        const floor = Math.floor(duration[\"quarter\"]);\n        date.setMonth(date.getMonth() + floor * 3);\n    }\n    if (\"month\" in duration) {\n        const floor = Math.floor(duration[\"month\"]);\n        date.setMonth(date.getMonth() + floor);\n        const remainingFraction = duration[\"month\"] - floor;\n        if (remainingFraction > 0) {\n            duration.week = duration?.week ?? 0;\n            duration.week += remainingFraction * 4;\n        }\n    }\n    if (\"week\" in duration) {\n        const floor = Math.floor(duration[\"week\"]);\n        date.setDate(date.getDate() + floor * 7);\n        const remainingFraction = duration[\"week\"] - floor;\n        if (remainingFraction > 0) {\n            duration.day = duration?.day ?? 0;\n            duration.day += Math.round(remainingFraction * 7);\n        }\n    }\n    if (\"day\" in duration) {\n        const floor = Math.floor(duration[\"day\"]);\n        date.setDate(date.getDate() + floor);\n        const remainingFraction = duration[\"day\"] - floor;\n        if (remainingFraction > 0) {\n            duration.hour = duration?.hour ?? 0;\n            duration.hour += Math.round(remainingFraction * 24);\n        }\n    }\n    if (\"hour\" in duration) {\n        const floor = Math.floor(duration[\"hour\"]);\n        date.setHours(date.getHours() + floor);\n        const remainingFraction = duration[\"hour\"] - floor;\n        if (remainingFraction > 0) {\n            duration.minute = duration?.minute ?? 0;\n            duration.minute += Math.round(remainingFraction * 60);\n        }\n    }\n    if (\"minute\" in duration) {\n        const floor = Math.floor(duration[\"minute\"]);\n        date.setMinutes(date.getMinutes() + floor);\n        const remainingFraction = duration[\"minute\"] - floor;\n        if (remainingFraction > 0) {\n            duration.second = duration?.second ?? 0;\n            duration.second += Math.round(remainingFraction * 60);\n        }\n    }\n    if (\"second\" in duration) {\n        const floor = Math.floor(duration[\"second\"]);\n        date.setSeconds(date.getSeconds() + floor);\n        const remainingFraction = duration[\"second\"] - floor;\n        if (remainingFraction > 0) {\n            duration.millisecond = duration?.millisecond ?? 0;\n            duration.millisecond += Math.round(remainingFraction * 1000);\n        }\n    }\n    if (\"millisecond\" in duration) {\n        const floor = Math.floor(duration[\"millisecond\"]);\n        date.setMilliseconds(date.getMilliseconds() + floor);\n    }\n    return date;\n}\n\n/**\n * Return the reversed duration (e.g. back into the past, instead of future)\n * @param duration\n */\nexport function reverseDuration(duration: Duration): Duration {\n    const reversed = {};\n    for (const key in duration) {\n        // noinspection JSUnfilteredForInLoop\n        reversed[key] = -duration[key];\n    }\n    return reversed as Duration;\n}\n", "import { Component, ParsedComponents, ParsedResult, ParsingReference, TimezoneAbbrMap } from \"./types\";\n\nimport { assignSimilarDate, assignSimilarTime, implySimilarTime } from \"./utils/dates\";\nimport { toTimezoneOffset } from \"./timezone\";\nimport { addDuration, Duration, EmptyDuration } from \"./calculation/duration\";\n\nexport class ReferenceWithTimezone {\n    readonly instant: Date;\n    readonly timezoneOffset?: number | null;\n\n    constructor(instant?: Date, timezoneOffset?: number) {\n        this.instant = instant ?? new Date();\n        this.timezoneOffset = timezoneOffset ?? null;\n    }\n\n    static fromDate(date: Date): ReferenceWithTimezone {\n        return new ReferenceWithTimezone(date);\n    }\n\n    static fromInput(input?: ParsingReference | Date, timezoneOverrides?: TimezoneAbbrMap) {\n        if (input instanceof Date) {\n            return ReferenceWithTimezone.fromDate(input);\n        }\n        const instant: Date = input?.instant ?? new Date();\n        const timezoneOffset = toTimezoneOffset(input?.timezone, instant, timezoneOverrides);\n        return new ReferenceWithTimezone(instant, timezoneOffset);\n    }\n\n    /**\n     * Returns a JS date (system timezone) with the { year, month, day, hour, minute, second } equal to the reference.\n     * The output's instant is NOT the reference's instant when the reference's and system's timezone are different.\n     */\n    getDateWithAdjustedTimezone() {\n        const date = new Date(this.instant);\n        if (this.timezoneOffset !== null) {\n            date.setMinutes(date.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant));\n        }\n        return date;\n    }\n\n    /**\n     * Returns the number minutes difference between the JS date's timezone and the reference timezone.\n     * @param date\n     * @param overrideTimezoneOffset\n     */\n    getSystemTimezoneAdjustmentMinute(date?: Date, overrideTimezoneOffset?: number): number {\n        if (!date || date.getTime() < 0) {\n            // Javascript date timezone calculation got effect when the time epoch < 0\n            // e.g. new Date('Tue Feb 02 1300 00:00:00 GMT+0900 (JST)') => Tue Feb 02 1300 00:18:59 GMT+0918 (JST)\n            date = new Date();\n        }\n\n        const currentTimezoneOffset = -date.getTimezoneOffset();\n        const targetTimezoneOffset = overrideTimezoneOffset ?? this.timezoneOffset ?? currentTimezoneOffset;\n        return currentTimezoneOffset - targetTimezoneOffset;\n    }\n\n    getTimezoneOffset(): number {\n        return this.timezoneOffset ?? -this.instant.getTimezoneOffset();\n    }\n}\n\nexport class ParsingComponents implements ParsedComponents {\n    private knownValues: { [c in Component]?: number };\n    private impliedValues: { [c in Component]?: number };\n    private reference: ReferenceWithTimezone;\n    private _tags = new Set<string>();\n\n    constructor(reference: ReferenceWithTimezone, knownComponents?: { [c in Component]?: number }) {\n        this.reference = reference;\n        this.knownValues = {};\n        this.impliedValues = {};\n        if (knownComponents) {\n            for (const key in knownComponents) {\n                this.knownValues[key as Component] = knownComponents[key as Component];\n            }\n        }\n\n        const date = reference.getDateWithAdjustedTimezone();\n        this.imply(\"day\", date.getDate());\n        this.imply(\"month\", date.getMonth() + 1);\n        this.imply(\"year\", date.getFullYear());\n        this.imply(\"hour\", 12);\n        this.imply(\"minute\", 0);\n        this.imply(\"second\", 0);\n        this.imply(\"millisecond\", 0);\n    }\n\n    static createRelativeFromReference(\n        reference: ReferenceWithTimezone,\n        duration: Duration = EmptyDuration\n    ): ParsingComponents {\n        let date = addDuration(reference.getDateWithAdjustedTimezone(), duration);\n\n        const components = new ParsingComponents(reference);\n        components.addTag(\"result/relativeDate\");\n        if (\"hour\" in duration || \"minute\" in duration || \"second\" in duration || \"millisecond\" in duration) {\n            components.addTag(\"result/relativeDateAndTime\");\n            assignSimilarTime(components, date);\n            assignSimilarDate(components, date);\n            components.assign(\"timezoneOffset\", reference.getTimezoneOffset());\n        } else {\n            implySimilarTime(components, date);\n            components.imply(\"timezoneOffset\", reference.getTimezoneOffset());\n\n            if (\"day\" in duration) {\n                components.assign(\"day\", date.getDate());\n                components.assign(\"month\", date.getMonth() + 1);\n                components.assign(\"year\", date.getFullYear());\n                components.assign(\"weekday\", date.getDay());\n            } else if (\"week\" in duration) {\n                components.assign(\"day\", date.getDate());\n                components.assign(\"month\", date.getMonth() + 1);\n                components.assign(\"year\", date.getFullYear());\n                components.imply(\"weekday\", date.getDay());\n            } else {\n                components.imply(\"day\", date.getDate());\n                if (\"month\" in duration) {\n                    components.assign(\"month\", date.getMonth() + 1);\n                    components.assign(\"year\", date.getFullYear());\n                } else {\n                    components.imply(\"month\", date.getMonth() + 1);\n                    if (\"year\" in duration) {\n                        components.assign(\"year\", date.getFullYear());\n                    } else {\n                        components.imply(\"year\", date.getFullYear());\n                    }\n                }\n            }\n        }\n\n        return components;\n    }\n\n    get(component: Component): number | null {\n        if (component in this.knownValues) {\n            return this.knownValues[component];\n        }\n\n        if (component in this.impliedValues) {\n            return this.impliedValues[component];\n        }\n\n        return null;\n    }\n\n    isCertain(component: Component): boolean {\n        return component in this.knownValues;\n    }\n\n    getCertainComponents(): Array<Component> {\n        return Object.keys(this.knownValues) as Array<Component>;\n    }\n\n    imply(component: Component, value: number): ParsingComponents {\n        if (component in this.knownValues) {\n            return this;\n        }\n        this.impliedValues[component] = value;\n        return this;\n    }\n\n    assign(component: Component, value: number): ParsingComponents {\n        this.knownValues[component] = value;\n        delete this.impliedValues[component];\n        return this;\n    }\n\n    /**\n     * Add the `duration` into this component, mark the modified date and/or time as implied.\n     * @param duration\n     */\n    addDurationAsImplied(duration: Duration): ParsingComponents {\n        const currentDate = this.dateWithoutTimezoneAdjustment();\n        const date = addDuration(currentDate, duration);\n        if (\"day\" in duration || \"week\" in duration || \"month\" in duration || \"year\" in duration) {\n            this.delete([\"day\", \"weekday\", \"month\", \"year\"]);\n            this.imply(\"day\", date.getDate());\n            this.imply(\"weekday\", date.getDay());\n            this.imply(\"month\", date.getMonth() + 1);\n            this.imply(\"year\", date.getFullYear());\n        }\n        if (\"second\" in duration || \"minute\" in duration || \"hour\" in duration) {\n            this.delete([\"second\", \"minute\", \"hour\"]);\n            this.imply(\"second\", date.getSeconds());\n            this.imply(\"minute\", date.getMinutes());\n            this.imply(\"hour\", date.getHours());\n        }\n        return this;\n    }\n\n    delete(components: Component | Component[]) {\n        if (typeof components === \"string\") {\n            components = [components];\n        }\n        for (const component of components) {\n            delete this.knownValues[component];\n            delete this.impliedValues[component];\n        }\n    }\n\n    clone(): ParsingComponents {\n        const component = new ParsingComponents(this.reference);\n        component.knownValues = {};\n        component.impliedValues = {};\n\n        for (const key in this.knownValues) {\n            component.knownValues[key as Component] = this.knownValues[key as Component];\n        }\n\n        for (const key in this.impliedValues) {\n            component.impliedValues[key as Component] = this.impliedValues[key as Component];\n        }\n\n        return component;\n    }\n\n    isOnlyDate(): boolean {\n        return !this.isCertain(\"hour\") && !this.isCertain(\"minute\") && !this.isCertain(\"second\");\n    }\n\n    isOnlyTime(): boolean {\n        return (\n            !this.isCertain(\"weekday\") && !this.isCertain(\"day\") && !this.isCertain(\"month\") && !this.isCertain(\"year\")\n        );\n    }\n\n    isOnlyWeekdayComponent(): boolean {\n        return this.isCertain(\"weekday\") && !this.isCertain(\"day\") && !this.isCertain(\"month\");\n    }\n\n    isDateWithUnknownYear(): boolean {\n        return this.isCertain(\"month\") && !this.isCertain(\"year\");\n    }\n\n    isValidDate(): boolean {\n        const date = this.dateWithoutTimezoneAdjustment();\n\n        if (date.getFullYear() !== this.get(\"year\")) return false;\n        if (date.getMonth() !== this.get(\"month\") - 1) return false;\n        if (date.getDate() !== this.get(\"day\")) return false;\n        if (this.get(\"hour\") != null && date.getHours() != this.get(\"hour\")) return false;\n        if (this.get(\"minute\") != null && date.getMinutes() != this.get(\"minute\")) return false;\n\n        return true;\n    }\n\n    toString() {\n        return `[ParsingComponents {\n            tags: ${JSON.stringify(Array.from(this._tags).sort())}, \n            knownValues: ${JSON.stringify(this.knownValues)}, \n            impliedValues: ${JSON.stringify(this.impliedValues)}}, \n            reference: ${JSON.stringify(this.reference)}]`;\n    }\n\n    date(): Date {\n        const date = this.dateWithoutTimezoneAdjustment();\n        const timezoneAdjustment = this.reference.getSystemTimezoneAdjustmentMinute(date, this.get(\"timezoneOffset\"));\n        return new Date(date.getTime() + timezoneAdjustment * 60000);\n    }\n\n    addTag(tag: string): ParsingComponents {\n        this._tags.add(tag);\n        return this;\n    }\n\n    addTags(tags: string[] | Set<string>): ParsingComponents {\n        for (const tag of tags) {\n            this._tags.add(tag);\n        }\n        return this;\n    }\n\n    tags(): Set<string> {\n        return new Set(this._tags);\n    }\n\n    private dateWithoutTimezoneAdjustment() {\n        const date = new Date(\n            this.get(\"year\"),\n            this.get(\"month\") - 1,\n            this.get(\"day\"),\n            this.get(\"hour\"),\n            this.get(\"minute\"),\n            this.get(\"second\"),\n            this.get(\"millisecond\")\n        );\n\n        date.setFullYear(this.get(\"year\"));\n        return date;\n    }\n}\n\nexport class ParsingResult implements ParsedResult {\n    refDate: Date;\n    index: number;\n    text: string;\n\n    reference: ReferenceWithTimezone;\n\n    start: ParsingComponents;\n    end?: ParsingComponents;\n\n    constructor(\n        reference: ReferenceWithTimezone,\n        index: number,\n        text: string,\n        start?: ParsingComponents,\n        end?: ParsingComponents\n    ) {\n        this.reference = reference;\n        this.refDate = reference.instant;\n        this.index = index;\n        this.text = text;\n        this.start = start || new ParsingComponents(reference);\n        this.end = end;\n    }\n\n    clone() {\n        const result = new ParsingResult(this.reference, this.index, this.text);\n        result.start = this.start ? this.start.clone() : null;\n        result.end = this.end ? this.end.clone() : null;\n        return result;\n    }\n\n    date(): Date {\n        return this.start.date();\n    }\n\n    addTag(tag: string): ParsingResult {\n        this.start.addTag(tag);\n        if (this.end) {\n            this.end.addTag(tag);\n        }\n        return this;\n    }\n\n    addTags(tags: string[] | Set<string>): ParsingResult {\n        this.start.addTags(tags);\n        if (this.end) {\n            this.end.addTags(tags);\n        }\n        return this;\n    }\n\n    tags(): Set<string> {\n        const combinedTags: Set<string> = new Set(this.start.tags());\n        if (this.end) {\n            for (const tag of this.end.tags()) {\n                combinedTags.add(tag);\n            }\n        }\n        return combinedTags;\n    }\n\n    toString() {\n        const tags = Array.from(this.tags()).sort();\n        return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(tags)} ...}]`;\n    }\n}\n", "type DictionaryLike = string[] | { [word: string]: unknown } | Map<string, unknown>;\n\nexport function repeatedTimeunitPattern(\n    prefix: string,\n    singleTimeunitPattern: string,\n    connectorPattern = \"\\\\s{0,5},?\\\\s{0,5}\"\n): string {\n    const singleTimeunitPatternNoCapture = singleTimeunitPattern.replace(/\\((?!\\?)/g, \"(?:\");\n    return `${prefix}${singleTimeunitPatternNoCapture}(?:${connectorPattern}${singleTimeunitPatternNoCapture}){0,10}`;\n}\n\nexport function extractTerms(dictionary: DictionaryLike): string[] {\n    let keys: string[];\n    if (dictionary instanceof Array) {\n        keys = [...dictionary];\n    } else if (dictionary instanceof Map) {\n        keys = Array.from((dictionary as Map<string, unknown>).keys());\n    } else {\n        keys = Object.keys(dictionary);\n    }\n\n    return keys;\n}\n\nexport function matchAnyPattern(dictionary: DictionaryLike): string {\n    // TODO: More efficient regex pattern by considering duplicated prefix\n\n    const joinedTerms = extractTerms(dictionary)\n        .sort((a, b) => b.length - a.length)\n        .join(\"|\")\n        .replace(/\\./g, \"\\\\.\");\n\n    return `(?:${joinedTerms})`;\n}\n", "import { addDuration } from \"./duration\";\n\n/**\n * Find the most likely year, from a raw number. For example:\n * 1997 => 1997\n * 97 => 1997\n * 12 => 2012\n */\nexport function findMostLikelyADYear(yearNumber: number): number {\n    if (yearNumber < 100) {\n        if (yearNumber > 50) {\n            yearNumber = yearNumber + 1900;\n        } else {\n            yearNumber = yearNumber + 2000;\n        }\n    }\n\n    return yearNumber;\n}\n\nexport function findYearClosestToRef(refDate: Date, day: number, month: number): number {\n    let date = new Date(refDate);\n    date.setMonth(month - 1);\n    date.setDate(day);\n    const nextYear = addDuration(date, { \"year\": 1 });\n    const lastYear = addDuration(date, { \"year\": -1 });\n    if (Math.abs(nextYear.getTime() - refDate.getTime()) < Math.abs(date.getTime() - refDate.getTime())) {\n        date = nextYear;\n    } else if (Math.abs(lastYear.getTime() - refDate.getTime()) < Math.abs(date.getTime() - refDate.getTime())) {\n        date = lastYear;\n    }\n    return date.getFullYear();\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit, Weekday } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: Weekday } = {\n    sunday: 0,\n    sun: 0,\n    \"sun.\": 0,\n    monday: 1,\n    mon: 1,\n    \"mon.\": 1,\n    tuesday: 2,\n    tue: 2,\n    \"tue.\": 2,\n    wednesday: 3,\n    wed: 3,\n    \"wed.\": 3,\n    thursday: 4,\n    thurs: 4,\n    \"thurs.\": 4,\n    thur: 4,\n    \"thur.\": 4,\n    thu: 4,\n    \"thu.\": 4,\n    friday: 5,\n    fri: 5,\n    \"fri.\": 5,\n    saturday: 6,\n    sat: 6,\n    \"sat.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    january: 1,\n    february: 2,\n    march: 3,\n    april: 4,\n    may: 5,\n    june: 6,\n    july: 7,\n    august: 8,\n    september: 9,\n    october: 10,\n    november: 11,\n    december: 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    jan: 1,\n    \"jan.\": 1,\n    feb: 2,\n    \"feb.\": 2,\n    mar: 3,\n    \"mar.\": 3,\n    apr: 4,\n    \"apr.\": 4,\n    jun: 6,\n    \"jun.\": 6,\n    jul: 7,\n    \"jul.\": 7,\n    aug: 8,\n    \"aug.\": 8,\n    sep: 9,\n    \"sep.\": 9,\n    sept: 9,\n    \"sept.\": 9,\n    oct: 10,\n    \"oct.\": 10,\n    nov: 11,\n    \"nov.\": 11,\n    dec: 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    one: 1,\n    two: 2,\n    three: 3,\n    four: 4,\n    five: 5,\n    six: 6,\n    seven: 7,\n    eight: 8,\n    nine: 9,\n    ten: 10,\n    eleven: 11,\n    twelve: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    first: 1,\n    second: 2,\n    third: 3,\n    fourth: 4,\n    fifth: 5,\n    sixth: 6,\n    seventh: 7,\n    eighth: 8,\n    ninth: 9,\n    tenth: 10,\n    eleventh: 11,\n    twelfth: 12,\n    thirteenth: 13,\n    fourteenth: 14,\n    fifteenth: 15,\n    sixteenth: 16,\n    seventeenth: 17,\n    eighteenth: 18,\n    nineteenth: 19,\n    twentieth: 20,\n    \"twenty first\": 21,\n    \"twenty-first\": 21,\n    \"twenty second\": 22,\n    \"twenty-second\": 22,\n    \"twenty third\": 23,\n    \"twenty-third\": 23,\n    \"twenty fourth\": 24,\n    \"twenty-fourth\": 24,\n    \"twenty fifth\": 25,\n    \"twenty-fifth\": 25,\n    \"twenty sixth\": 26,\n    \"twenty-sixth\": 26,\n    \"twenty seventh\": 27,\n    \"twenty-seventh\": 27,\n    \"twenty eighth\": 28,\n    \"twenty-eighth\": 28,\n    \"twenty ninth\": 29,\n    \"twenty-ninth\": 29,\n    \"thirtieth\": 30,\n    \"thirty first\": 31,\n    \"thirty-first\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY_NO_ABBR: { [word: string]: Timeunit } = {\n    second: \"second\",\n    seconds: \"second\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    hour: \"hour\",\n    hours: \"hour\",\n    day: \"day\",\n    days: \"day\",\n    week: \"week\",\n    weeks: \"week\",\n    month: \"month\",\n    months: \"month\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    year: \"year\",\n    years: \"year\",\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    s: \"second\",\n    sec: \"second\",\n    second: \"second\",\n    seconds: \"second\",\n    m: \"minute\",\n    min: \"minute\",\n    mins: \"minute\",\n    minute: \"minute\",\n    minutes: \"minute\",\n    h: \"hour\",\n    hr: \"hour\",\n    hrs: \"hour\",\n    hour: \"hour\",\n    hours: \"hour\",\n    d: \"day\",\n    day: \"day\",\n    days: \"day\",\n    w: \"week\",\n    week: \"week\",\n    weeks: \"week\",\n    mo: \"month\",\n    mon: \"month\",\n    mos: \"month\",\n    month: \"month\",\n    months: \"month\",\n    qtr: \"quarter\",\n    quarter: \"quarter\",\n    quarters: \"quarter\",\n    y: \"year\",\n    yr: \"year\",\n    year: \"year\",\n    years: \"year\",\n    // Also, merge the entries from the full-name dictionary.\n    // We leave the duplicated entries for readability.\n    ...TIME_UNIT_DICTIONARY_NO_ABBR,\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|half(?:\\\\s{0,2}an?)?|an?\\\\b(?:\\\\s{0,2}few)?|few|several|the|a?\\\\s{0,2}couple\\\\s{0,2}(?:of)?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"a\" || num === \"an\" || num == \"the\") {\n        return 1;\n    } else if (num.match(/few/)) {\n        return 3;\n    } else if (num.match(/half/)) {\n        return 0.5;\n    } else if (num.match(/couple/)) {\n        return 2;\n    } else if (num.match(/several/)) {\n        return 7;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:st|nd|rd|th)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n\n    num = num.replace(/(?:st|nd|rd|th)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])`;\nexport function parseYear(match: string): number {\n    if (/BE/i.test(match)) {\n        // Buddhist Era\n        match = match.replace(/BE/i, \"\");\n        return parseInt(match) - 543;\n    }\n\n    if (/BCE?/i.test(match)) {\n        // Before Christ, Before Common Era\n        match = match.replace(/BCE?/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(AD|CE)/i.test(match)) {\n        // Anno Domini, Common Era\n        match = match.replace(/(AD|CE)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nconst SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(\n    TIME_UNIT_DICTIONARY_NO_ABBR\n)})`;\n\nconst TIME_UNIT_CONNECTOR_PATTERN = `\\\\s{0,5},?(?:\\\\s*and)?\\\\s{0,5}`;\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:about|around)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_PATTERN,\n    TIME_UNIT_CONNECTOR_PATTERN\n);\nexport const TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:about|around)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_NO_ABBR_PATTERN,\n    TIME_UNIT_CONNECTOR_PATTERN\n);\n\nexport function parseDuration(timeunitText): null | Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    if (Object.keys(fragments).length == 0) {\n        return null;\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    if (match[0].match(/^[a-zA-Z]+$/)) {\n        return;\n    }\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Component } from \"../../types\";\n\n/**\n * A parser that checks for word boundary and applying the inner pattern and extraction.\n */\nexport abstract class AbstractParserWithWordBoundaryChecking implements Parser {\n    abstract innerPattern(context: ParsingContext): RegExp;\n    abstract innerExtract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n\n    // Overrides this method if there is more efficient way to check for inner pattern change.\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return this.innerPattern(context) !== currentInnerPattern;\n    }\n\n    patternLeftBoundary(): string {\n        return `(\\\\W|^)`;\n    }\n\n    private cachedInnerPattern?: RegExp = null;\n    private cachedPattern?: RegExp = null;\n\n    pattern(context: ParsingContext): RegExp {\n        if (this.cachedInnerPattern) {\n            if (!this.innerPatternHasChange(context, this.cachedInnerPattern)) {\n                return this.cachedPattern;\n            }\n        }\n        this.cachedInnerPattern = this.innerPattern(context);\n        this.cachedPattern = new RegExp(\n            `${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`,\n            this.cachedInnerPattern.flags\n        );\n        return this.cachedPattern;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const header = match[1] ?? \"\";\n        match.index = match.index + header.length;\n        match[0] = match[0].substring(header.length);\n        for (let i = 2; i < match.length; i++) {\n            match[i - 1] = match[i];\n        }\n\n        return this.innerExtract(context, match);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN_WITH_OPTIONAL_PREFIX = new RegExp(\n    `(?:(?:within|in|for)\\\\s*)?` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITH_PREFIX = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITH_PREFIX_STRICT = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:about|around|roughly|approximately|just)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        if (this.strictMode) {\n            return PATTERN_WITH_PREFIX_STRICT;\n        }\n        return context.option.forwardDate ? PATTERN_WITH_OPTIONAL_PREFIX : PATTERN_WITH_PREFIX;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // Exclude \"for the unit\" phases, e.g. \"for the year\"\n        if (match[0].match(/^for\\s*the\\s*\\w+/)) {\n            return null;\n        }\n        const timeUnits = parseDuration(match[1]);\n        if (!timeUnits) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(?:on\\\\s{0,3})?` +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:` +\n            `\\\\s{0,3}(?:to|\\\\-|\\\\–|until|through|till)?\\\\s{0,3}` +\n            `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        `(?:-|/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:\" +\n            `(?:-|/|,?\\\\s{0,3})` +\n            `(${YEAR_PATTERN}(?!\\\\w))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ENMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` +\n        \"(?:\" +\n            \"(?:to|\\\\-)\\\\s*\" +\n            `(${ORDINAL_NUMBER_PATTERN})\\\\s*` +\n        \")?\" +\n        \"(?:\" +\n            `(?:-|/|\\\\s*,\\\\s*|\\\\s+)` +\n            `(${YEAR_PATTERN})` +\n        \")?\" +\n        \"(?=\\\\W|$)(?!\\\\:\\\\d)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing US's date format that begin with month's name.\n *  - January 13\n *  - January 13, 2012\n *  - January 13 - 15, 2012\n * Note: Watch out for:\n *  - January 12:00\n *  - January 12.44\n *  - January 1222344\n *  - January 21 (when shouldSkipYearLikeDate=true)\n */\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    shouldSkipYearLikeDate: boolean;\n\n    constructor(shouldSkipYearLikeDate: boolean) {\n        super();\n        this.shouldSkipYearLikeDate = shouldSkipYearLikeDate;\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            return null;\n        }\n\n        // Skip the case where the day looks like a year (ex: January 21)\n        if (this.shouldSkipYearLikeDate) {\n            if (!match[DATE_TO_GROUP] && !match[YEAR_GROUP] && match[DATE_GROUP].match(/^2[0-5]$/)) {\n                return null;\n            }\n        }\n        const components = context\n            .createParsingComponents({\n                day: day,\n                month: month,\n            })\n            .addTag(\"parser/ENMonthNameMiddleEndianParser\");\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `((?:in)\\\\s*)?` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `(?:,|-|of)?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - January, 2012\n * - January 2012\n * - January\n * (in) Jan\n */\nexport default class ENMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"jan\", \"mar\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(\n            match.index + (match[PREFIX_GROUP] || \"\").length,\n            match.index + match[0].length\n        );\n        result.start.imply(\"day\", 1);\n        result.start.addTag(\"parser/ENMonthNameParser\");\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[-\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[-\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class ENYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMonthDateOrder: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        let day = parseInt(match[DATE_NUMBER_GROUP]);\n        let month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            if (this.strictMonthDateOrder) {\n                return null;\n            }\n            if (day >= 1 && day <= 12) {\n                [month, day] = [day, month];\n            }\n        }\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\"([0-9]|0[1-9]|1[012])/([0-9]{4})\" + \"\", \"i\");\n\nconst MONTH_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * Month/Year date format with slash \"/\" (also \"-\" and \".\") between numbers\n * - 11/05\n * - 06/2005\n */\nexport default class ENSlashMonthFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const year = parseInt(match[YEAR_GROUP]);\n        const month = parseInt(match[MONTH_GROUP]);\n\n        return context.createParsingComponents().imply(\"day\", 1).assign(\"month\", month).assign(\"year\", year);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../results\";\nimport { Meridiem } from \"../../types\";\n\n// prettier-ignore\nfunction primaryTimePattern(leftBoundary: string, primaryPrefix: string, primarySuffix: string, flags: string) {\n    return new RegExp(\n            `${leftBoundary}` +\n            `${primaryPrefix}` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|:|：)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?::|：)` +\n                    `(\\\\d{2})` +\n                    `(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${primarySuffix}`,\n        flags\n    );\n}\n\n// prettier-ignore\nfunction followingTimePatten(followingPhase: string, followingSuffix: string) {\n    return new RegExp(\n        `^(${followingPhase})` +\n            `(\\\\d{1,4})` +\n            `(?:` +\n                `(?:\\\\.|\\\\:|\\\\：)` +\n                `(\\\\d{1,2})` +\n                `(?:` +\n                    `(?:\\\\.|\\\\:|\\\\：)` +\n                    `(\\\\d{1,2})(?:\\\\.(\\\\d{1,6}))?` +\n                `)?` +\n            `)?` +\n            `(?:\\\\s*(a\\\\.m\\\\.|p\\\\.m\\\\.|am?|pm?))?` +\n            `${followingSuffix}`,\n        \"i\"\n    );\n}\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst MILLI_SECOND_GROUP = 5;\nconst AM_PM_HOUR_GROUP = 6;\n\nexport abstract class AbstractTimeExpressionParser implements Parser {\n    abstract primaryPrefix(): string;\n    abstract followingPhase(): string;\n    strictMode: boolean;\n\n    constructor(strictMode = false) {\n        this.strictMode = strictMode;\n    }\n\n    patternFlags(): string {\n        return \"i\";\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|\\\\b)`;\n    }\n\n    primarySuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    followingSuffix(): string {\n        return `(?!/)(?=\\\\W|$)`;\n    }\n\n    pattern(context: ParsingContext): RegExp {\n        return this.getPrimaryTimePatternThroughCache();\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const startComponents = this.extractPrimaryTimeComponents(context, match);\n        if (!startComponents) {\n            // If the match seem like a year e.g. \"2013.12:...\",\n            // then skips the year part and try matching again.\n            if (match[0].match(/^\\d{4}/)) {\n                match.index += 4; // Skip over potential overlapping pattern\n                return null;\n            }\n\n            match.index += match[0].length; // Skip over potential overlapping pattern\n            return null;\n        }\n\n        const index = match.index + match[1].length;\n        const text = match[0].substring(match[1].length);\n        const result = context.createParsingResult(index, text, startComponents);\n        match.index += match[0].length; // Skip over potential overlapping pattern\n\n        const remainingText = context.text.substring(match.index);\n        const followingPattern = this.getFollowingTimePatternThroughCache();\n        const followingMatch = followingPattern.exec(remainingText);\n\n        // Pattern \"456-12\", \"2022-12\" should not be time without proper context\n        if (text.match(/^\\d{3,4}/) && followingMatch) {\n            // e.g. \"2022-12\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2,4}$/)) {\n                return null;\n            }\n            // e.g. \"2022-12:01...\"\n            if (followingMatch[0].match(/^\\s*([+-])\\s*\\d{2}\\W\\d{2}/)) {\n                return null;\n            }\n        }\n\n        if (\n            !followingMatch ||\n            // Pattern \"YY.YY -XXXX\" is more like timezone offset\n            followingMatch[0].match(/^\\s*([+-])\\s*\\d{3,4}$/)\n        ) {\n            return this.checkAndReturnWithoutFollowingPattern(result);\n        }\n\n        result.end = this.extractFollowingTimeComponents(context, followingMatch, result);\n        if (result.end) {\n            result.text += followingMatch[0];\n        }\n\n        return this.checkAndReturnWithFollowingPattern(result);\n    }\n\n    extractPrimaryTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        strict = false\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        let hour = parseInt(match[HOUR_GROUP]);\n        if (hour > 100) {\n            // When time is like '2019', it is more likely a year.\n            // Especially if there is no minute part and no am/pm.\n            if (match[HOUR_GROUP].length == 4 && match[MINUTE_GROUP] == null && !match[AM_PM_HOUR_GROUP]) {\n                return null;\n            }\n\n            if (this.strictMode || match[MINUTE_GROUP] != null) {\n                return null;\n            }\n\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            if (match[MINUTE_GROUP].length == 1 && !match[AM_PM_HOUR_GROUP]) {\n                // Skip single digit minute e.g. \"at 1.1 xx\"\n                return null;\n            }\n\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem !== null) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                components.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        return components;\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): null | ParsingComponents {\n        const components = context.createParsingComponents();\n\n        // ----- Millisecond\n        if (match[MILLI_SECOND_GROUP] != null) {\n            const millisecond = parseInt(match[MILLI_SECOND_GROUP].substring(0, 3));\n            if (millisecond >= 1000) return null;\n\n            components.assign(\"millisecond\", millisecond);\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            components.assign(\"second\", second);\n        }\n\n        let hour = parseInt(match[HOUR_GROUP]);\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Minute\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) {\n                return null;\n            }\n\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                    if (!components.isCertain(\"day\")) {\n                        components.imply(\"day\", components.get(\"day\") + 1);\n                    }\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == Meridiem.AM) {\n                    result.start.imply(\"meridiem\", Meridiem.AM);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", Meridiem.PM);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        }\n\n        components.assign(\"hour\", hour);\n        components.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            components.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"hour\") > 12;\n            if (startAtPM) {\n                if (result.start.get(\"hour\") - 12 > hour) {\n                    // 10pm - 1 (am)\n                    components.imply(\"meridiem\", Meridiem.AM);\n                } else if (hour <= 12) {\n                    components.assign(\"hour\", hour + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                }\n            } else if (hour > 12) {\n                components.imply(\"meridiem\", Meridiem.PM);\n            } else if (hour <= 12) {\n                components.imply(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (components.date().getTime() < result.start.date().getTime()) {\n            components.imply(\"day\", components.get(\"day\") + 1);\n        }\n\n        return components;\n    }\n\n    private checkAndReturnWithoutFollowingPattern(result) {\n        // Single digit (e.g \"1\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d$/)) {\n            return null;\n        }\n\n        // Three or more digit (e.g. \"203\", \"2014\") should not be counted as time expression (without proper context)\n        if (result.text.match(/^\\d\\d\\d+$/)) {\n            return null;\n        }\n\n        // Instead of \"am/pm\", it ends with \"a\" or \"p\" (e.g \"1a\", \"123p\"), this seems unlikely\n        if (result.text.match(/\\d[apAP]$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            const endingNumbers: string = endingWithNumbers[1];\n\n            // In strict mode (e.g. \"at 1\" or \"at 1.2\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            if (endingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private checkAndReturnWithFollowingPattern(result) {\n        if (result.text.match(/^\\d+-\\d+$/)) {\n            return null;\n        }\n\n        // If it ends only with numbers or dots\n        const endingWithNumbers = result.text.match(/[^\\d:.](\\d[\\d.]+)\\s*-\\s*(\\d[\\d.]+)$/);\n        if (endingWithNumbers) {\n            // In strict mode (e.g. \"at 1-3\" or \"at 1.2 - 2.3\"), this should not be accepted\n            if (this.strictMode) {\n                return null;\n            }\n\n            const startingNumbers: string = endingWithNumbers[1];\n            const endingNumbers: string = endingWithNumbers[2];\n            // If it ends only with dot single digit, e.g. \"at 1.2\"\n            if (endingNumbers.includes(\".\") && !endingNumbers.match(/\\d(\\.\\d{2})+$/)) {\n                return null;\n            }\n\n            // If it ends only with numbers above 24, e.g. \"at 25\"\n            const endingNumberVal = parseInt(endingNumbers);\n            const startingNumberVal = parseInt(startingNumbers);\n            if (endingNumberVal > 24 || startingNumberVal > 24) {\n                return null;\n            }\n        }\n\n        return result;\n    }\n\n    private cachedPrimaryPrefix = null;\n    private cachedPrimarySuffix = null;\n    private cachedPrimaryTimePattern = null;\n\n    getPrimaryTimePatternThroughCache() {\n        const primaryPrefix = this.primaryPrefix();\n        const primarySuffix = this.primarySuffix();\n\n        if (this.cachedPrimaryPrefix === primaryPrefix && this.cachedPrimarySuffix === primarySuffix) {\n            return this.cachedPrimaryTimePattern;\n        }\n\n        this.cachedPrimaryTimePattern = primaryTimePattern(\n            this.primaryPatternLeftBoundary(),\n            primaryPrefix,\n            primarySuffix,\n            this.patternFlags()\n        );\n        this.cachedPrimaryPrefix = primaryPrefix;\n        this.cachedPrimarySuffix = primarySuffix;\n        return this.cachedPrimaryTimePattern;\n    }\n\n    private cachedFollowingPhase = null;\n    private cachedFollowingSuffix = null;\n    private cachedFollowingTimePatten = null;\n\n    getFollowingTimePatternThroughCache() {\n        const followingPhase = this.followingPhase();\n        const followingSuffix = this.followingSuffix();\n\n        if (this.cachedFollowingPhase === followingPhase && this.cachedFollowingSuffix === followingSuffix) {\n            return this.cachedFollowingTimePatten;\n        }\n\n        this.cachedFollowingTimePatten = followingTimePatten(followingPhase, followingSuffix);\n        this.cachedFollowingPhase = followingPhase;\n        this.cachedFollowingSuffix = followingSuffix;\n        return this.cachedFollowingTimePatten;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class ENTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|to|until|through|till|\\\\?)\\\\s*\";\n    }\n\n    primaryPrefix(): string {\n        return \"(?:(?:at|from)\\\\s*)??\";\n    }\n\n    primarySuffix(): string {\n        return \"(?:\\\\s*(?:o\\\\W*clock|at\\\\s*night|in\\\\s*the\\\\s*(?:morning|afternoon)))?(?!/)(?=\\\\W|$)\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (!components) {\n            return components;\n        }\n\n        if (match[0].endsWith(\"night\")) {\n            const hour = components.get(\"hour\");\n            if (hour >= 6 && hour < 12) {\n                components.assign(\"hour\", components.get(\"hour\") + 12);\n                components.assign(\"meridiem\", Meridiem.PM);\n            } else if (hour < 6) {\n                components.assign(\"meridiem\", Meridiem.AM);\n            }\n        }\n\n        if (match[0].endsWith(\"afternoon\")) {\n            components.assign(\"meridiem\", Meridiem.PM);\n            const hour = components.get(\"hour\");\n            if (hour >= 0 && hour <= 6) {\n                components.assign(\"hour\", components.get(\"hour\") + 12);\n            }\n        }\n\n        if (match[0].endsWith(\"morning\")) {\n            components.assign(\"meridiem\", Meridiem.AM);\n            const hour = components.get(\"hour\");\n            if (hour < 12) {\n                components.assign(\"hour\", components.get(\"hour\"));\n            }\n        }\n\n        return components.addTag(\"parser/ENTimeExpressionParser\");\n    }\n\n    extractFollowingTimeComponents(\n        context: ParsingContext,\n        match: RegExpMatchArray,\n        result: ParsingResult\n    ): ParsingComponents | null {\n        const followingComponents = super.extractFollowingTimeComponents(context, match, result);\n        if (followingComponents) {\n            followingComponents.addTag(\"parser/ENTimeExpressionParser\");\n        }\n        return followingComponents;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_NO_ABBR_PATTERN, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(`(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:ago|before|earlier)(?=\\\\W|$)`, \"i\");\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\\\s{0,5}(?:ago|before|earlier)(?=\\\\W|$)`, \"i\");\n\nexport default class ENTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const duration = parseDuration(match[1]);\n        if (!duration) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, reverseDuration(duration));\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_NO_ABBR_PATTERN, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:later|after|from now|henceforth|forward|out)` + \"(?=(?:\\\\W|$))\",\n    \"i\"\n);\n\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_NO_ABBR_PATTERN})\\\\s{0,5}(later|after|from now)(?=\\\\W|$)`, \"i\");\nconst GROUP_NUM_TIMEUNITS = 1;\n\nexport default class ENTimeUnitLaterFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseDuration(match[GROUP_NUM_TIMEUNITS]);\n        if (!timeUnits) {\n            return null;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext, Refiner } from \"../chrono\";\nimport { ParsingResult } from \"../results\";\n\n/**\n * A special type of {@link Refiner} to filter the results\n */\nexport abstract class Filter implements Refiner {\n    abstract isValid(context: ParsingContext, result: ParsingResult): boolean;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        return results.filter((r) => this.isValid(context, r));\n    }\n}\n\n/**\n * A special type of {@link Refiner} to merge consecutive results\n */\nexport abstract class MergingRefiner implements Refiner {\n    abstract shouldMergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): boolean;\n\n    abstract mergeResults(\n        textBetween: string,\n        currentResult: ParsingResult,\n        nextResult: ParsingResult,\n        context: ParsingContext\n    ): ParsingResult;\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const mergedResults: ParsingResult[] = [];\n        let curResult = results[0];\n        let nextResult = null;\n\n        for (let i = 1; i < results.length; i++) {\n            nextResult = results[i];\n\n            const textBetween = context.text.substring(curResult.index + curResult.text.length, nextResult.index);\n            if (!this.shouldMergeResults(textBetween, curResult, nextResult, context)) {\n                mergedResults.push(curResult);\n                curResult = nextResult;\n            } else {\n                const left = curResult;\n                const right = nextResult;\n                const mergedResult = this.mergeResults(textBetween, left, right, context);\n                context.debug(() => {\n                    console.log(`${this.constructor.name} merged ${left} and ${right} into ${mergedResult}`);\n                });\n\n                curResult = mergedResult;\n            }\n        }\n\n        if (curResult != null) {\n            mergedResults.push(curResult);\n        }\n\n        return mergedResults;\n    }\n}\n", "/*\n  \n*/\n\nimport { ParsingResult } from \"../../results\";\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { addDuration } from \"../../calculation/duration\";\n\nexport default abstract class AbstractMergeDateRangeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween, currentResult, nextResult): boolean {\n        return !currentResult.end && !nextResult.end && textBetween.match(this.patternBetween()) != null;\n    }\n\n    mergeResults(textBetween, fromResult, toResult): ParsingResult {\n        if (!fromResult.start.isOnlyWeekdayComponent() && !toResult.start.isOnlyWeekdayComponent()) {\n            toResult.start.getCertainComponents().forEach((key) => {\n                if (!fromResult.start.isCertain(key)) {\n                    fromResult.start.imply(key, toResult.start.get(key));\n                }\n            });\n\n            fromResult.start.getCertainComponents().forEach((key) => {\n                if (!toResult.start.isCertain(key)) {\n                    toResult.start.imply(key, fromResult.start.get(key));\n                }\n            });\n        }\n        if (fromResult.start.date() > toResult.start.date()) {\n            let fromDate = fromResult.start.date();\n            let toDate = toResult.start.date();\n\n            if (toResult.start.isOnlyWeekdayComponent() && addDuration(toDate, { day: 7 }) > fromDate) {\n                toDate = addDuration(toDate, { day: 7 });\n                toResult.start.imply(\"day\", toDate.getDate());\n                toResult.start.imply(\"month\", toDate.getMonth() + 1);\n                toResult.start.imply(\"year\", toDate.getFullYear());\n            } else if (fromResult.start.isOnlyWeekdayComponent() && addDuration(fromDate, { day: -7 }) < toDate) {\n                fromDate = addDuration(fromDate, { day: -7 });\n                fromResult.start.imply(\"day\", fromDate.getDate());\n                fromResult.start.imply(\"month\", fromDate.getMonth() + 1);\n                fromResult.start.imply(\"year\", fromDate.getFullYear());\n            } else if (toResult.start.isDateWithUnknownYear() && addDuration(toDate, { year: 1 }) > fromDate) {\n                toDate = addDuration(toDate, { year: 1 });\n                toResult.start.imply(\"year\", toDate.getFullYear());\n            } else if (fromResult.start.isDateWithUnknownYear() && addDuration(fromDate, { year: -1 }) < toDate) {\n                fromDate = addDuration(fromDate, { year: -1 });\n                fromResult.start.imply(\"year\", fromDate.getFullYear());\n            } else {\n                [toResult, fromResult] = [fromResult, toResult];\n            }\n        }\n        const result = fromResult.clone();\n        result.start = fromResult.start;\n        result.end = toResult.start;\n        result.index = Math.min(fromResult.index, toResult.index);\n        if (fromResult.index < toResult.index) {\n            result.text = fromResult.text + textBetween + toResult.text;\n        } else {\n            result.text = toResult.text + textBetween + fromResult.text;\n        }\n        return result;\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide English connecting phases\n * - 2020-02-13 [to] 2020-02-13\n * - Wednesday [-] Friday\n */\nexport default class ENMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(to|-|–|until|through|till)\\s*$/i;\n    }\n}\n", "import { ParsingComponents, ParsingResult } from \"../results\";\nimport { Meridiem } from \"../types\";\nimport { assignSimilarDate, implySimilarDate } from \"../utils/dates\";\n\nexport function mergeDateTimeResult(dateResult: ParsingResult, timeResult: ParsingResult): ParsingResult {\n    const result = dateResult.clone();\n    const beginDate = dateResult.start;\n    const beginTime = timeResult.start;\n\n    result.start = mergeDateTimeComponent(beginDate, beginTime);\n    if (dateResult.end != null || timeResult.end != null) {\n        const endDate = dateResult.end == null ? dateResult.start : dateResult.end;\n        const endTime = timeResult.end == null ? timeResult.start : timeResult.end;\n        const endDateTime = mergeDateTimeComponent(endDate, endTime);\n\n        if (dateResult.end == null && endDateTime.date().getTime() < result.start.date().getTime()) {\n            // For example,  \"Tuesday 9pm - 1am\" the ending should actually be 1am on the next day.\n            // We need to add to ending by another day.\n            const nextDay = new Date(endDateTime.date().getTime());\n            nextDay.setDate(nextDay.getDate() + 1);\n            if (endDateTime.isCertain(\"day\")) {\n                assignSimilarDate(endDateTime, nextDay);\n            } else {\n                implySimilarDate(endDateTime, nextDay);\n            }\n        }\n\n        result.end = endDateTime;\n    }\n\n    return result;\n}\n\nexport function mergeDateTimeComponent(\n    dateComponent: ParsingComponents,\n    timeComponent: ParsingComponents\n): ParsingComponents {\n    const dateTimeComponent = dateComponent.clone();\n\n    if (timeComponent.isCertain(\"hour\")) {\n        dateTimeComponent.assign(\"hour\", timeComponent.get(\"hour\"));\n        dateTimeComponent.assign(\"minute\", timeComponent.get(\"minute\"));\n\n        if (timeComponent.isCertain(\"second\")) {\n            dateTimeComponent.assign(\"second\", timeComponent.get(\"second\"));\n\n            if (timeComponent.isCertain(\"millisecond\")) {\n                dateTimeComponent.assign(\"millisecond\", timeComponent.get(\"millisecond\"));\n            } else {\n                dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n            }\n        } else {\n            dateTimeComponent.imply(\"second\", timeComponent.get(\"second\"));\n            dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n        }\n    } else {\n        dateTimeComponent.imply(\"hour\", timeComponent.get(\"hour\"));\n        dateTimeComponent.imply(\"minute\", timeComponent.get(\"minute\"));\n        dateTimeComponent.imply(\"second\", timeComponent.get(\"second\"));\n        dateTimeComponent.imply(\"millisecond\", timeComponent.get(\"millisecond\"));\n    }\n\n    if (timeComponent.isCertain(\"timezoneOffset\")) {\n        dateTimeComponent.assign(\"timezoneOffset\", timeComponent.get(\"timezoneOffset\"));\n    }\n\n    if (timeComponent.isCertain(\"meridiem\")) {\n        dateTimeComponent.assign(\"meridiem\", timeComponent.get(\"meridiem\"));\n    } else if (timeComponent.get(\"meridiem\") != null && dateTimeComponent.get(\"meridiem\") == null) {\n        dateTimeComponent.imply(\"meridiem\", timeComponent.get(\"meridiem\"));\n    }\n\n    if (dateTimeComponent.get(\"meridiem\") == Meridiem.PM && dateTimeComponent.get(\"hour\") < 12) {\n        if (timeComponent.isCertain(\"hour\")) {\n            dateTimeComponent.assign(\"hour\", dateTimeComponent.get(\"hour\") + 12);\n        } else {\n            dateTimeComponent.imply(\"hour\", dateTimeComponent.get(\"hour\") + 12);\n        }\n    }\n\n    dateTimeComponent.addTags(dateComponent.tags());\n    dateTimeComponent.addTags(timeComponent.tags());\n    return dateTimeComponent;\n}\n", "/*\n\n*/\n\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\nimport { mergeDateTimeResult } from \"../../calculation/mergingCalculation\";\n\nexport default abstract class AbstractMergeDateTimeRefiner extends MergingRefiner {\n    abstract patternBetween(): RegExp;\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        return (\n            ((currentResult.start.isOnlyDate() && nextResult.start.isOnlyTime()) ||\n                (nextResult.start.isOnlyDate() && currentResult.start.isOnlyTime())) &&\n            textBetween.match(this.patternBetween()) != null\n        );\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const result = currentResult.start.isOnlyDate()\n            ? mergeDateTimeResult(currentResult, nextResult)\n            : mergeDateTimeResult(nextResult, currentResult);\n\n        result.index = currentResult.index;\n        result.text = currentResult.text + textBetween + nextResult.text;\n        return result;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide English connecting phases\n * - 2020-02-13 [at] 6pm\n * - Tomorrow [after] 7am\n */\nexport default class ENMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|at|after|before|on|of|,|-|\\\\.|∙|:)?\\\\s*$\");\n    }\n}\n", "// Map ABBR -> Offset in minute\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { TimezoneAbbrMap } from \"../../types\";\nimport { ParsingResult } from \"../../results\";\nimport { toTimezoneOffset } from \"../../timezone\";\n\nconst TIMEZONE_NAME_PATTERN = new RegExp(\"^\\\\s*,?\\\\s*\\\\(?([A-Z]{2,4})\\\\)?(?=\\\\W|$)\", \"i\");\n\nexport default class ExtractTimezoneAbbrRefiner implements Refiner {\n    constructor(private readonly timezoneOverrides?: TimezoneAbbrMap) {}\n\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        const timezoneOverrides = context.option.timezones ?? {};\n\n        results.forEach((result) => {\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_NAME_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            const timezoneAbbr = match[1].toUpperCase();\n            const refDate = result.start.date() ?? result.refDate ?? new Date();\n            const tzOverrides = { ...this.timezoneOverrides, ...timezoneOverrides };\n            const extractedTimezoneOffset = toTimezoneOffset(timezoneAbbr, refDate, tzOverrides);\n            if (extractedTimezoneOffset == null) {\n                return;\n            }\n            context.debug(() => {\n                console.log(\n                    `Extracting timezone: '${timezoneAbbr}' into: ${extractedTimezoneOffset} for: ${result.start}`\n                );\n            });\n\n            const currentTimezoneOffset = result.start.get(\"timezoneOffset\");\n            if (currentTimezoneOffset !== null && extractedTimezoneOffset != currentTimezoneOffset) {\n                // We may already have extracted the timezone offset e.g. \"11 am GMT+0900 (JST)\"\n                // - if they are equal, we also want to take the abbreviation text into result\n                // - if they are not equal, we trust the offset more\n                if (result.start.isCertain(\"timezoneOffset\")) {\n                    return;\n                }\n\n                // This is often because it's relative time with inferred timezone (e.g. in 1 hour, tomorrow)\n                // Then, we want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            if (result.start.isOnlyDate()) {\n                // If the time is not explicitly mentioned,\n                // Then, we also want to double-check the abbr case (e.g. \"GET\" not \"get\")\n                if (timezoneAbbr != match[1]) {\n                    return;\n                }\n            }\n\n            result.text += match[0];\n\n            if (!result.start.isCertain(\"timezoneOffset\")) {\n                result.start.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n\n            if (result.end != null && !result.end.isCertain(\"timezoneOffset\")) {\n                result.end.assign(\"timezoneOffset\", extractedTimezoneOffset);\n            }\n        });\n\n        return results;\n    }\n}\n", "import { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\n\nconst TIMEZONE_OFFSET_PATTERN = new RegExp(\"^\\\\s*(?:\\\\(?(?:GMT|UTC)\\\\s?)?([+-])(\\\\d{1,2})(?::?(\\\\d{2}))?\\\\)?\", \"i\");\nconst TIMEZONE_OFFSET_SIGN_GROUP = 1;\nconst TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 2;\nconst TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 3;\n\nexport default class ExtractTimezoneOffsetRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (result.start.isCertain(\"timezoneOffset\")) {\n                return;\n            }\n\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = TIMEZONE_OFFSET_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n\n            context.debug(() => {\n                console.log(`Extracting timezone: '${match[0]}' into : ${result}`);\n            });\n\n            const hourOffset = parseInt(match[TIMEZONE_OFFSET_HOUR_OFFSET_GROUP]);\n            const minuteOffset = parseInt(match[TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP] || \"0\");\n            let timezoneOffset = hourOffset * 60 + minuteOffset;\n            // No timezones have offsets greater than 14 hours, so disregard this match\n            if (timezoneOffset > 14 * 60) {\n                return;\n            }\n            if (match[TIMEZONE_OFFSET_SIGN_GROUP] === \"-\") {\n                timezoneOffset = -timezoneOffset;\n            }\n\n            if (result.end != null) {\n                result.end.assign(\"timezoneOffset\", timezoneOffset);\n            }\n\n            result.start.assign(\"timezoneOffset\", timezoneOffset);\n            result.text += match[0];\n        });\n\n        return results;\n    }\n}\n", "/*\n  \n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\n\nexport default class OverlapRemovalRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (results.length < 2) {\n            return results;\n        }\n\n        const filteredResults = [];\n        let prevResult = results[0];\n        for (let i = 1; i < results.length; i++) {\n            const result = results[i];\n            if (result.index >= prevResult.index + prevResult.text.length) {\n                filteredResults.push(prevResult);\n                prevResult = result;\n                continue;\n            }\n\n            // If overlap, compare the length and discard the shorter one\n            let kept = null;\n            let removed = null;\n            if (result.text.length > prevResult.text.length) {\n                kept = result;\n                removed = prevResult;\n            } else {\n                kept = prevResult;\n                removed = result;\n            }\n            context.debug(() => {\n                console.log(`${this.constructor.name} remove ${removed} by ${kept}`);\n            });\n            prevResult = kept;\n        }\n\n        // The last one\n        if (prevResult != null) {\n            filteredResults.push(prevResult);\n        }\n\n        return filteredResults;\n    }\n}\n", "/*\n    Enforce 'forwardDate' option to on the results. When there are missing component,\n    e.g. \"March 12-13 (without year)\" or \"Thursday\", the refiner will try to adjust the result\n    into the future instead of the past.\n*/\n\nimport { ParsingContext, Refiner } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport * as dates from \"../../utils/dates\";\nimport { implySimilarDate } from \"../../utils/dates\";\nimport { addDuration } from \"../../calculation/duration\";\n\nexport default class ForwardDateRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        if (!context.option.forwardDate) {\n            return results;\n        }\n\n        results.forEach((result) => {\n            let refDate = context.reference.getDateWithAdjustedTimezone();\n\n            if (result.start.isOnlyTime() && context.reference.instant > result.start.date()) {\n                const refDate = context.reference.getDateWithAdjustedTimezone();\n                const refFollowingDay = new Date(refDate);\n                refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n\n                dates.implySimilarDate(result.start, refFollowingDay);\n                context.debug(() => {\n                    console.log(\n                        `${this.constructor.name} adjusted ${result} time from the ref date (${refDate}) to the following day (${refFollowingDay})`\n                    );\n                });\n                if (result.end && result.end.isOnlyTime()) {\n                    dates.implySimilarDate(result.end, refFollowingDay);\n                    if (result.start.date() > result.end.date()) {\n                        refFollowingDay.setDate(refFollowingDay.getDate() + 1);\n                        dates.implySimilarDate(result.end, refFollowingDay);\n                    }\n                }\n            }\n\n            if (result.start.isOnlyWeekdayComponent() && refDate > result.start.date()) {\n                let daysToAdd = result.start.get(\"weekday\") - refDate.getDay();\n                if (daysToAdd <= 0) {\n                    daysToAdd += 7;\n                }\n                refDate = addDuration(refDate, { day: daysToAdd });\n                implySimilarDate(result.start, refDate);\n                context.debug(() => {\n                    console.log(`${this.constructor.name} adjusted ${result} weekday (${result.start})`);\n                });\n\n                if (result.end && result.end.isOnlyWeekdayComponent()) {\n                    // Adjust date to the coming week\n                    let daysToAdd = result.end.get(\"weekday\") - refDate.getDay();\n                    if (daysToAdd <= 0) {\n                        daysToAdd += 7;\n                    }\n                    refDate = addDuration(refDate, { day: daysToAdd });\n                    implySimilarDate(result.end, refDate);\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} weekday (${result.end})`);\n                    });\n                }\n            }\n\n            // In case where we know the month, but not which year (e.g. \"in December\", \"25th December\"),\n            // try move to another year (up-to 3 times)\n            if (result.start.isDateWithUnknownYear() && refDate > result.start.date()) {\n                for (let i = 0; i < 3 && refDate > result.start.date(); i++) {\n                    result.start.imply(\"year\", result.start.get(\"year\") + 1);\n                    context.debug(() => {\n                        console.log(`${this.constructor.name} adjusted ${result} year (${result.start})`);\n                    });\n\n                    if (result.end && !result.end.isCertain(\"year\")) {\n                        result.end.imply(\"year\", result.end.get(\"year\") + 1);\n                        context.debug(() => {\n                            console.log(`${this.constructor.name} adjusted ${result} month (${result.start})`);\n                        });\n                    }\n                }\n            }\n        });\n\n        return results;\n    }\n}\n", "import { Filter } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\n\nexport default class UnlikelyFormatFilter extends Filter {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    isValid(context, result: ParsingResult): boolean {\n        if (result.text.replace(\" \", \"\").match(/^\\d*(\\.\\d*)?$/)) {\n            context.debug(() => {\n                console.log(`Removing unlikely result '${result.text}'`);\n            });\n\n            return false;\n        }\n\n        if (!result.start.isValidDate()) {\n            context.debug(() => {\n                console.log(`Removing invalid result: ${result} (${result.start})`);\n            });\n\n            return false;\n        }\n\n        if (result.end && !result.end.isValidDate()) {\n            context.debug(() => {\n                console.log(`Removing invalid result: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        if (this.strictMode) {\n            return this.isStrictModeValid(context, result);\n        }\n\n        return true;\n    }\n\n    private isStrictModeValid(context, result: ParsingResult) {\n        if (result.start.isOnlyWeekdayComponent()) {\n            context.debug(() => {\n                console.log(`(Strict) Removing weekday only component: ${result} (${result.end})`);\n            });\n\n            return false;\n        }\n\n        return true;\n    }\n}\n", "import { ParsingContext } from \"../../chrono\";\nimport { Component } from \"../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"./AbstractParserWithWordBoundary\";\n\n// ISO 8601\n// http://www.w3.org/TR/NOTE-datetime\n// - YYYY-MM-DD\n// - YYYY-MM-DDThh:mmTZD\n// - YYYY-MM-DDThh:mm:ssTZD\n// - YYYY-MM-DDThh:mm:ss.sTZD\n// - TZD = (Z or +hh:mm or -hh:mm)\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    \"([0-9]{4})\\\\-([0-9]{1,2})\\\\-([0-9]{1,2})\" +\n    \"(?:T\" + //..\n        \"([0-9]{1,2}):([0-9]{1,2})\" + // hh:mm\n        \"(?:\" +\n            \":([0-9]{1,2})(?:\\\\.(\\\\d{1,4}))?\" +\n        \")?\" + // :ss.s\n        \"(\" +\n            \"Z|([+-]\\\\d{2}):?(\\\\d{2})?\" +\n        \")?\" + // TZD (Z or ±hh:mm or ±hhmm or ±hh)\n    \")?\" +\n    \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NUMBER_GROUP = 2;\nconst DATE_NUMBER_GROUP = 3;\nconst HOUR_NUMBER_GROUP = 4;\nconst MINUTE_NUMBER_GROUP = 5;\nconst SECOND_NUMBER_GROUP = 6;\nconst MILLISECOND_NUMBER_GROUP = 7;\nconst TZD_GROUP = 8;\nconst TZD_HOUR_OFFSET_GROUP = 9;\nconst TZD_MINUTE_OFFSET_GROUP = 10;\n\nexport default class ISOFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const components = context.createParsingComponents({\n            \"year\": parseInt(match[YEAR_NUMBER_GROUP]),\n            \"month\": parseInt(match[MONTH_NUMBER_GROUP]),\n            \"day\": parseInt(match[DATE_NUMBER_GROUP]),\n        });\n        if (match[HOUR_NUMBER_GROUP] != null) {\n            components.assign(\"hour\", parseInt(match[HOUR_NUMBER_GROUP]));\n            components.assign(\"minute\", parseInt(match[MINUTE_NUMBER_GROUP]));\n\n            if (match[SECOND_NUMBER_GROUP] != null) {\n                components.assign(\"second\", parseInt(match[SECOND_NUMBER_GROUP]));\n            }\n\n            if (match[MILLISECOND_NUMBER_GROUP] != null) {\n                components.assign(\"millisecond\", parseInt(match[MILLISECOND_NUMBER_GROUP]));\n            }\n            if (match[TZD_GROUP] != null) {\n                // The Zulu time zone (Z) is equivalent to UTC\n                let offset = 0;\n                if (match[TZD_HOUR_OFFSET_GROUP]) {\n                    const hourOffset = parseInt(match[TZD_HOUR_OFFSET_GROUP]);\n                    let minuteOffset = 0;\n                    if (match[TZD_MINUTE_OFFSET_GROUP] != null) {\n                        minuteOffset = parseInt(match[TZD_MINUTE_OFFSET_GROUP]);\n                    }\n                    offset = hourOffset * 60;\n                    if (offset < 0) {\n                        offset -= minuteOffset;\n                    } else {\n                        offset += minuteOffset;\n                    }\n                }\n                components.assign(\"timezoneOffset\", offset);\n            }\n        }\n        return components.addTag(\"parser/ISOFormatParser\");\n    }\n}\n", "/*\n  \n*/\n\nimport { MergingRefiner } from \"../abstractRefiners\";\nimport { ParsingResult } from \"../../results\";\n\n/**\n * Merge weekday component into more completed data\n * - [Sunday] [12/7/2014] => [Sunday 12/7/2014]\n * - [Tuesday], [January 13, 2012] => [Sunday 12/7/2014]\n */\nexport default class MergeWeekdayComponentRefiner extends MergingRefiner {\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const newResult = nextResult.clone();\n        newResult.index = currentResult.index;\n        newResult.text = currentResult.text + textBetween + newResult.text;\n\n        newResult.start.assign(\"weekday\", currentResult.start.get(\"weekday\"));\n        if (newResult.end) {\n            newResult.end.assign(\"weekday\", currentResult.start.get(\"weekday\"));\n        }\n\n        return newResult;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        const weekdayThenNormalDate =\n            currentResult.start.isOnlyWeekdayComponent() &&\n            !currentResult.start.isCertain(\"hour\") &&\n            nextResult.start.isCertain(\"day\");\n        return weekdayThenNormalDate && textBetween.match(/^,?\\s*$/) != null;\n    }\n}\n", "import { Configuration, Parser, Refiner } from \"./chrono\";\n\nimport ExtractTimezoneAbbrRefiner from \"./common/refiners/ExtractTimezoneAbbrRefiner\";\nimport ExtractTimezoneOffsetRefiner from \"./common/refiners/ExtractTimezoneOffsetRefiner\";\nimport OverlapRemovalRefiner from \"./common/refiners/OverlapRemovalRefiner\";\nimport ForwardDateRefiner from \"./common/refiners/ForwardDateRefiner\";\nimport UnlikelyFormatFilter from \"./common/refiners/UnlikelyFormatFilter\";\nimport ISOFormatParser from \"./common/parsers/ISOFormatParser\";\nimport MergeWeekdayComponentRefiner from \"./common/refiners/MergeWeekdayComponentRefiner\";\n\nexport function includeCommonConfiguration(configuration: Configuration, strictMode = false): Configuration {\n    configuration.parsers.unshift(new ISOFormatParser());\n\n    configuration.refiners.unshift(new MergeWeekdayComponentRefiner());\n    configuration.refiners.unshift(new ExtractTimezoneOffsetRefiner());\n    configuration.refiners.unshift(new OverlapRemovalRefiner());\n\n    // Unlike ExtractTimezoneOffsetRefiner, this refiner relies on knowing both date and time in cases where the tz\n    // is ambiguous (in terms of DST/non-DST). It therefore needs to be applied as late as possible in the parsing.\n    configuration.refiners.push(new ExtractTimezoneAbbrRefiner());\n    configuration.refiners.push(new OverlapRemovalRefiner());\n    configuration.refiners.push(new ForwardDateRefiner());\n    configuration.refiners.push(new UnlikelyFormatFilter(strictMode));\n    return configuration;\n}\n", "import { ParsingComponents, ReferenceWithTimezone } from \"../results\";\nimport { assignSimilarDate, assignSimilarTime, implySimilarTime } from \"../utils/dates\";\nimport { Meridiem } from \"../types\";\n\nexport function now(reference: ReferenceWithTimezone): ParsingComponents {\n    const targetDate = reference.getDateWithAdjustedTimezone();\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    assignSimilarTime(component, targetDate);\n    component.assign(\"timezoneOffset\", reference.getTimezoneOffset());\n    component.addTag(\"casualReference/now\");\n    return component;\n}\n\nexport function today(reference: ReferenceWithTimezone): ParsingComponents {\n    const targetDate = reference.getDateWithAdjustedTimezone();\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    implySimilarTime(component, targetDate);\n    component.delete(\"meridiem\");\n    component.addTag(\"casualReference/today\");\n    return component;\n}\n\nexport function yesterday(reference: ReferenceWithTimezone): ParsingComponents {\n    return theDayBefore(reference, 1).addTag(\"casualReference/yesterday\");\n}\n\nexport function tomorrow(reference: ReferenceWithTimezone): ParsingComponents {\n    return theDayAfter(reference, 1).addTag(\"casualReference/tomorrow\");\n}\n\nexport function theDayBefore(reference: ReferenceWithTimezone, numDay: number): ParsingComponents {\n    return theDayAfter(reference, -numDay);\n}\n\nexport function theDayAfter(reference: ReferenceWithTimezone, nDays: number): ParsingComponents {\n    const targetDate = reference.getDateWithAdjustedTimezone();\n    const component = new ParsingComponents(reference, {});\n    const newDate = new Date(targetDate.getTime());\n    newDate.setDate(newDate.getDate() + nDays);\n\n    assignSimilarDate(component, newDate);\n    implySimilarTime(component, newDate);\n    component.delete(\"meridiem\");\n    return component;\n}\n\nexport function tonight(reference: ReferenceWithTimezone, implyHour = 22): ParsingComponents {\n    const targetDate = reference.getDateWithAdjustedTimezone();\n    const component = new ParsingComponents(reference, {});\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.addTag(\"casualReference/tonight\");\n    return component;\n}\n\nexport function lastNight(reference: ReferenceWithTimezone, implyHour = 0): ParsingComponents {\n    let targetDate = reference.getDateWithAdjustedTimezone();\n    const component = new ParsingComponents(reference, {});\n    if (targetDate.getHours() < 6) {\n        targetDate = new Date(targetDate.getTime() - 24 * 60 * 60 * 1000);\n    }\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    return component;\n}\n\nexport function evening(reference: ReferenceWithTimezone, implyHour = 20): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.imply(\"hour\", implyHour);\n    component.addTag(\"casualReference/evening\");\n    return component;\n}\n\nexport function yesterdayEvening(reference: ReferenceWithTimezone, implyHour = 20): ParsingComponents {\n    let targetDate = reference.getDateWithAdjustedTimezone();\n    const component = new ParsingComponents(reference, {});\n    targetDate = new Date(targetDate.getTime() - 24 * 60 * 60 * 1000);\n    assignSimilarDate(component, targetDate);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.addTag(\"casualReference/yesterday\");\n    component.addTag(\"casualReference/evening\");\n    return component;\n}\n\nexport function midnight(reference: ReferenceWithTimezone): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    if (reference.getDateWithAdjustedTimezone().getHours() > 2) {\n        // Unless it's very early morning (0~2AM), we assume the midnight is the coming midnight.\n        // Thus, increasing the day by 1.\n        component.addDurationAsImplied({ day: 1 });\n    }\n    component.assign(\"hour\", 0);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/midnight\");\n    return component;\n}\n\nexport function morning(reference: ReferenceWithTimezone, implyHour = 6): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.AM);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/morning\");\n    return component;\n}\n\nexport function afternoon(reference: ReferenceWithTimezone, implyHour = 15): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.PM);\n    component.imply(\"hour\", implyHour);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/afternoon\");\n    return component;\n}\n\nexport function noon(reference: ReferenceWithTimezone): ParsingComponents {\n    const component = new ParsingComponents(reference, {});\n    component.imply(\"meridiem\", Meridiem.AM);\n    component.assign(\"hour\", 12);\n    component.imply(\"minute\", 0);\n    component.imply(\"second\", 0);\n    component.imply(\"millisecond\", 0);\n    component.addTag(\"casualReference/noon\");\n    return component;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dates\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\\s*night)(?=\\W|$)/i;\n\nexport default class ENCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = context.refDate;\n        const lowerText = match[0].toLowerCase();\n        let component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"now\":\n                component = references.now(context.reference);\n                break;\n\n            case \"today\":\n                component = references.today(context.reference);\n                break;\n\n            case \"yesterday\":\n                component = references.yesterday(context.reference);\n                break;\n\n            case \"tomorrow\":\n            case \"tmr\":\n            case \"tmrw\":\n                component = references.tomorrow(context.reference);\n                break;\n\n            case \"tonight\":\n                component = references.tonight(context.reference);\n                break;\n\n            case \"overmorrow\":\n                component = references.theDayAfter(context.reference, 2);\n                break;\n\n            default:\n                if (lowerText.match(/last\\s*night/)) {\n                    if (targetDate.getHours() > 6) {\n                        const previousDay = new Date(targetDate.getTime());\n                        previousDay.setDate(previousDay.getDate() - 1);\n                        targetDate = previousDay;\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n                break;\n        }\n        component.addTag(\"parser/ENCasualDateParser\");\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as casualReferences from \"../../../common/casualReferences\";\n\nconst PATTERN = /(?:this)?\\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\\W|$)/i;\n\nexport default class ENCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return PATTERN;\n    }\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let component = null;\n        switch (match[1].toLowerCase()) {\n            case \"afternoon\":\n                component = casualReferences.afternoon(context.reference);\n                break;\n            case \"evening\":\n            case \"night\":\n                component = casualReferences.evening(context.reference);\n                break;\n            case \"midnight\":\n                component = casualReferences.midnight(context.reference);\n                break;\n            case \"morning\":\n                component = casualReferences.morning(context.reference);\n                break;\n            case \"noon\":\n            case \"midday\":\n                component = casualReferences.noon(context.reference);\n                break;\n        }\n        if (component) {\n            component.addTag(\"parser/ENCasualTimeParser\");\n        }\n        return component;\n    }\n}\n", "import { Weekday } from \"../types\";\nimport { ParsingComponents, ReferenceWithTimezone } from \"../results\";\nimport { implySimilarTime } from \"../utils/dates\";\n\n/**\n * Returns the parsing components at the weekday (considering the modifier). The time and timezone is assume to be\n * similar to the reference.\n * @param reference\n * @param weekday\n * @param modifier \"this\", \"next\", \"last\" modifier word. If empty, returns the weekday closest to the `refDate`.\n */\nexport function createParsingComponentsAtWeekday(\n    reference: ReferenceWithTimezone,\n    weekday: Weekday,\n    modifier?: \"this\" | \"next\" | \"last\"\n): ParsingComponents {\n    const refDate = reference.getDateWithAdjustedTimezone();\n    const daysToWeekday = getDaysToWeekday(refDate, weekday, modifier);\n\n    let components = new ParsingComponents(reference);\n    components = components.addDurationAsImplied({ day: daysToWeekday });\n    components.assign(\"weekday\", weekday);\n\n    return components;\n}\n\n/**\n * Returns number of days from refDate to the weekday. The refDate date and timezone information is used.\n * @param refDate\n * @param weekday\n * @param modifier \"this\", \"next\", \"last\" modifier word. If empty, returns the weekday closest to the `refDate`.\n */\nexport function getDaysToWeekday(refDate: Date, weekday: Weekday, modifier?: \"this\" | \"next\" | \"last\"): number {\n    const refWeekday = refDate.getDay() as Weekday;\n    switch (modifier) {\n        case \"this\":\n            return getDaysForwardToWeekday(refDate, weekday);\n        case \"last\":\n            return getBackwardDaysToWeekday(refDate, weekday);\n        case \"next\":\n            // From Sunday, the next Sunday is 7 days later.\n            // Otherwise, next Mon is 1 days later, next Tues is 2 days later, and so on..., (return enum value)\n            if (refWeekday == Weekday.SUNDAY) {\n                return weekday == Weekday.SUNDAY ? 7 : weekday;\n            }\n            // From Saturday, the next Saturday is 7 days later, the next Sunday is 8-days later.\n            // Otherwise, next Mon is (1 + 1) days later, next Tues is (1 + 2) days later, and so on...,\n            // (return, 2 + [enum value] days)\n            if (refWeekday == Weekday.SATURDAY) {\n                if (weekday == Weekday.SATURDAY) return 7;\n                if (weekday == Weekday.SUNDAY) return 8;\n                return 1 + weekday;\n            }\n            // From weekdays, next Mon is the following week's Mon, next Tues the following week's Tues, and so on...\n            // If the week's weekday already passed (weekday < refWeekday), we simply count forward to next week\n            // (similar to 'this'). Otherwise, count forward to this week, then add another 7 days.\n            if (weekday < refWeekday && weekday != Weekday.SUNDAY) {\n                return getDaysForwardToWeekday(refDate, weekday);\n            } else {\n                return getDaysForwardToWeekday(refDate, weekday) + 7;\n            }\n    }\n    return getDaysToWeekdayClosest(refDate, weekday);\n}\n\nexport function getDaysToWeekdayClosest(refDate: Date, weekday: Weekday): number {\n    const backward = getBackwardDaysToWeekday(refDate, weekday);\n    const forward = getDaysForwardToWeekday(refDate, weekday);\n\n    return forward < -backward ? forward : backward;\n}\n\nexport function getDaysForwardToWeekday(refDate: Date, weekday: Weekday): number {\n    const refWeekday = refDate.getDay();\n    let forwardCount = weekday - refWeekday;\n    if (forwardCount < 0) {\n        forwardCount += 7;\n    }\n    return forwardCount;\n}\n\nexport function getBackwardDaysToWeekday(refDate: Date, weekday: Weekday): number {\n    const refWeekday = refDate.getDay();\n    let backwardCount = weekday - refWeekday;\n    if (backwardCount >= 0) {\n        backwardCount -= 7;\n    }\n    return backwardCount;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\nimport { Weekday } from \"../../../types\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:on\\\\s*?)?\" +\n        \"(?:(this|last|past|next)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)}|weekend|weekday)` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(this|last|past|next)\\\\s*week)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ENWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"last\" || modifierWord == \"past\") {\n            modifier = \"last\";\n        } else if (modifierWord == \"next\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"this\") {\n            modifier = \"this\";\n        }\n\n        const weekday_word = match[WEEKDAY_GROUP].toLowerCase();\n        let weekday;\n        if (WEEKDAY_DICTIONARY[weekday_word] !== undefined) {\n            weekday = WEEKDAY_DICTIONARY[weekday_word];\n        } else if (weekday_word == \"weekend\") {\n            // This depends on what days are weekend setting, but typically:\n            // 'This/next weekend' means the coming Saturday, 'last weekend' means last Sunday.\n            weekday = modifier == \"last\" ? Weekday.SUNDAY : Weekday.SATURDAY;\n        } else if (weekday_word == \"weekday\") {\n            // In English, the \"weekday\" means any day of the week except weekend.\n            // This also depends on what days are weekend setting, but typically:\n            // - On weekend ref, this means the coming Monday or last Friday.\n            // - On weekday ref, this means the next/last working day.\n            const refWeekday = context.reference.getDateWithAdjustedTimezone().getDay();\n            if (refWeekday == Weekday.SUNDAY || refWeekday == Weekday.SATURDAY) {\n                weekday = modifier == \"last\" ? Weekday.FRIDAY : Weekday.MONDAY;\n            } else {\n                weekday = refWeekday - 1;\n                weekday = modifier == \"last\" ? weekday - 1 : weekday + 1;\n                weekday = (weekday % 5) + 1;\n            }\n        } else {\n            return null;\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nconst PATTERN = new RegExp(\n    `(this|last|past|next|after\\\\s*this)\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)` + \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class ENRelativeDateFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"next\" || modifier.startsWith(\"after\")) {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = new Date(context.reference.instant.getTime());\n\n        // This week\n        if (unitWord.match(/week/i)) {\n            date.setDate(date.getDate() - date.getDay());\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.imply(\"year\", date.getFullYear());\n        }\n\n        // This month\n        else if (unitWord.match(/month/i)) {\n            date.setDate(1);\n            components.imply(\"day\", date.getDate());\n            components.assign(\"year\", date.getFullYear());\n            components.assign(\"month\", date.getMonth() + 1);\n        }\n\n        // This year\n        else if (unitWord.match(/year/i)) {\n            date.setDate(1);\n            date.setMonth(0);\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.assign(\"year\", date.getFullYear());\n        }\n\n        return components;\n    }\n}\n", "import { Parser, ParsingContext } from \"../../chrono\";\nimport { ParsingResult } from \"../../results\";\nimport { findMostLikelyADYear, findYearClosestToRef } from \"../../calculation/years\";\n\n/**\n * Date format with slash \"/\" (or dot \".\") between numbers.\n * For examples:\n * - 7/10\n * - 7/12/2020\n * - 7.12.2020\n */\nconst PATTERN = new RegExp(\n    \"([^\\\\d]|^)\" +\n        \"([0-3]{0,1}[0-9]{1})[\\\\/\\\\.\\\\-]([0-3]{0,1}[0-9]{1})\" +\n        \"(?:[\\\\/\\\\.\\\\-]([0-9]{4}|[0-9]{2}))?\" +\n        \"(\\\\W|$)\",\n    \"i\"\n);\n\nconst OPENING_GROUP = 1;\nconst ENDING_GROUP = 5;\n\nconst FIRST_NUMBERS_GROUP = 2;\nconst SECOND_NUMBERS_GROUP = 3;\n\nconst YEAR_GROUP = 4;\n\nexport default class SlashDateFormatParser implements Parser {\n    groupNumberMonth: number;\n    groupNumberDay: number;\n\n    constructor(littleEndian: boolean) {\n        this.groupNumberMonth = littleEndian ? SECOND_NUMBERS_GROUP : FIRST_NUMBERS_GROUP;\n        this.groupNumberDay = littleEndian ? FIRST_NUMBERS_GROUP : SECOND_NUMBERS_GROUP;\n    }\n\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        // Because of how pattern is executed on remaining text in `chrono.ts`, the character before the match could\n        // still be a number (e.g. X[X/YY/ZZ] or XX[/YY/ZZ] or [XX/YY/]ZZ). We want to check and skip them.\n        const index = match.index + match[OPENING_GROUP].length;\n        const indexEnd = match.index + match[0].length - match[ENDING_GROUP].length;\n        if (index > 0) {\n            const textBefore = context.text.substring(0, index);\n            if (textBefore.match(\"\\\\d/?$\")) {\n                return;\n            }\n        }\n        if (indexEnd < context.text.length) {\n            const textAfter = context.text.substring(indexEnd);\n            if (textAfter.match(\"^/?\\\\d\")) {\n                return;\n            }\n        }\n\n        const text = context.text.substring(index, indexEnd);\n\n        // '1.12', '1.12.12' is more like a version numbers\n        if (text.match(/^\\d\\.\\d$/) || text.match(/^\\d\\.\\d{1,2}\\.\\d{1,2}\\s*$/)) {\n            return;\n        }\n\n        // MM/dd -> OK\n        // MM.dd -> NG\n        if (!match[YEAR_GROUP] && text.indexOf(\"/\") < 0) {\n            return;\n        }\n\n        const result = context.createParsingResult(index, text);\n        let month = parseInt(match[this.groupNumberMonth]);\n        let day = parseInt(match[this.groupNumberDay]);\n        if (month < 1 || month > 12) {\n            if (month > 12) {\n                if (day >= 1 && day <= 12 && month <= 31) {\n                    [day, month] = [month, day];\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        result.start.assign(\"day\", day);\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const rawYearNumber = parseInt(match[YEAR_GROUP]);\n            const year = findMostLikelyADYear(rawYearNumber);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result.addTag(\"parser/SlashDateFormatParser\");\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(`(this|last|past|next|after|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\nconst PATTERN_NO_ABBR = new RegExp(\n    `(this|last|past|next|after|\\\\+|-)\\\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private allowAbbreviations: boolean = true) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.allowAbbreviations ? PATTERN : PATTERN_NO_ABBR;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const prefix = match[1].toLowerCase();\n        let duration = parseDuration(match[2]);\n        if (!duration) {\n            return null;\n        }\n        switch (prefix) {\n            case \"last\":\n            case \"past\":\n            case \"-\":\n                duration = reverseDuration(duration);\n                break;\n        }\n        return ParsingComponents.createRelativeFromReference(context.reference, duration);\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseDuration } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction IsPositiveFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^[+-]/i) != null;\n}\n\nfunction IsNegativeFollowingReference(result: ParsingResult): boolean {\n    return result.text.match(/^-/i) != null;\n}\n\n/**\n * Merges a relative data/time that comes after an absolute date.\n * - [2020-02-13] [+2 weeks]\n * - [next tuesday] [+10 days]\n */\nexport default class ENMergeRelativeAfterDateRefiner extends MergingRefiner {\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        if (!textBetween.match(/^\\s*$/i)) {\n            return false;\n        }\n\n        return IsPositiveFollowingReference(nextResult) || IsNegativeFollowingReference(nextResult);\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult, context): ParsingResult {\n        let timeUnits = parseDuration(nextResult.text);\n        if (IsNegativeFollowingReference(nextResult)) {\n            timeUnits = reverseDuration(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            ReferenceWithTimezone.fromDate(currentResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            currentResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseDuration } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(before|from)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(after|since)$/i) != null;\n}\n\n/**\n * Merges a relative data/time that follow by an absolute date.\n * - [2 weeks before] [2020-02-13]\n * - [2 days after] [next Friday]\n */\nexport default class ENMergeRelativeFollowByDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let duration = parseDuration(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            duration = reverseDuration(duration);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            ReferenceWithTimezone.fromDate(nextResult.start.date()),\n            duration\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { ParsingContext, Refiner } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\n\nconst YEAR_SUFFIX_PATTERN = new RegExp(`^\\\\s*(${YEAR_PATTERN})`, \"i\");\nconst YEAR_GROUP = 1;\nexport default class ENExtractYearSuffixRefiner implements Refiner {\n    refine(context: ParsingContext, results: ParsingResult[]): ParsingResult[] {\n        results.forEach(function (result) {\n            if (!result.start.isDateWithUnknownYear()) {\n                return;\n            }\n            const suffix = context.text.substring(result.index + result.text.length);\n            const match = YEAR_SUFFIX_PATTERN.exec(suffix);\n            if (!match) {\n                return;\n            }\n            // If the suffix match is just a short number, e.g. \"14/4 90\", don't assume it year.\n            if (match[0].trim().length <= 3) {\n                return;\n            }\n            context.debug(() => {\n                console.log(`Extracting year: '${match[0]}' into : ${result}`);\n            });\n            const year = parseYear(match[YEAR_GROUP]);\n            if (result.end != null) {\n                result.end.assign(\"year\", year);\n            }\n            result.start.assign(\"year\", year);\n            result.text += match[0];\n        });\n        return results;\n    }\n}\n", "import { Filter } from \"../../../common/abstractRefiners\";\nimport { ParsingResult } from \"../../../results\";\n\nexport default class ENUnlikelyFormatFilter extends Filter {\n    constructor() {\n        super();\n    }\n\n    isValid(context, result: ParsingResult): boolean {\n        const text = result.text.trim();\n\n        // If the result is consists of the whole text (e.g. \"2024\", \"May\", etc),\n        // then it is unlikely to be a date.\n        if (text === context.text.trim()) {\n            return true;\n        }\n\n        // In English, the word \"may\" is a month name, but it is also a modal verb.\n        // Check if the text before \"may\" follows some allowed patterns.\n        if (text.toLowerCase() === \"may\") {\n            const textBefore = context.text.substring(0, result.index).trim();\n            if (!textBefore.match(/\\b(in)$/i)) {\n                context.debug(() => {\n                    console.log(`Removing unlikely result: ${result}`);\n                });\n\n                return false;\n            }\n        }\n\n        // In English, \"the second\" could refer to the ordinal number or timeunit.\n        if (text.toLowerCase().endsWith(\"the second\")) {\n            const textAfter = context.text.substring(result.index + result.text.length).trim();\n            if (textAfter.length > 0) {\n                context.debug(() => {\n                    console.log(`Removing unlikely result: ${result}`);\n                });\n            }\n            return false;\n        }\n\n        return true;\n    }\n}\n", "import { Configuration } from \"../../chrono\";\n\nimport ENTimeUnitWithinFormatParser from \"./parsers/ENTimeUnitWithinFormatParser\";\nimport ENMonthNameLittleEndianParser from \"./parsers/ENMonthNameLittleEndianParser\";\nimport ENMonthNameMiddleEndianParser from \"./parsers/ENMonthNameMiddleEndianParser\";\nimport ENMonthNameParser from \"./parsers/ENMonthNameParser\";\nimport ENYearMonthDayParser from \"./parsers/ENYearMonthDayParser\";\nimport ENSlashMonthFormatParser from \"./parsers/ENSlashMonthFormatParser\";\nimport ENTimeExpressionParser from \"./parsers/ENTimeExpressionParser\";\nimport ENTimeUnitAgoFormatParser from \"./parsers/ENTimeUnitAgoFormatParser\";\nimport ENTimeUnitLaterFormatParser from \"./parsers/ENTimeUnitLaterFormatParser\";\nimport ENMergeDateRangeRefiner from \"./refiners/ENMergeDateRangeRefiner\";\nimport ENMergeDateTimeRefiner from \"./refiners/ENMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport ENCasualDateParser from \"./parsers/ENCasualDateParser\";\nimport ENCasualTimeParser from \"./parsers/ENCasualTimeParser\";\nimport ENWeekdayParser from \"./parsers/ENWeekdayParser\";\nimport ENRelativeDateFormatParser from \"./parsers/ENRelativeDateFormatParser\";\n\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ENTimeUnitCasualRelativeFormatParser from \"./parsers/ENTimeUnitCasualRelativeFormatParser\";\nimport ENMergeRelativeAfterDateRefiner from \"./refiners/ENMergeRelativeAfterDateRefiner\";\nimport ENMergeRelativeFollowByDateRefiner from \"./refiners/ENMergeRelativeFollowByDateRefiner\";\nimport OverlapRemovalRefiner from \"../../common/refiners/OverlapRemovalRefiner\";\nimport ENExtractYearSuffixRefiner from \"./refiners/ENExtractYearSuffixRefiner\";\nimport ENUnlikelyFormatFilter from \"./refiners/ENUnlikelyFormatFilter\";\n\nexport default class ENDefaultConfiguration {\n    /**\n     * Create a default *casual* {@Link Configuration} for English chrono.\n     * It calls {@Link createConfiguration} and includes additional parsers.\n     */\n    createCasualConfiguration(littleEndian = false): Configuration {\n        const option = this.createConfiguration(false, littleEndian);\n        option.parsers.push(new ENCasualDateParser());\n        option.parsers.push(new ENCasualTimeParser());\n        option.parsers.push(new ENMonthNameParser());\n        option.parsers.push(new ENRelativeDateFormatParser());\n        option.parsers.push(new ENTimeUnitCasualRelativeFormatParser());\n        option.refiners.push(new ENUnlikelyFormatFilter());\n        return option;\n    }\n\n    /**\n     * Create a default {@Link Configuration} for English chrono\n     *\n     * @param strictMode If the timeunit mentioning should be strict, not casual\n     * @param littleEndian If format should be date-first/littleEndian (e.g. en_UK), not month-first/middleEndian (e.g. en_US)\n     */\n    createConfiguration(strictMode = true, littleEndian = false): Configuration {\n        const options = includeCommonConfiguration(\n            {\n                parsers: [\n                    new SlashDateFormatParser(littleEndian),\n                    new ENTimeUnitWithinFormatParser(strictMode),\n                    new ENMonthNameLittleEndianParser(),\n                    new ENMonthNameMiddleEndianParser(/*shouldSkipYearLikeDate=*/ littleEndian),\n                    new ENWeekdayParser(),\n                    new ENSlashMonthFormatParser(),\n                    new ENTimeExpressionParser(strictMode),\n                    new ENTimeUnitAgoFormatParser(strictMode),\n                    new ENTimeUnitLaterFormatParser(strictMode),\n                ],\n                refiners: [new ENMergeDateTimeRefiner()],\n            },\n            strictMode\n        );\n        options.parsers.unshift(new ENYearMonthDayParser(/*strictMonthDateOrder=*/ strictMode));\n\n        // These relative-dates consideration should be done before other common refiners.\n        options.refiners.unshift(new ENMergeRelativeFollowByDateRefiner());\n        options.refiners.unshift(new ENMergeRelativeAfterDateRefiner());\n        options.refiners.unshift(new OverlapRemovalRefiner());\n\n        // Re-apply the date time refiner again after the timezone refinement and exclusion in common refiners.\n        options.refiners.push(new ENMergeDateTimeRefiner());\n\n        // Extract year after merging date and time\n        options.refiners.push(new ENExtractYearSuffixRefiner());\n\n        // Keep the date range refiner at the end (after all other refinements).\n        options.refiners.push(new ENMergeDateRangeRefiner());\n        return options;\n    }\n}\n", "import { ReferenceWithTimezone, ParsingComponents, ParsingResult } from \"./results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference } from \"./types\";\nimport { AsyncDebugBlock, DebugHandler } from \"./debugging\";\nimport ENDefaultConfiguration from \"./locales/en/configuration\";\nimport { toTimezoneOffset } from \"./timezone\";\n\n/**\n * Chrono configuration.\n * It is simply an ordered list of parsers and refiners\n */\nexport interface Configuration {\n    parsers: Parser[];\n    refiners: Refiner[];\n}\n\n/**\n * An abstraction for Chrono *Parser*.\n *\n * Each parser should recognize and handle a certain date format.\n * Chrono uses multiple parses (and refiners) together for parsing the input.\n *\n * The parser implementation must provide {@Link pattern | pattern()} for the date format.\n *\n * The {@Link extract | extract()} method is called with the pattern's *match*.\n * The matching and extracting is controlled and adjusted to avoid for overlapping results.\n */\nexport interface Parser {\n    pattern(context: ParsingContext): RegExp;\n    extract(\n        context: ParsingContext,\n        match: RegExpMatchArray\n    ): ParsingComponents | ParsingResult | { [c in Component]?: number } | null;\n}\n\n/**\n * A abstraction for Chrono *Refiner*.\n *\n * Each refiner takes the list of results (from parsers or other refiners) and returns another list of results.\n * Chrono applies each refiner in order and return the output from the last refiner.\n */\nexport interface Refiner {\n    refine: (context: ParsingContext, results: ParsingResult[]) => ParsingResult[];\n}\n\n/**\n * The Chrono object.\n */\nexport class Chrono {\n    parsers: Array<Parser>;\n    refiners: Array<Refiner>;\n\n    defaultConfig = new ENDefaultConfiguration();\n\n    constructor(configuration?: Configuration) {\n        configuration = configuration || this.defaultConfig.createCasualConfiguration();\n        this.parsers = [...configuration.parsers];\n        this.refiners = [...configuration.refiners];\n    }\n\n    /**\n     * Create a shallow copy of the Chrono object with the same configuration (`parsers` and `refiners`)\n     */\n    clone(): Chrono {\n        return new Chrono({\n            parsers: [...this.parsers],\n            refiners: [...this.refiners],\n        });\n    }\n\n    /**\n     * A shortcut for calling {@Link parse | parse() } then transform the result into Javascript's Date object\n     * @return Date object created from the first parse result\n     */\n    parseDate(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): Date | null {\n        const results = this.parse(text, referenceDate, option);\n        return results.length > 0 ? results[0].start.date() : null;\n    }\n\n    parse(text: string, referenceDate?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n        const context = new ParsingContext(text, referenceDate, option);\n\n        let results = [];\n        this.parsers.forEach((parser) => {\n            const parsedResults = Chrono.executeParser(context, parser);\n            results = results.concat(parsedResults);\n        });\n\n        results.sort((a, b) => {\n            return a.index - b.index;\n        });\n\n        this.refiners.forEach(function (refiner) {\n            results = refiner.refine(context, results);\n        });\n\n        return results;\n    }\n\n    private static executeParser(context: ParsingContext, parser: Parser) {\n        const results = [];\n        const pattern = parser.pattern(context);\n\n        const originalText = context.text;\n        let remainingText = context.text;\n        let match = pattern.exec(remainingText);\n\n        while (match) {\n            // Calculate match index on the full text;\n            const index = match.index + originalText.length - remainingText.length;\n            match.index = index;\n\n            const result = parser.extract(context, match);\n            if (!result) {\n                // If fails, move on by 1\n                remainingText = originalText.substring(match.index + 1);\n                match = pattern.exec(remainingText);\n                continue;\n            }\n\n            let parsedResult: ParsingResult = null;\n            if (result instanceof ParsingResult) {\n                parsedResult = result;\n            } else if (result instanceof ParsingComponents) {\n                parsedResult = context.createParsingResult(match.index, match[0]);\n                parsedResult.start = result;\n            } else {\n                parsedResult = context.createParsingResult(match.index, match[0], result);\n            }\n\n            const parsedIndex = parsedResult.index;\n            const parsedText = parsedResult.text;\n            context.debug(() =>\n                console.log(`${parser.constructor.name} extracted (at index=${parsedIndex}) '${parsedText}'`)\n            );\n\n            results.push(parsedResult);\n            remainingText = originalText.substring(parsedIndex + parsedText.length);\n            match = pattern.exec(remainingText);\n        }\n\n        return results;\n    }\n}\n\nexport class ParsingContext implements DebugHandler {\n    readonly text: string;\n    readonly option: ParsingOption;\n    readonly reference: ReferenceWithTimezone;\n\n    /**\n     * @deprecated. Use `reference.instant` instead.\n     */\n    readonly refDate: Date;\n\n    constructor(text: string, refDate?: ParsingReference | Date, option?: ParsingOption) {\n        this.text = text;\n        this.option = option ?? {};\n        this.reference = ReferenceWithTimezone.fromInput(refDate, this.option.timezones);\n        this.refDate = this.reference.instant;\n    }\n\n    createParsingComponents(components?: { [c in Component]?: number } | ParsingComponents): ParsingComponents {\n        if (components instanceof ParsingComponents) {\n            return components;\n        }\n\n        return new ParsingComponents(this.reference, components);\n    }\n\n    createParsingResult(\n        index: number,\n        textOrEndIndex: number | string,\n        startComponents?: { [c in Component]?: number } | ParsingComponents,\n        endComponents?: { [c in Component]?: number } | ParsingComponents\n    ): ParsingResult {\n        const text = typeof textOrEndIndex === \"string\" ? textOrEndIndex : this.text.substring(index, textOrEndIndex);\n\n        const start = startComponents ? this.createParsingComponents(startComponents) : null;\n        const end = endComponents ? this.createParsingComponents(endComponents) : null;\n\n        return new ParsingResult(this.reference, index, text, start, end);\n    }\n\n    debug(block: AsyncDebugBlock): void {\n        if (this.option.debug) {\n            if (this.option.debug instanceof Function) {\n                this.option.debug(block);\n            } else {\n                const handler: DebugHandler = <DebugHandler>this.option.debug;\n                handler.debug(block);\n            }\n        }\n    }\n}\n", "import { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ISOFormatParser from \"../../common/parsers/ISOFormatParser\";\nimport DETimeExpressionParser from \"./parsers/DETimeExpressionParser\";\nimport DEWeekdayParser from \"./parsers/DEWeekdayParser\";\nimport DESpecificTimeExpressionParser from \"./parsers/DESpecificTimeExpressionParser\";\nimport DEMergeDateRangeRefiner from \"./refiners/DEMergeDateRangeRefiner\";\nimport DEMergeDateTimeRefiner from \"./refiners/DEMergeDateTimeRefiner\";\nimport DECasualDateParser from \"./parsers/DECasualDateParser\";\nimport DECasualTimeParser from \"./parsers/DECasualTimeParser\";\nimport DEMonthNameLittleEndianParser from \"./parsers/DEMonthNameLittleEndianParser\";\nimport DETimeUnitRelativeFormatParser from \"./parsers/DETimeUnitRelativeFormatParser\";\nimport DETimeUnitWithinFormatParser from \"./parsers/DETimeUnitWithinFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new DECasualTimeParser());\n    option.parsers.unshift(new DECasualDateParser());\n    option.parsers.unshift(new DETimeUnitRelativeFormatParser());\n    return option;\n}\n\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new ISOFormatParser(),\n                new SlashDateFormatParser(littleEndian),\n                new DETimeExpressionParser(),\n                new DESpecificTimeExpressionParser(),\n                new DEMonthNameLittleEndianParser(),\n                new DEWeekdayParser(),\n                new DETimeUnitWithinFormatParser(),\n            ],\n            refiners: [new DEMergeDateRangeRefiner(), new DEMergeDateTimeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { ParsingComponents } from \"../../../results\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport default class DETimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:um|von)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|bis)\\\\s*\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        // This looks more like a year e.g. 2020\n        if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n            return null;\n        }\n\n        return super.extractPrimaryTimeComponents(context, match);\n    }\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"sonntag\": 0,\n    \"so\": 0,\n    \"montag\": 1,\n    \"mo\": 1,\n    \"dienstag\": 2,\n    \"di\": 2,\n    \"mittwoch\": 3,\n    \"mi\": 3,\n    \"donnerstag\": 4,\n    \"do\": 4,\n    \"freitag\": 5,\n    \"fr\": 5,\n    \"samstag\": 6,\n    \"sa\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"januar\": 1,\n    \"jänner\": 1,\n    \"janner\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"februar\": 2,\n    \"feber\": 2,\n    \"feb\": 2,\n    \"feb.\": 2,\n    \"märz\": 3,\n    \"maerz\": 3,\n    \"mär\": 3,\n    \"mär.\": 3,\n    \"mrz\": 3,\n    \"mrz.\": 3,\n    \"april\": 4,\n    \"apr\": 4,\n    \"apr.\": 4,\n    \"mai\": 5,\n    \"juni\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"juli\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"august\": 8,\n    \"aug\": 8,\n    \"aug.\": 8,\n    \"september\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"sept\": 9,\n    \"sept.\": 9,\n    \"oktober\": 10,\n    \"okt\": 10,\n    \"okt.\": 10,\n    \"november\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"dezember\": 12,\n    \"dez\": 12,\n    \"dez.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"eins\": 1,\n    \"eine\": 1,\n    \"einem\": 1,\n    \"einen\": 1,\n    \"einer\": 1,\n    \"zwei\": 2,\n    \"drei\": 3,\n    \"vier\": 4,\n    \"fünf\": 5,\n    \"fuenf\": 5,\n    \"sechs\": 6,\n    \"sieben\": 7,\n    \"acht\": 8,\n    \"neun\": 9,\n    \"zehn\": 10,\n    \"elf\": 11,\n    \"zwölf\": 12,\n    \"zwoelf\": 12,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    sek: \"second\",\n    sekunde: \"second\",\n    sekunden: \"second\",\n    min: \"minute\",\n    minute: \"minute\",\n    minuten: \"minute\",\n    h: \"hour\",\n    std: \"hour\",\n    stunde: \"hour\",\n    stunden: \"hour\",\n    tag: \"day\",\n    tage: \"day\",\n    tagen: \"day\",\n    woche: \"week\",\n    wochen: \"week\",\n    monat: \"month\",\n    monate: \"month\",\n    monaten: \"month\",\n    monats: \"month\",\n    quartal: \"quarter\",\n    quartals: \"quarter\",\n    quartale: \"quarter\",\n    quartalen: \"quarter\",\n    a: \"year\",\n    j: \"year\",\n    jr: \"year\",\n    jahr: \"year\",\n    jahre: \"year\",\n    jahren: \"year\",\n    jahres: \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|halb?|halbe?|einigen?|wenigen?|mehreren?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"ein\" || num === \"einer\" || num === \"einem\" || num === \"einen\" || num === \"eine\") {\n        return 1;\n    } else if (num.match(/wenigen/)) {\n        return 2;\n    } else if (num.match(/halb/) || num.match(/halben/)) {\n        return 0.5;\n    } else if (num.match(/einigen/)) {\n        return 3;\n    } else if (num.match(/mehreren/)) {\n        return 7;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[0-9]{1,4}(?:\\\\s*[vn]\\\\.?\\\\s*(?:C(?:hr)?|(?:u\\\\.?|d\\\\.?(?:\\\\s*g\\\\.?)?)?\\\\s*Z)\\\\.?|\\\\s*(?:u\\\\.?|d\\\\.?(?:\\\\s*g\\\\.)?)\\\\s*Z\\\\.?)?)`;\nexport function parseYear(match: string): number {\n    if (/v/i.test(match)) {\n        // v.Chr.\n        return -parseInt(match.replace(/[^0-9]+/gi, \"\"));\n    }\n\n    if (/n/i.test(match)) {\n        // n.Chr.\n        return parseInt(match.replace(/[^0-9]+/gi, \"\"));\n    }\n\n    if (/z/i.test(match)) {\n        // n.Chr. as \"uZ\" or \"dgZ\"\n        return parseInt(match.replace(/[^0-9]+/gi, \"\"));\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:a[mn]\\\\s*?)?\" +\n        \"(?:(diese[mn]|letzte[mn]|n(?:ä|ae)chste[mn])\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(diese|letzte|n(?:ä|ae)chste)\\\\s*woche)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst SUFFIX_GROUP = 3;\nconst WEEKDAY_GROUP = 2;\n\nexport default class DEWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const offset = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[SUFFIX_GROUP];\n\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord.match(/letzte/)) {\n            modifier = \"last\";\n        } else if (modifierWord.match(/chste/)) {\n            modifier = \"next\";\n        } else if (modifierWord.match(/diese/)) {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, offset, modifier);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\n\n/**\n * 8h10m00s\n * 8h10m00\n * 8h10\n * 8 Uhr\n * 8h10m00s Uhr\n * 8:10 Uhr\n */\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(^|\\\\s|T)\" +\n        \"(?:(?:um|von)\\\\s*)?\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s)?)?\" +\n        \"(?:\\\\s*Uhr)?\" +\n        \"(?:\\\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\\\s+der\\\\s+Nacht))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"^\\\\s*(\\\\-|\\\\–|\\\\~|\\\\〜|bis(?:\\\\s+um)?|\\\\?)\\\\s*\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s)?)?\" +\n        \"(?:\\\\s*Uhr)?\" +\n        \"(?:\\\\s*(morgens|vormittags|nachmittags|abends|nachts|am\\\\s+(?:Morgen|Vormittag|Nachmittag|Abend)|in\\\\s+der\\\\s+Nacht))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP = 5;\n\nexport default class DESpecificTimeExpressionParser implements Parser {\n    pattern(context): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult | null {\n        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));\n\n        // This looks more like a year e.g. 2020\n        if (result.text.match(/^\\d{4}$/)) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        result.start = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);\n        if (!result.start) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        const remainingText = context.text.substring(match.index + match[0].length);\n        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);\n        if (secondMatch) {\n            result.end = DESpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);\n            if (result.end) {\n                result.text += secondMatch[0];\n            }\n        }\n\n        return result;\n    }\n\n    private static extractTimeComponent(\n        extractingComponents: ParsingComponents,\n        match: RegExpMatchArray\n    ): ParsingComponents | null {\n        let hour = 0;\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        hour = parseInt(match[HOUR_GROUP]);\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP].toLowerCase();\n            if (ampm.match(/morgen|vormittag/)) {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm.match(/nachmittag|abend/)) {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n\n            if (ampm.match(/nacht/)) {\n                if (hour == 12) {\n                    meridiem = Meridiem.AM;\n                    hour = 0;\n                } else if (hour < 6) {\n                    meridiem = Meridiem.AM;\n                } else {\n                    meridiem = Meridiem.PM;\n                    hour += 12;\n                }\n            }\n        }\n\n        extractingComponents.assign(\"hour\", hour);\n        extractingComponents.assign(\"minute\", minute);\n        if (meridiem !== null) {\n            extractingComponents.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                extractingComponents.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                extractingComponents.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            extractingComponents.assign(\"second\", second);\n        }\n\n        return extractingComponents;\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class DEMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(bis(?:\\s*(?:am|zum))?|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class DEMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|um|am|,|-)?\\\\s*$\");\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { implySimilarTime } from \"../../../utils/dates\";\n\nexport default class DECasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(diesen)?\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const targetDate = context.refDate;\n        const timeKeywordPattern = match[2].toLowerCase();\n        const component = context.createParsingComponents();\n        implySimilarTime(component, targetDate);\n        return DECasualTimeParser.extractTimeComponents(component, timeKeywordPattern);\n    }\n\n    static extractTimeComponents(component: ParsingComponents, timeKeywordPattern: string): ParsingComponents {\n        switch (timeKeywordPattern) {\n            case \"morgen\":\n                component.imply(\"hour\", 6);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"vormittag\":\n                component.imply(\"hour\", 9);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"mittag\":\n            case \"mittags\":\n                component.imply(\"hour\", 12);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"nachmittag\":\n                component.imply(\"hour\", 15);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"abend\":\n                component.imply(\"hour\", 18);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"nacht\":\n                component.imply(\"hour\", 22);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"mitternacht\":\n                if (component.get(\"hour\") > 1) {\n                    component.addDurationAsImplied({ \"day\": 1 });\n                }\n\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n        }\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\nimport DECasualTimeParser from \"./DECasualTimeParser\";\nimport * as references from \"../../../common/casualReferences\";\nimport { addDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(\n    `(jetzt|heute|morgen|übermorgen|uebermorgen|gestern|vorgestern|letzte\\\\s*nacht)` +\n        `(?:\\\\s*(morgen|vormittag|mittags?|nachmittag|abend|nacht|mitternacht))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst TIME_GROUP = 2;\n\nexport default class DECasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = context.reference.getDateWithAdjustedTimezone();\n        const dateKeyword = (match[DATE_GROUP] || \"\").toLowerCase();\n        const timeKeyword = (match[TIME_GROUP] || \"\").toLowerCase();\n\n        let component = context.createParsingComponents();\n        switch (dateKeyword) {\n            case \"jetzt\":\n                component = references.now(context.reference);\n                break;\n\n            case \"heute\":\n                component = references.today(context.reference);\n                break;\n\n            case \"morgen\":\n                targetDate = addDuration(targetDate, { day: 1 });\n                assignSimilarDate(component, targetDate);\n                implySimilarTime(component, targetDate);\n                break;\n\n            case \"übermorgen\":\n            case \"uebermorgen\":\n                targetDate = addDuration(targetDate, { day: 2 });\n                assignSimilarDate(component, targetDate);\n                implySimilarTime(component, targetDate);\n                break;\n\n            case \"gestern\":\n                targetDate = addDuration(targetDate, { day: -1 });\n                assignSimilarDate(component, targetDate);\n                implySimilarTime(component, targetDate);\n                break;\n\n            case \"vorgestern\":\n                targetDate = addDuration(targetDate, { day: -2 });\n                assignSimilarDate(component, targetDate);\n                implySimilarTime(component, targetDate);\n                break;\n\n            default:\n                if (dateKeyword.match(/letzte\\s*nacht/)) {\n                    if (targetDate.getHours() > 6) {\n                        targetDate = addDuration(targetDate, { day: -1 });\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n\n                break;\n        }\n\n        if (timeKeyword) {\n            component = DECasualTimeParser.extractTimeComponents(component, timeKeyword);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:am\\\\s*?)?\" +\n        \"(?:den\\\\s*?)?\" +\n        `([0-9]{1,2})\\\\.` +\n        `(?:\\\\s*(?:bis(?:\\\\s*(?:am|zum))?|\\\\-|\\\\–|\\\\s)\\\\s*([0-9]{1,2})\\\\.?)?\\\\s*` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:(?:-|/|,?\\\\s*)(${YEAR_PATTERN}(?![^\\\\s]\\\\d)))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class DEMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { NUMBER_PATTERN, parseNumberPattern, TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class DETimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(\n            `(?:\\\\s*((?:nächste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?|vor|in)\\\\s*)?` +\n                `(${NUMBER_PATTERN})?` +\n                `(?:\\\\s*(nächste|kommende|folgende|letzte|vergangene|vorige|vor(?:her|an)gegangene)(?:s|n|m|r)?)?` +\n                `\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`,\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const num = match[2] ? parseNumberPattern(match[2]) : 1;\n        const unit = TIME_UNIT_DICTIONARY[match[4].toLowerCase()];\n        let timeUnits = {};\n        timeUnits[unit] = num;\n\n        // Modifier\n        let modifier = match[1] || match[3] || \"\";\n        modifier = modifier.toLowerCase();\n        if (!modifier) {\n            return;\n        }\n\n        if (/vor/.test(modifier) || /letzte/.test(modifier) || /vergangen/.test(modifier)) {\n            timeUnits = reverseDuration(timeUnits);\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class DETimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:in|für|während)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for French support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport FRCasualDateParser from \"./parsers/FRCasualDateParser\";\nimport FRCasualTimeParser from \"./parsers/FRCasualTimeParser\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport FRTimeExpressionParser from \"./parsers/FRTimeExpressionParser\";\nimport FRMergeDateTimeRefiner from \"./refiners/FRMergeDateTimeRefiner\";\nimport FRMergeDateRangeRefiner from \"./refiners/FRMergeDateRangeRefiner\";\nimport FRWeekdayParser from \"./parsers/FRWeekdayParser\";\nimport FRSpecificTimeExpressionParser from \"./parsers/FRSpecificTimeExpressionParser\";\nimport FRMonthNameLittleEndianParser from \"./parsers/FRMonthNameLittleEndianParser\";\nimport FRTimeUnitAgoFormatParser from \"./parsers/FRTimeUnitAgoFormatParser\";\nimport FRTimeUnitWithinFormatParser from \"./parsers/FRTimeUnitWithinFormatParser\";\nimport FRTimeUnitRelativeFormatParser from \"./parsers/FRTimeUnitRelativeFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new FRCasualDateParser());\n    option.parsers.unshift(new FRCasualTimeParser());\n    option.parsers.unshift(new FRTimeUnitRelativeFormatParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new FRMonthNameLittleEndianParser(),\n                new FRTimeExpressionParser(),\n                new FRSpecificTimeExpressionParser(),\n                new FRTimeUnitAgoFormatParser(),\n                new FRTimeUnitWithinFormatParser(),\n                new FRWeekdayParser(),\n            ],\n            refiners: [new FRMergeDateTimeRefiner(), new FRMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dates\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class FRCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(maintenant|aujourd'hui|demain|hier|cette\\s*nuit|la\\s*veille)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const targetDate = context.refDate;\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"maintenant\":\n                return references.now(context.reference);\n\n            case \"aujourd'hui\":\n                return references.today(context.reference);\n\n            case \"hier\":\n                return references.yesterday(context.reference);\n\n            case \"demain\":\n                return references.tomorrow(context.reference);\n\n            default:\n                if (lowerText.match(/cette\\s*nuit/)) {\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 22);\n                    component.imply(\"meridiem\", Meridiem.PM);\n                } else if (lowerText.match(/la\\s*veille/)) {\n                    const previousDay = new Date(targetDate.getTime());\n                    previousDay.setDate(previousDay.getDate() - 1);\n                    assignSimilarDate(component, previousDay);\n                    component.imply(\"hour\", 0);\n                }\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class FRCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(cet?)?\\s*(matin|soir|après-midi|aprem|a midi|à minuit)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const suffixLower = match[2].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (suffixLower) {\n            case \"après-midi\":\n            case \"aprem\":\n                component.imply(\"hour\", 14);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"soir\":\n                component.imply(\"hour\", 18);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.PM);\n                break;\n\n            case \"matin\":\n                component.imply(\"hour\", 8);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"a midi\":\n                component.imply(\"hour\", 12);\n                component.imply(\"minute\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n\n            case \"à minuit\":\n                component.imply(\"hour\", 0);\n                component.imply(\"meridiem\", Meridiem.AM);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { ParsingComponents } from \"../../../results\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport default class FRTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:[àa])\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|[àa]|\\\\?)\\\\s*\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        // This looks more like a year e.g. 2020\n        if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n            return null;\n        }\n\n        return super.extractPrimaryTimeComponents(context, match);\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class FRMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|à|a|au|vers|de|,|-)?\\\\s*$\");\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class FRMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(à|a|au|-)\\s*$/i;\n    }\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { Timeunit } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"dimanche\": 0,\n    \"dim\": 0,\n    \"lundi\": 1,\n    \"lun\": 1,\n    \"mardi\": 2,\n    \"mar\": 2,\n    \"mercredi\": 3,\n    \"mer\": 3,\n    \"jeudi\": 4,\n    \"jeu\": 4,\n    \"vendredi\": 5,\n    \"ven\": 5,\n    \"samedi\": 6,\n    \"sam\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"janvier\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"février\": 2,\n    \"fév\": 2,\n    \"fév.\": 2,\n    \"fevrier\": 2,\n    \"fev\": 2,\n    \"fev.\": 2,\n    \"mars\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"avril\": 4,\n    \"avr\": 4,\n    \"avr.\": 4,\n    \"mai\": 5,\n    \"juin\": 6,\n    \"jun\": 6,\n    \"juillet\": 7,\n    \"juil\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"août\": 8,\n    \"aout\": 8,\n    \"septembre\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"sept\": 9,\n    \"sept.\": 9,\n    \"octobre\": 10,\n    \"oct\": 10,\n    \"oct.\": 10,\n    \"novembre\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"décembre\": 12,\n    \"decembre\": 12,\n    \"dec\": 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"un\": 1,\n    \"deux\": 2,\n    \"trois\": 3,\n    \"quatre\": 4,\n    \"cinq\": 5,\n    \"six\": 6,\n    \"sept\": 7,\n    \"huit\": 8,\n    \"neuf\": 9,\n    \"dix\": 10,\n    \"onze\": 11,\n    \"douze\": 12,\n    \"treize\": 13,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    \"sec\": \"second\",\n    \"seconde\": \"second\",\n    \"secondes\": \"second\",\n    \"min\": \"minute\",\n    \"mins\": \"minute\",\n    \"minute\": \"minute\",\n    \"minutes\": \"minute\",\n    \"h\": \"hour\",\n    \"hr\": \"hour\",\n    \"hrs\": \"hour\",\n    \"heure\": \"hour\",\n    \"heures\": \"hour\",\n    \"jour\": \"day\",\n    \"jours\": \"day\",\n    \"semaine\": \"week\",\n    \"semaines\": \"week\",\n    \"mois\": \"month\",\n    \"trimestre\": \"quarter\",\n    \"trimestres\": \"quarter\",\n    \"ans\": \"year\",\n    \"année\": \"year\",\n    \"années\": \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|une?\\\\b|quelques?|demi-?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"une\" || num === \"un\") {\n        return 1;\n    } else if (num.match(/quelques?/)) {\n        return 3;\n    } else if (num.match(/demi-?/)) {\n        return 0.5;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:[0-9]{1,2}(?:er)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    num = num.replace(/(?:er)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n// 88 p. Chr. n.\n// 234 AC\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s*(?:AC|AD|p\\\\.\\\\s*C(?:hr?)?\\\\.\\\\s*n\\\\.)|[1-2][0-9]{3}|[5-9][0-9])`;\nexport function parseYear(match: string): number {\n    if (/AC/i.test(match)) {\n        match = match.replace(/BC/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/AD/i.test(match) || /C/i.test(match)) {\n        match = match.replace(/[^\\d]+/i, \"\");\n        return parseInt(match);\n    }\n\n    let yearNumber = parseInt(match);\n    if (yearNumber < 100) {\n        if (yearNumber > 50) {\n            yearNumber = yearNumber + 1900;\n        } else {\n            yearNumber = yearNumber + 2000;\n        }\n    }\n\n    return yearNumber;\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\n\nimport { Duration } from \"../../calculation/duration\";\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:(?:ce)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(dernier|prochain)\\\\s*)?\" +\n        \"(?=\\\\W|\\\\d|$)\",\n    \"i\"\n);\n\nconst WEEKDAY_GROUP = 1;\nconst POSTFIX_GROUP = 2;\n\nexport default class FRWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        if (weekday === undefined) {\n            return null;\n        }\n\n        let suffix = match[POSTFIX_GROUP];\n        suffix = suffix || \"\";\n        suffix = suffix.toLowerCase();\n\n        let modifier = null;\n        if (suffix == \"dernier\") {\n            modifier = \"last\";\n        } else if (suffix == \"prochain\") {\n            modifier = \"next\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\n\n/**\n * 8h10m00s\n * 8h10m00\n * 8h10\n */\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(^|\\\\s|T)\" +\n        \"(?:(?:[àa])\\\\s*)?\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s|:)?)?\" +\n        \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"^\\\\s*(\\\\-|\\\\–|\\\\~|\\\\〜|[àa]|\\\\?)\\\\s*\" +\n        \"(\\\\d{1,2})(?:h|:)?\" +\n        \"(?:(\\\\d{1,2})(?:m|:)?)?\" +\n        \"(?:(\\\\d{1,2})(?:s|:)?)?\" +\n        \"(?:\\\\s*(A\\\\.M\\\\.|P\\\\.M\\\\.|AM?|PM?))?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP = 5;\n\nexport default class FRSpecificTimeExpressionParser implements Parser {\n    pattern(context): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingResult | null {\n        const result = context.createParsingResult(match.index + match[1].length, match[0].substring(match[1].length));\n\n        // This looks more like a year e.g. 2020\n        if (result.text.match(/^\\d{4}$/)) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        result.start = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), match);\n        if (!result.start) {\n            match.index += match[0].length;\n            return null;\n        }\n\n        const remainingText = context.text.substring(match.index + match[0].length);\n        const secondMatch = SECOND_REG_PATTERN.exec(remainingText);\n        if (secondMatch) {\n            result.end = FRSpecificTimeExpressionParser.extractTimeComponent(result.start.clone(), secondMatch);\n            if (result.end) {\n                result.text += secondMatch[0];\n            }\n        }\n\n        return result;\n    }\n\n    private static extractTimeComponent(\n        extractingComponents: ParsingComponents,\n        match: RegExpMatchArray\n    ): ParsingComponents | null {\n        let hour = 0;\n        let minute = 0;\n        let meridiem = null;\n\n        // ----- Hours\n        hour = parseInt(match[HOUR_GROUP]);\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP] != null) {\n            minute = parseInt(match[MINUTE_GROUP]);\n        }\n\n        if (minute >= 60 || hour > 24) {\n            return null;\n        }\n\n        if (hour >= 12) {\n            meridiem = Meridiem.PM;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP] != null) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = Meridiem.AM;\n                if (hour == 12) {\n                    hour = 0;\n                }\n            }\n\n            if (ampm == \"p\") {\n                meridiem = Meridiem.PM;\n                if (hour != 12) {\n                    hour += 12;\n                }\n            }\n        }\n\n        extractingComponents.assign(\"hour\", hour);\n        extractingComponents.assign(\"minute\", minute);\n        if (meridiem !== null) {\n            extractingComponents.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                extractingComponents.imply(\"meridiem\", Meridiem.AM);\n            } else {\n                extractingComponents.imply(\"meridiem\", Meridiem.PM);\n            }\n        }\n\n        // ----- Second\n        if (match[SECOND_GROUP] != null) {\n            const second = parseInt(match[SECOND_GROUP]);\n            if (second >= 60) return null;\n\n            extractingComponents.assign(\"second\", second);\n        }\n\n        return extractingComponents;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:on\\\\s*?)?\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:\\\\s*(?:au|\\\\-|\\\\–|jusqu'au?|\\\\s)\\\\s*(${ORDINAL_NUMBER_PATTERN}))?` +\n        `(?:-|/|\\\\s*(?:de)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:(?:-|/|,?\\\\s*)(${YEAR_PATTERN}(?![^\\\\s]\\\\d)))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class FRMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        //console.log(match)\n\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class FRTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(`il y a\\\\s*(${TIME_UNITS_PATTERN})(?=(?:\\\\W|$))`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseDuration(match[1]);\n        const outputTimeUnits = reverseDuration(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class FRTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:dans|en|pour|pendant|de)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { NUMBER_PATTERN, parseNumberPattern, TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class FRTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor() {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return new RegExp(\n            `(?:les?|la|l'|du|des?)\\\\s*` +\n                `(${NUMBER_PATTERN})?` +\n                `(?:\\\\s*(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?))?` +\n                `\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})` +\n                `(?:\\\\s*(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?))?`,\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const num = match[1] ? parseNumberPattern(match[1]) : 1;\n        const unit = TIME_UNIT_DICTIONARY[match[3].toLowerCase()];\n        let timeUnits = {};\n        timeUnits[unit] = num;\n\n        // Modifier\n        let modifier = match[2] || match[4] || \"\";\n        modifier = modifier.toLowerCase();\n        if (!modifier) {\n            return;\n        }\n\n        if (/derni[eè]re?s?/.test(modifier) || /pass[ée]e?s?/.test(modifier) || /pr[ée]c[ée]dents?/.test(modifier)) {\n            timeUnits = reverseDuration(timeUnits);\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Japanese support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport JPStandardParser from \"./parsers/JPStandardParser\";\nimport JPMergeDateRangeRefiner from \"./refiners/JPMergeDateRangeRefiner\";\nimport JPCasualDateParser from \"./parsers/JPCasualDateParser\";\nimport JPWeekdayParser from \"./parsers/JPWeekdayParser\";\nimport JPSlashDateFormatParser from \"./parsers/JPSlashDateFormatParser\";\nimport JPTimeExpressionParser from \"./parsers/JPTimeExpressionParser\";\nimport JPMergeDateTimeRefiner from \"./refiners/JPMergeDateTimeRefiner\";\n\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport JPMergeWeekdayComponentRefiner from \"./refiners/JPMergeWeekdayComponentRefiner\";\nimport JPWeekdayWithParenthesesParser from \"./parsers/JPWeekdayWithParenthesesParser\";\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport MergeWeekdayComponentRefiner from \"../../common/refiners/MergeWeekdayComponentRefiner\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration(false);\n    option.parsers.unshift(new JPCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true): Configuration {\n    const configuration = includeCommonConfiguration(\n        {\n            parsers: [\n                new JPStandardParser(),\n                new JPWeekdayParser(),\n                new JPWeekdayWithParenthesesParser(),\n                new JPSlashDateFormatParser(),\n                new JPTimeExpressionParser(),\n            ],\n            refiners: [\n                new JPMergeWeekdayComponentRefiner(), // Note: should be before JPMergeDateTimeRefiner and JPMergeDateRangeRefiner\n                new JPMergeDateTimeRefiner(),\n                new JPMergeDateRangeRefiner(),\n            ],\n        },\n        strictMode\n    );\n\n    // Note: Remove because it is not used in Japanese grammar\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof MergeWeekdayComponentRefiner)\n    );\n\n    return configuration;\n}\n", "export const NUMBER = {\n    \"零\": 0,\n    \"〇\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n    \"七\": 7,\n    \"八\": 8,\n    \"九\": 9,\n    \"十\": 10,\n};\n\nexport const WEEKDAY_OFFSET = {\n    \"日\": 0,\n    \"月\": 1,\n    \"火\": 2,\n    \"水\": 3,\n    \"木\": 4,\n    \"金\": 5,\n    \"土\": 6,\n};\n\n/**\n * to-hankaku.js\n * convert to ascii code strings.\n *\n * @version 1.0.1\n * @author think49\n * @url https://gist.github.com/964592\n * @license http://www.opensource.org/licenses/mit-license.php (The MIT License)\n */\nexport function toHankaku(text) {\n    return String(text)\n        .replace(/\\u2019/g, \"\\u0027\")\n        .replace(/\\u201D/g, \"\\u0022\")\n        .replace(/\\u3000/g, \"\\u0020\")\n        .replace(/\\uFFE5/g, \"\\u00A5\")\n        .replace(\n            /[\\uFF01\\uFF03-\\uFF06\\uFF08\\uFF09\\uFF0C-\\uFF19\\uFF1C-\\uFF1F\\uFF21-\\uFF3B\\uFF3D\\uFF3F\\uFF41-\\uFF5B\\uFF5D\\uFF5E]/g,\n            alphaNum\n        );\n}\n\nfunction alphaNum(token) {\n    return String.fromCharCode(token.charCodeAt(0) - 65248);\n}\n\nexport function jaStringToNumber(text: string) {\n    let number = 0;\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === \"十\") {\n            number = number === 0 ? NUMBER[char] : number * NUMBER[char];\n        } else {\n            number += NUMBER[char];\n        }\n    }\n\n    return number;\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { toHankaku } from \"../constants\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\n\nconst PATTERN =\n    /(?:(?:([同今本])|((昭和|平成|令和)?([0-9０-９]{1,4}|元)))年\\s*)?([0-9０-９]{1,2})月\\s*([0-9０-９]{1,2})日/i;\nconst SPECIAL_YEAR_GROUP = 1;\nconst TYPICAL_YEAR_GROUP = 2;\nconst ERA_GROUP = 3;\nconst YEAR_NUMBER_GROUP = 4;\nconst MONTH_GROUP = 5;\nconst DAY_GROUP = 6;\n\nexport default class JPStandardParser implements Parser {\n    pattern() {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = parseInt(toHankaku(match[MONTH_GROUP]));\n        const day = parseInt(toHankaku(match[DAY_GROUP]));\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[SPECIAL_YEAR_GROUP] && match[SPECIAL_YEAR_GROUP].match(\"同|今|本\")) {\n            components.assign(\"year\", context.reference.getDateWithAdjustedTimezone().getFullYear());\n        }\n\n        if (match[TYPICAL_YEAR_GROUP]) {\n            const yearNumText = match[YEAR_NUMBER_GROUP];\n\n            let year = yearNumText == \"元\" ? 1 : parseInt(toHankaku(yearNumText));\n            if (match[ERA_GROUP] == \"令和\") {\n                year += 2018;\n            } else if (match[ERA_GROUP] == \"平成\") {\n                year += 1988;\n            } else if (match[ERA_GROUP] == \"昭和\") {\n                year += 1925;\n            }\n\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        return components;\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Japanese connecting phases\n * - 2月11日[ー]2月13日\n * - 水曜日[から]日曜日\n */\nexport default class JPMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(から|－|ー|-|～|~)\\s*$/i;\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /今日|きょう|本日|ほんじつ|昨日|きのう|明日|あした|今夜|こんや|今夕|こんゆう|今晩|こんばん|今朝|けさ/i;\n\nfunction normalizeTextToKanji(text: string) {\n    switch (text) {\n        case \"きょう\":\n            return \"今日\";\n        case \"ほんじつ\":\n            return \"本日\";\n        case \"きのう\":\n            return \"昨日\";\n        case \"あした\":\n            return \"明日\";\n        case \"こんや\":\n            return \"今夜\";\n        case \"こんゆう\":\n            return \"今夕\";\n        case \"こんばん\":\n            return \"今晩\";\n        case \"けさ\":\n            return \"今朝\";\n        default:\n            return text;\n    }\n}\n\nexport default class JPCasualDateParser implements Parser {\n    pattern() {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray) {\n        const text = normalizeTextToKanji(match[0]);\n\n        const components = context.createParsingComponents();\n\n        switch (text) {\n            case \"昨日\":\n                return references.yesterday(context.reference);\n\n            case \"明日\":\n                return references.tomorrow(context.reference);\n\n            case \"本日\":\n            case \"今日\":\n                return references.today(context.reference);\n        }\n\n        if (text == \"今夜\" || text == \"今夕\" || text == \"今晩\") {\n            components.imply(\"hour\", 22);\n            components.assign(\"meridiem\", Meridiem.PM);\n        } else if (text.match(\"今朝\")) {\n            components.imply(\"hour\", 6);\n            components.assign(\"meridiem\", Meridiem.AM);\n        }\n\n        const date = context.refDate;\n        components.assign(\"day\", date.getDate());\n        components.assign(\"month\", date.getMonth() + 1);\n        components.assign(\"year\", date.getFullYear());\n        return components;\n    }\n}\n", "import { ParsingContext, Parser } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"((?<prefix>前の|次の|今週))?(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")(?:曜日|曜)\",\n    \"i\"\n);\n\nexport default class JPWeekdayParser implements Parser {\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        const prefix = match.groups.prefix || \"\";\n\n        let modifier = null;\n        if (prefix.match(/前の/)) {\n            modifier = \"last\";\n        } else if (prefix.match(/次の/)) {\n            modifier = \"next\";\n        } else if (prefix.match(/今週/)) {\n            modifier = \"this\";\n        }\n        // TODO: handle 先週, 来週. They are different from last and next.\n\n        return createParsingComponentsAtWeekday(context.reference, offset, modifier);\n    }\n}\n", "import { Parser, ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { findMostLikelyADYear, findYearClosestToRef } from \"../../../calculation/years\";\nimport { toHankaku } from \"../constants\";\n\n/**\n * Date format with slash \"/\" between numbers. YYYY/MM/DD or MM/DD\n * Big-endian slash format is used in Japan.\n * For examples:\n * - 7/31\n * - 2020/7/12\n */\nconst PATTERN = new RegExp(\n    \"([0-9０-９]{4}[\\\\/|\\\\／])?\" + \"([0-1０-１]{0,1}[0-9０-９]{1})(?:[\\\\/|\\\\／]([0-3０-３]{0,1}[0-9０-９]{1}))\",\n    \"i\"\n);\n\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\n\nexport default class JPSlashDateFormatParser implements Parser {\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const result = context.createParsingComponents();\n        const month = parseInt(toHankaku(match[MONTH_GROUP]));\n        const day = parseInt(toHankaku(match[DAY_GROUP]));\n        if (month < 1 || month > 12) {\n            return null;\n        }\n\n        if (day < 1 || day > 31) {\n            return null;\n        }\n\n        result.assign(\"day\", day);\n        result.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const rawYearNumber = parseInt(toHankaku(match[YEAR_GROUP]));\n            const year = findMostLikelyADYear(rawYearNumber);\n            result.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.reference.instant, day, month);\n            result.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { Meridiem, ParsedComponents } from \"../../../types\";\nimport { NUMBER, jaStringToNumber, toHankaku } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\n\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(?:\" +\n        \"(午前|午後|A.M.|P.M.|AM|PM)\" +\n        \")?\" +\n        \"(?:[\\\\s,，、]*)\" +\n        \"(?:([0-9０-９]+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:時(?!間)|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"([0-9０-９]+|半|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"([0-9０-９]+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"(?:^\\\\s*(?:から|\\\\-|\\\\–|\\\\－|\\\\~|\\\\〜)\\\\s*)\" +\n        \"(?:\" +\n        \"(午前|午後|A.M.|P.M.|AM|PM)\" +\n        \")?\" +\n        \"(?:[\\\\s,，、]*)\" +\n        \"(?:([0-9０-９]+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:時|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"([0-9０-９]+|半|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"([0-9０-９]+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst AM_PM_HOUR_GROUP_1 = 1;\nconst HOUR_GROUP = 2;\nconst MINUTE_GROUP = 3;\nconst SECOND_GROUP = 4;\nconst AM_PM_HOUR_GROUP_2 = 5;\n\nexport default class JPTimeExpressionParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // This pattern can be overlapped Ex. [12] AM, 1[2] AM\n        if (match.index > 0 && context.text[match.index - 1].match(/\\w/)) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = createTimeComponents(\n            context,\n            match[HOUR_GROUP],\n            match[MINUTE_GROUP],\n            match[SECOND_GROUP],\n            match[AM_PM_HOUR_GROUP_1] ?? match[AM_PM_HOUR_GROUP_2]\n        );\n        if (!result.start) {\n            match.index += match[0].length; // Skip over potential overlapping pattern\n            return null;\n        }\n\n        // =============================================================================================\n        //                  Extracting the 'to' chunk\n        // =============================================================================================\n\n        match = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));\n        if (!match) {\n            return result;\n        }\n\n        result.text = result.text + match[0];\n        result.end = createTimeComponents(\n            context,\n            match[HOUR_GROUP],\n            match[MINUTE_GROUP],\n            match[SECOND_GROUP],\n            match[AM_PM_HOUR_GROUP_1] ?? match[AM_PM_HOUR_GROUP_2]\n        );\n        if (!result.end) {\n            return null;\n        }\n        if (!result.end.isCertain(\"meridiem\") && result.start.isCertain(\"meridiem\")) {\n            result.end.imply(\"meridiem\", result.start.get(\"meridiem\"));\n            if (result.start.get(\"meridiem\") === Meridiem.PM) {\n                if (result.start.get(\"hour\") - 12 > result.end.get(\"hour\")) {\n                    // 10pm - 1 (am)\n                    result.end.imply(\"meridiem\", Meridiem.AM);\n                } else if (result.end.get(\"hour\") < 12) {\n                    result.end.assign(\"hour\", result.end.get(\"hour\") + 12);\n                }\n            }\n        }\n        if (result.end.date().getTime() < result.start.date().getTime()) {\n            result.end.imply(\"day\", result.end.get(\"day\") + 1);\n        }\n        return result;\n    }\n}\n\nfunction createTimeComponents(\n    context: ParsingContext,\n    matchHour: string | null,\n    matchMinute: string | null,\n    matchSecond: string | null,\n    matchAmPm: string | null\n): ParsingComponents | null {\n    let hour = 0;\n    let meridiem = -1;\n    let targetComponents = context.createParsingComponents();\n    hour = parseInt(toHankaku(matchHour));\n    if (isNaN(hour)) {\n        hour = jaStringToNumber(matchHour);\n    }\n    if (hour > 24) {\n        return null;\n    }\n\n    if (matchMinute) {\n        let minute: number;\n        if (matchMinute === \"半\") {\n            minute = 30;\n        } else {\n            minute = parseInt(toHankaku(matchMinute));\n            if (isNaN(minute)) {\n                minute = jaStringToNumber(matchMinute);\n            }\n        }\n        if (minute >= 60) return null;\n        targetComponents.assign(\"minute\", minute);\n    }\n    if (matchSecond) {\n        let second = parseInt(toHankaku(matchSecond));\n        if (isNaN(second)) {\n            second = jaStringToNumber(matchSecond);\n        }\n        if (second >= 60) return null;\n        targetComponents.assign(\"second\", second);\n    }\n\n    if (matchAmPm) {\n        if (hour > 12) {\n            return null;\n        }\n        const AMPMString = matchAmPm;\n        if (AMPMString === \"午前\" || AMPMString[0].toLowerCase() === \"a\") {\n            meridiem = Meridiem.AM;\n            if (hour === 12) hour = 0;\n        } else if (AMPMString === \"午後\" || AMPMString[0].toLowerCase() === \"p\") {\n            meridiem = Meridiem.PM;\n            if (hour != 12) hour += 12;\n        }\n    }\n\n    targetComponents.assign(\"hour\", hour);\n\n    if (meridiem >= 0) {\n        targetComponents.assign(\"meridiem\", meridiem);\n    } else {\n        if (hour < 12) {\n            targetComponents.imply(\"meridiem\", Meridiem.AM);\n        } else {\n            targetComponents.imply(\"meridiem\", Meridiem.PM);\n        }\n    }\n    return targetComponents;\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\nexport default class JPMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(の)?\\s*$/i;\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingResult } from \"../../../results\";\n\n/**\n * Merge weekday component into more completed data\n * - [2014/7/12], [(土)] => [2014/7/12 (土)]\n * - [7月12日], [土曜日] => [7月12日 土曜日]\n * The difference between the original MergeWeekdayComponentRefiner and the JP one is the order of date and weekday.\n */\nexport default class JPMergeWeekdayComponentRefiner extends MergingRefiner {\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        const newResult = currentResult.clone();\n        newResult.text = currentResult.text + textBetween + nextResult.text;\n\n        newResult.start.assign(\"weekday\", nextResult.start.get(\"weekday\"));\n        if (newResult.end) {\n            newResult.end.assign(\"weekday\", nextResult.start.get(\"weekday\"));\n        }\n\n        return newResult;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        const normalDateThenWeekday =\n            currentResult.start.isCertain(\"day\") &&\n            nextResult.start.isOnlyWeekdayComponent() &&\n            !nextResult.start.isCertain(\"hour\");\n        return normalDateThenWeekday && textBetween.match(/^[,、の]?\\s*$/) !== null;\n    }\n}\n", "import { ParsingContext, Parser } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\"(?:\\\\(|\\\\（)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")(?:\\\\)|\\\\）)\", \"i\");\n\n/**\n * Weekday with parentheses in Japanese\n * For examples:\n * - (水)\n * - （土）\n */\nexport default class JPWeekdayWithParenthesesParser implements Parser {\n    pattern(): RegExp {\n        return PATTERN;\n    }\n\n    extract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n        return createParsingComponentsAtWeekday(context.reference, offset);\n    }\n}\n", "/**\n * Chrono components for Portuguese support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport PTWeekdayParser from \"./parsers/PTWeekdayParser\";\nimport PTTimeExpressionParser from \"./parsers/PTTimeExpressionParser\";\nimport PTMergeDateTimeRefiner from \"./refiners/PTMergeDateTimeRefiner\";\nimport PTMergeDateRangeRefiner from \"./refiners/PTMergeDateRangeRefiner\";\nimport PTMonthNameLittleEndianParser from \"./parsers/PTMonthNameLittleEndianParser\";\nimport PTCasualDateParser from \"./parsers/PTCasualDateParser\";\nimport PTCasualTimeParser from \"./parsers/PTCasualTimeParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.push(new PTCasualDateParser());\n    option.parsers.push(new PTCasualTimeParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new PTWeekdayParser(),\n                new PTTimeExpressionParser(),\n                new PTMonthNameLittleEndianParser(),\n            ],\n            refiners: [new PTMergeDateTimeRefiner(), new PTMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "export const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"domingo\": 0,\n    \"dom\": 0,\n    \"segunda\": 1,\n    \"segunda-feira\": 1,\n    \"seg\": 1,\n    \"terça\": 2,\n    \"terça-feira\": 2,\n    \"ter\": 2,\n    \"quarta\": 3,\n    \"quarta-feira\": 3,\n    \"qua\": 3,\n    \"quinta\": 4,\n    \"quinta-feira\": 4,\n    \"qui\": 4,\n    \"sexta\": 5,\n    \"sexta-feira\": 5,\n    \"sex\": 5,\n    \"sábado\": 6,\n    \"sabado\": 6,\n    \"sab\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"janeiro\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"fevereiro\": 2,\n    \"fev\": 2,\n    \"fev.\": 2,\n    \"março\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"abril\": 4,\n    \"abr\": 4,\n    \"abr.\": 4,\n    \"maio\": 5,\n    \"mai\": 5,\n    \"mai.\": 5,\n    \"junho\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"julho\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"agosto\": 8,\n    \"ago\": 8,\n    \"ago.\": 8,\n    \"setembro\": 9,\n    \"set\": 9,\n    \"set.\": 9,\n    \"outubro\": 10,\n    \"out\": 10,\n    \"out.\": 10,\n    \"novembro\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"dezembro\": 12,\n    \"dez\": 12,\n    \"dez.\": 12,\n};\n\n//-----------------------------\n// 88 p. Chr. n.\n// 234 AC\nexport const YEAR_PATTERN = \"[0-9]{1,4}(?![^\\\\s]\\\\d)(?:\\\\s*[a|d]\\\\.?\\\\s*c\\\\.?|\\\\s*a\\\\.?\\\\s*d\\\\.?)?\";\nexport function parseYear(match: string): number {\n    if (match.match(/^[0-9]{1,4}$/)) {\n        let yearNumber = parseInt(match);\n        if (yearNumber < 100) {\n            if (yearNumber > 50) {\n                yearNumber = yearNumber + 1900;\n            } else {\n                yearNumber = yearNumber + 2000;\n            }\n        }\n        return yearNumber;\n    }\n\n    if (match.match(/a\\.?\\s*c\\.?/i)) {\n        match = match.replace(/a\\.?\\s*c\\.?/i, \"\");\n        return -parseInt(match);\n    }\n\n    return parseInt(match);\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:(este|esta|passado|pr[oó]ximo)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(este|esta|passado|pr[óo]ximo)\\\\s*semana)?\" +\n        \"(?=\\\\W|\\\\d|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class PTWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        if (weekday === undefined) {\n            return null;\n        }\n\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let norm = prefix || postfix || \"\";\n        norm = norm.toLowerCase();\n\n        let modifier = null;\n        if (norm == \"passado\") {\n            modifier = \"this\";\n        } else if (norm == \"próximo\" || norm == \"proximo\") {\n            modifier = \"next\";\n        } else if (norm == \"este\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class PTTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:ao?|às?|das|da|de|do)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|a(?:o)?|\\\\?)\\\\s*\";\n    }\n\n    // extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n    //     // This looks more like a year e.g. 2020\n    //     // if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n    //     //     return null;\n    //     // }\n    //\n    //     return super.extractPrimaryTimeComponents(context, match);\n    // }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class PTMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(?:,|à)?\\\\s*$\");\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class PTMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(?:-)\\s*$/i;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `([0-9]{1,2})(?:º|ª|°)?` +\n        \"(?:\\\\s*(?:desde|de|\\\\-|\\\\–|ao?|\\\\s)\\\\s*([0-9]{1,2})(?:º|ª|°)?)?\\\\s*(?:de)?\\\\s*\" +\n        `(?:-|/|\\\\s*(?:de|,)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:\\\\s*(?:de|,)?\\\\s*(${YEAR_PATTERN}))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class PTMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class PTCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(agora|hoje|amanha|amanhã|ontem)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"agora\":\n                return references.now(context.reference);\n\n            case \"hoje\":\n                return references.today(context.reference);\n\n            case \"amanha\":\n            case \"amanhã\":\n                return references.tomorrow(context.reference);\n\n            case \"ontem\":\n                return references.yesterday(context.reference);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\n\nexport default class PTCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return /(?:esta\\s*)?(manha|manhã|tarde|meia-noite|meio-dia|noite)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = context.refDate;\n        const component = context.createParsingComponents();\n        switch (match[1].toLowerCase()) {\n            case \"tarde\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"noite\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 22);\n                break;\n\n            case \"manha\":\n            case \"manhã\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"meia-noite\":\n                const nextDay = new Date(targetDate.getTime());\n                nextDay.setDate(nextDay.getDate() + 1);\n                assignSimilarDate(component, nextDay);\n                implySimilarTime(component, nextDay);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"meio-dia\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "/**\n * Chrono components for Dutch support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport NLMergeDateRangeRefiner from \"./refiners/NLMergeDateRangeRefiner\";\nimport NLMergeDateTimeRefiner from \"./refiners/NLMergeDateTimeRefiner\";\nimport NLCasualDateParser from \"./parsers/NLCasualDateParser\";\nimport NLCasualTimeParser from \"./parsers/NLCasualTimeParser\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport NLTimeUnitWithinFormatParser from \"./parsers/NLTimeUnitWithinFormatParser\";\nimport NLWeekdayParser from \"./parsers/NLWeekdayParser\";\nimport NLMonthNameMiddleEndianParser from \"./parsers/NLMonthNameMiddleEndianParser\";\nimport NLMonthNameParser from \"./parsers/NLMonthNameParser\";\nimport NLSlashMonthFormatParser from \"./parsers/NLSlashMonthFormatParser\";\nimport NLTimeExpressionParser from \"./parsers/NLTimeExpressionParser\";\nimport NLCasualYearMonthDayParser from \"./parsers/NLCasualYearMonthDayParser\";\nimport NLCasualDateTimeParser from \"./parsers/NLCasualDateTimeParser\";\nimport NLTimeUnitCasualRelativeFormatParser from \"./parsers/NLTimeUnitCasualRelativeFormatParser\";\nimport NLRelativeDateFormatParser from \"./parsers/NLRelativeDateFormatParser\";\nimport NLTimeUnitAgoFormatParser from \"./parsers/NLTimeUnitAgoFormatParser\";\nimport NLTimeUnitLaterFormatParser from \"./parsers/NLTimeUnitLaterFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new NLCasualDateParser());\n    option.parsers.unshift(new NLCasualTimeParser());\n    option.parsers.unshift(new NLCasualDateTimeParser());\n    option.parsers.unshift(new NLMonthNameParser());\n    option.parsers.unshift(new NLRelativeDateFormatParser());\n    option.parsers.unshift(new NLTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new NLTimeUnitWithinFormatParser(),\n                new NLMonthNameMiddleEndianParser(),\n                new NLMonthNameParser(),\n                new NLWeekdayParser(),\n                new NLCasualYearMonthDayParser(),\n                new NLSlashMonthFormatParser(),\n                new NLTimeExpressionParser(strictMode),\n                new NLTimeUnitAgoFormatParser(strictMode),\n                new NLTimeUnitLaterFormatParser(strictMode),\n            ],\n            refiners: [new NLMergeDateTimeRefiner(), new NLMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "/*\n\n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Dutch connecting phases\n * - 2020-02-13 [tot] 2020-02-13\n * - Wednesday [-] Friday\n */\nexport default class NLMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(tot|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide Dutch connecting phases\n * - 2020-02-13 [at] 6pm\n * - Tomorrow [after] 7am\n */\nexport default class NLMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(om|na|voor|in de|,|-)?\\\\s*$\");\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class NLCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(nu|vandaag|morgen|morgend|gisteren)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"nu\":\n                return references.now(context.reference);\n\n            case \"vandaag\":\n                return references.today(context.reference);\n\n            case \"morgen\":\n            case \"morgend\":\n                return references.tomorrow(context.reference);\n\n            case \"gisteren\":\n                return references.yesterday(context.reference);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\n\nconst DAY_GROUP = 1;\nconst MOMENT_GROUP = 2;\n\nexport default class NLCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return /(deze)?\\s*(namiddag|avond|middernacht|ochtend|middag|'s middags|'s avonds|'s ochtends)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = context.refDate;\n        const component = context.createParsingComponents();\n\n        if (match[DAY_GROUP] === \"deze\") {\n            component.assign(\"day\", context.refDate.getDate());\n            component.assign(\"month\", context.refDate.getMonth() + 1);\n            component.assign(\"year\", context.refDate.getFullYear());\n        }\n\n        switch (match[MOMENT_GROUP].toLowerCase()) {\n            case \"namiddag\":\n            case \"'s namiddags\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"avond\":\n            case \"'s avonds'\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 20);\n                break;\n\n            case \"middernacht\":\n                const nextDay = new Date(targetDate.getTime());\n                nextDay.setDate(nextDay.getDate() + 1);\n                assignSimilarDate(component, nextDay);\n                implySimilarTime(component, nextDay);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"ochtend\":\n            case \"'s ochtends\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"middag\":\n            case \"'s middags\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    // Zondag\n    zondag: 0,\n    zon: 0,\n    \"zon.\": 0,\n    zo: 0,\n    \"zo.\": 0,\n    // Maandag\n    maandag: 1,\n    ma: 1,\n    \"ma.\": 1,\n    // Dinsdag\n    dinsdag: 2,\n    din: 2,\n    \"din.\": 2,\n    di: 2,\n    \"di.\": 2,\n    // Woensdag\n    woensdag: 3,\n    woe: 3,\n    \"woe.\": 3,\n    wo: 3,\n    \"wo.\": 3,\n    // Donderdag\n    donderdag: 4,\n    dond: 4,\n    \"dond.\": 4,\n    do: 4,\n    \"do.\": 4,\n    // Vrijdag\n    vrijdag: 5,\n    vrij: 5,\n    \"vrij.\": 5,\n    vr: 5,\n    \"vr.\": 5,\n    // Zaterdag\n    zaterdag: 6,\n    zat: 6,\n    \"zat.\": 6,\n    \"za\": 6,\n    \"za.\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    januari: 1,\n    jan: 1,\n    \"jan.\": 1,\n    februari: 2,\n    feb: 2,\n    \"feb.\": 2,\n    maart: 3,\n    mar: 3,\n    \"mar.\": 3,\n    mrt: 3,\n    \"mrt.\": 3,\n    april: 4,\n    apr: 4,\n    \"apr.\": 4,\n    mei: 5,\n    juni: 6,\n    jun: 6,\n    \"jun.\": 6,\n    juli: 7,\n    jul: 7,\n    \"jul.\": 7,\n    augustus: 8,\n    aug: 8,\n    \"aug.\": 8,\n    september: 9,\n    sep: 9,\n    \"sep.\": 9,\n    sept: 9,\n    \"sept.\": 9,\n    oktober: 10,\n    okt: 10,\n    \"okt.\": 10,\n    november: 11,\n    nov: 11,\n    \"nov.\": 11,\n    december: 12,\n    dec: 12,\n    \"dec.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    een: 1,\n    twee: 2,\n    drie: 3,\n    vier: 4,\n    vijf: 5,\n    zes: 6,\n    zeven: 7,\n    acht: 8,\n    negen: 9,\n    tien: 10,\n    elf: 11,\n    twaalf: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    eerste: 1,\n    tweede: 2,\n    derde: 3,\n    vierde: 4,\n    vijfde: 5,\n    zesde: 6,\n    zevende: 7,\n    achtste: 8,\n    negende: 9,\n    tiende: 10,\n    elfde: 11,\n    twaalfde: 12,\n    dertiende: 13,\n    veertiende: 14,\n    vijftiende: 15,\n    zestiende: 16,\n    zeventiende: 17,\n    achttiende: 18,\n    negentiende: 19,\n    twintigste: 20,\n    \"eenentwintigste\": 21,\n    \"tweeëntwintigste\": 22,\n    \"drieentwintigste\": 23,\n    \"vierentwintigste\": 24,\n    \"vijfentwintigste\": 25,\n    \"zesentwintigste\": 26,\n    \"zevenentwintigste\": 27,\n    \"achtentwintig\": 28,\n    \"negenentwintig\": 29,\n    \"dertigste\": 30,\n    \"eenendertigste\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    sec: \"second\",\n    second: \"second\",\n    seconden: \"second\",\n    min: \"minute\",\n    mins: \"minute\",\n    minute: \"minute\",\n    minuut: \"minute\",\n    minuten: \"minute\",\n    minuutje: \"minute\",\n    h: \"hour\",\n    hr: \"hour\",\n    hrs: \"hour\",\n    uur: \"hour\",\n    u: \"hour\",\n    uren: \"hour\",\n    dag: \"day\",\n    dagen: \"day\",\n    week: \"week\",\n    weken: \"week\",\n    maand: \"month\",\n    maanden: \"month\",\n    jaar: \"year\",\n    jr: \"year\",\n    jaren: \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+[\\\\.,][0-9]+|halve?|half|paar)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"paar\") {\n        return 2;\n    } else if (num === \"half\" || num.match(/halve?/)) {\n        return 0.5;\n    }\n    // Replace \",\" with \".\" to support some European languages\n    return parseFloat(num.replace(\",\", \".\"));\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:ste|de)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n    num = num.replace(/(?:ste|de)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s*(?:voor Christus|na Christus)|[1-2][0-9]{3}|[5-9][0-9])`;\nexport function parseYear(match: string): number {\n    if (/voor Christus/i.test(match)) {\n        // Before Christ\n        match = match.replace(/voor Christus/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/na Christus/i.test(match)) {\n        match = match.replace(/na Christus/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:binnen|in)\\\\s*)?`, SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class NLTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:binnen|in|binnen de|voor)\\\\s*` + \"(\" + TIME_UNITS_PATTERN + \")\" + `(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../../nl/constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:op\\\\s*?)?\" +\n        \"(?:(deze|vorige|volgende)\\\\s*(?:week\\\\s*)?)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class NLWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"vorige\") {\n            modifier = \"last\";\n        } else if (modifierWord == \"volgende\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"deze\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:on\\\\s*?)?\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        \"(?:\\\\s*\" +\n        \"(?:tot|\\\\-|\\\\–|until|through|till|\\\\s)\\\\s*\" +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        \"(?:-|/|\\\\s*(?:of)?\\\\s*)\" +\n        \"(\" +\n        matchAnyPattern(MONTH_DICTIONARY) +\n        \")\" +\n        \"(?:\" +\n        \"(?:-|/|,?\\\\s*)\" +\n        `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 3;\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing BE/NL date format with month's name in full writing\n *  - 1 januari 2019\n *  - 01 januari 2019\n *  - 10 januari 2019\n *  - 13 januari\n *  - 10 - 25 maart\n *  - 10 - 25 maart 2019\n *  - 1 aug 2019\n *  - 1 september 200 voor Christus\n *  - 1 september 2002 na Christus\n *  - 19 januari 87\n *  - 12de juli 2013\n *  - 1ste november 2013\n */\nexport default class NLMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n", "import { MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * The parser for parsing month name and year.\n * - januari, 2012\n * - januari 2012\n * - januari\n */\nexport default class NLMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const components = context.createParsingComponents();\n        components.imply(\"day\", 1);\n\n        const monthName = match[MONTH_NAME_GROUP];\n        const month = MONTH_DICTIONARY[monthName.toLowerCase()];\n        components.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            components.imply(\"year\", year);\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\"([0-9]|0[1-9]|1[012])/([0-9]{4})\" + \"\", \"i\");\n\nconst MONTH_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * Month/Year date format with slash \"/\" (also \"-\" and \".\") between numbers\n * - 11/05\n * - 06/2005\n */\nexport default class NLSlashMonthFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const year = parseInt(match[YEAR_GROUP]);\n        const month = parseInt(match[MONTH_GROUP]);\n\n        return context.createParsingComponents().imply(\"day\", 1).assign(\"month\", month).assign(\"year\", year);\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { ParsingComponents } from \"../../../results\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport default class NLTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:om)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|om|\\\\?)\\\\s*\";\n    }\n\n    primarySuffix(): string {\n        return \"(?:\\\\s*(?:uur))?(?!/)(?=\\\\W|$)\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n        // This looks more like a year e.g. 2020\n        if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n            return null;\n        }\n\n        return super.extractPrimaryTimeComponents(context, match);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class NLCasualYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            return null;\n        }\n\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        const day = parseInt(match[DATE_NUMBER_GROUP]);\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { Meridiem } from \"../../../types\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\n\n/*\n * Find combined words\n * - morgenochtend\n * - morgenmiddag\n * - morgennamiddag\n * - morgenavond\n * - morgennacht\n * - vanochtend\n * - vanmiddag\n * - vannamiddag\n * - vanavond\n * - vannacht\n * - gisterenochtend\n * - gisterenmiddag\n * - gisterennamiddag\n * - gisterenavond\n * - gisterennacht\n * */\n\nconst DATE_GROUP = 1;\nconst TIME_OF_DAY_GROUP = 2;\n\nexport default class NLCasualDateTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(gisteren|morgen|van)(ochtend|middag|namiddag|avond|nacht)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const dateText = match[DATE_GROUP].toLowerCase();\n        const timeText = match[TIME_OF_DAY_GROUP].toLowerCase();\n        const component = context.createParsingComponents();\n        const targetDate = context.refDate;\n\n        switch (dateText) {\n            case \"gisteren\":\n                const previousDay = new Date(targetDate.getTime());\n                previousDay.setDate(previousDay.getDate() - 1);\n                assignSimilarDate(component, previousDay);\n                break;\n            case \"van\":\n                assignSimilarDate(component, targetDate);\n                break;\n            case \"morgen\":\n                const nextDay = new Date(targetDate.getTime());\n                nextDay.setDate(nextDay.getDate() + 1);\n                assignSimilarDate(component, nextDay);\n                implySimilarTime(component, nextDay);\n                break;\n        }\n\n        switch (timeText) {\n            case \"ochtend\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n            case \"middag\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n            case \"namiddag\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"avond\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 20);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(\n    `(dit|deze|vorig|afgelopen|(?:aan)?komend|over|\\\\+|-)e?\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PREFIX_WORD_GROUP = 1;\nconst TIME_UNIT_WORD_GROUP = 2;\n\nexport default class NLTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[PREFIX_WORD_GROUP].toLowerCase();\n        let timeUnits = parseDuration(match[TIME_UNIT_WORD_GROUP]);\n        switch (prefix) {\n            case \"vorig\":\n            case \"afgelopen\":\n            case \"-\":\n                timeUnits = reverseDuration(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nconst PATTERN = new RegExp(\n    `(dit|deze|(?:aan)?komend|volgend|afgelopen|vorig)e?\\\\s*(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class NLRelativeDateFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"volgend\" || modifier == \"komend\" || modifier == \"aankomend\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"afgelopen\" || modifier == \"vorig\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = new Date(context.reference.instant.getTime());\n\n        // This week\n        if (unitWord.match(/week/i)) {\n            date.setDate(date.getDate() - date.getDay());\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.imply(\"year\", date.getFullYear());\n        }\n\n        // This month\n        else if (unitWord.match(/maand/i)) {\n            date.setDate(1);\n            components.imply(\"day\", date.getDate());\n            components.assign(\"year\", date.getFullYear());\n            components.assign(\"month\", date.getMonth() + 1);\n        }\n\n        // This year\n        else if (unitWord.match(/jaar/i)) {\n            date.setDate(1);\n            date.setMonth(0);\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.assign(\"year\", date.getFullYear());\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(?:geleden|voor|eerder)(?=(?:\\\\W|$))\", \"i\");\n\nconst STRICT_PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"geleden(?=(?:\\\\W|$))\", \"i\");\n\nexport default class NLTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseDuration(match[1]);\n        const outputTimeUnits = reverseDuration(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(later|na|vanaf nu|voortaan|vooruit|uit)\" + \"(?=(?:\\\\W|$))\",\n    \"i\"\n);\n\nconst STRICT_PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(later|vanaf nu)\" + \"(?=(?:\\\\W|$))\", \"i\");\nconst GROUP_NUM_TIMEUNITS = 1;\n\nexport default class NLTimeUnitLaterFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const fragments = parseDuration(match[GROUP_NUM_TIMEUNITS]);\n        return ParsingComponents.createRelativeFromReference(context.reference, fragments);\n    }\n}\n", "import { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport ExtractTimezoneOffsetRefiner from \"../../common/refiners/ExtractTimezoneOffsetRefiner\";\n\nimport ZHHansCasualDateParser from \"./hans/parsers/ZHHansCasualDateParser\";\nimport ZHHansDateParser from \"./hans/parsers/ZHHansDateParser\";\nimport ZHHansDeadlineFormatParser from \"./hans/parsers/ZHHansDeadlineFormatParser\";\nimport ZHHansRelationWeekdayParser from \"./hans/parsers/ZHHansRelationWeekdayParser\";\nimport ZHHansTimeExpressionParser from \"./hans/parsers/ZHHansTimeExpressionParser\";\nimport ZHHansWeekdayParser from \"./hans/parsers/ZHHansWeekdayParser\";\n\nimport ZHHantCasualDateParser from \"./hant/parsers/ZHHantCasualDateParser\";\nimport ZHHantDateParser from \"./hant/parsers/ZHHantDateParser\";\nimport ZHHantDeadlineFormatParser from \"./hant/parsers/ZHHantDeadlineFormatParser\";\nimport ZHHantRelationWeekdayParser from \"./hant/parsers/ZHHantRelationWeekdayParser\";\nimport ZHHantTimeExpressionParser from \"./hant/parsers/ZHHantTimeExpressionParser\";\nimport ZHHantWeekdayParser from \"./hant/parsers/ZHHantWeekdayParser\";\nimport ZHHantMergeDateRangeRefiner from \"./hant/refiners/ZHHantMergeDateRangeRefiner\";\nimport ZHHantMergeDateTimeRefiner from \"./hant/refiners/ZHHantMergeDateTimeRefiner\";\n\nexport * as hant from \"./hant\";\nexport * as hans from \"./hans\";\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new ZHHantCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    const configuration = includeCommonConfiguration({\n        parsers: [\n            new ZHHantDateParser(),\n            new ZHHansDateParser(),\n            new ZHHantRelationWeekdayParser(),\n            new ZHHansRelationWeekdayParser(),\n            new ZHHantWeekdayParser(),\n            new ZHHansWeekdayParser(),\n            new ZHHantTimeExpressionParser(),\n            new ZHHansTimeExpressionParser(),\n            new ZHHantDeadlineFormatParser(),\n            new ZHHansDeadlineFormatParser(),\n        ],\n        refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()],\n    });\n\n    // REMOVE ExtractTimezoneOffsetRefiner\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)\n    );\n\n    return configuration;\n}\n", "export const NUMBER = {\n    \"零\": 0,\n    \"〇\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"两\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n    \"七\": 7,\n    \"八\": 8,\n    \"九\": 9,\n    \"十\": 10,\n};\n\nexport const WEEKDAY_OFFSET = {\n    \"天\": 0,\n    \"日\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n};\n\nexport function zhStringToNumber(text: string) {\n    let number = 0;\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === \"十\") {\n            number = number === 0 ? NUMBER[char] : number * NUMBER[char];\n        } else {\n            number += NUMBER[char];\n        }\n    }\n\n    return number;\n}\n\nexport function zhStringToYear(text: string) {\n    let string = \"\";\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        string = string + NUMBER[char];\n    }\n\n    return parseInt(string);\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber, zhStringToYear } from \"../constants\";\n\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\n\nexport default class ZHHansDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        // prettier-ignore\n        return new RegExp(\n            \"(\" +\n                \"\\\\d{2,4}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{4}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{2}\" +\n                \")?\" +\n                \"(?:\\\\s*)\" +\n                \"(?:年)?\" +\n                \"(?:[\\\\s|,|，]*)\" +\n                \"(\" +\n                \"\\\\d{1,2}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{1,3}\" +\n                \")\" +\n                \"(?:\\\\s*)\" +\n                \"(?:月)\" +\n                \"(?:\\\\s*)\" +\n                \"(\" +\n                \"\\\\d{1,2}|\" +\n                \"[\" +\n                Object.keys(NUMBER).join(\"\") +\n                \"]{1,3}\" +\n                \")?\" +\n                \"(?:\\\\s*)\" +\n                \"(?:日|号)?\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        //Month\n        let month = parseInt(match[MONTH_GROUP]);\n        if (isNaN(month)) month = zhStringToNumber(match[MONTH_GROUP]);\n        result.start.assign(\"month\", month);\n\n        //Day\n        if (match[DAY_GROUP]) {\n            let day = parseInt(match[DAY_GROUP]);\n            if (isNaN(day)) day = zhStringToNumber(match[DAY_GROUP]);\n            result.start.assign(\"day\", day);\n        } else {\n            result.start.imply(\"day\", context.refDate.getDate());\n        }\n\n        //Year\n        if (match[YEAR_GROUP]) {\n            let year = parseInt(match[YEAR_GROUP]);\n            if (isNaN(year)) year = zhStringToYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            result.start.imply(\"year\", context.refDate.getFullYear());\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { addDuration, Duration } from \"../../../../calculation/duration\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+|半|几)(?:\\\\s*)\" +\n        \"(?:个)?\" +\n        \"(秒(?:钟)?|分钟|小时|钟|日|天|星期|礼拜|月|年)\" +\n        \"(?:(?:之|过)?后|(?:之)?内)\",\n    \"i\"\n);\n\nconst NUMBER_GROUP = 1;\nconst UNIT_GROUP = 2;\n\nexport default class ZHHansDeadlineFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        let number = parseInt(match[NUMBER_GROUP]);\n        if (isNaN(number)) {\n            number = zhStringToNumber(match[NUMBER_GROUP]);\n        }\n\n        if (isNaN(number)) {\n            const string = match[NUMBER_GROUP];\n            if (string === \"几\") {\n                number = 3;\n            } else if (string === \"半\") {\n                number = 0.5;\n            } else {\n                //just in case\n                return null;\n            }\n        }\n\n        const duration: Duration = {};\n        const unit = match[UNIT_GROUP];\n        const unitAbbr = unit[0];\n\n        if (unitAbbr.match(/[日天星礼月年]/)) {\n            if (unitAbbr == \"日\" || unitAbbr == \"天\") {\n                duration.day = number;\n            } else if (unitAbbr == \"星\" || unitAbbr == \"礼\") {\n                duration.week = number;\n            } else if (unitAbbr == \"月\") {\n                duration.month = number;\n            } else if (unitAbbr == \"年\") {\n                duration.year = number;\n            }\n\n            const date = addDuration(context.refDate, duration);\n            result.start.assign(\"year\", date.getFullYear());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"day\", date.getDate());\n            return result;\n        }\n\n        if (unitAbbr == \"秒\") {\n            duration.second = number;\n        } else if (unitAbbr == \"分\") {\n            duration.minute = number;\n        } else if (unitAbbr == \"小\" || unitAbbr == \"钟\") {\n            duration.hour = number;\n        }\n\n        const date = addDuration(context.refDate, duration);\n        result.start.imply(\"year\", date.getFullYear());\n        result.start.imply(\"month\", date.getMonth() + 1);\n        result.start.imply(\"day\", date.getDate());\n        result.start.assign(\"hour\", date.getHours());\n        result.start.assign(\"minute\", date.getMinutes());\n        result.start.assign(\"second\", date.getSeconds());\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(?<prefix>上|下|这)(?:个)?(?:星期|礼拜|周)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\"\n);\n\nexport default class ZHHansRelationWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let modifier = null;\n        const prefix = match.groups.prefix;\n\n        if (prefix == \"上\") {\n            modifier = \"last\";\n        } else if (prefix == \"下\") {\n            modifier = \"next\";\n        } else if (prefix == \"这\") {\n            modifier = \"this\";\n        }\n\n        const date = new Date(context.refDate.getTime());\n        let startMomentFixed = false;\n        const refOffset = date.getDay();\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            date.setDate(date.getDate() + (offset - 7 - refOffset));\n            startMomentFixed = true;\n        } else if (modifier == \"next\") {\n            date.setDate(date.getDate() + (offset + 7 - refOffset));\n            startMomentFixed = true;\n        } else if (modifier == \"this\") {\n            date.setDate(date.getDate() + (offset - refOffset));\n        } else {\n            let diff = offset - refOffset;\n            if (Math.abs(diff - 7) < Math.abs(diff)) {\n                diff -= 7;\n            }\n            if (Math.abs(diff + 7) < Math.abs(diff)) {\n                diff += 7;\n            }\n            date.setDate(date.getDate() + diff);\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", date.getDate());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"year\", date.getFullYear());\n        } else {\n            result.start.imply(\"day\", date.getDate());\n            result.start.imply(\"month\", date.getMonth() + 1);\n            result.start.imply(\"year\", date.getFullYear());\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(?:从|自)?\" +\n        \"(?:\" +\n        \"(今|明|前|大前|后|大后|昨)(早|朝|晚)|\" +\n        \"(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|后|大后|昨)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:点|时|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"(?:^\\\\s*(?:到|至|\\\\-|\\\\–|\\\\~|\\\\〜)\\\\s*)\" +\n        \"(?:\" +\n        \"(今|明|前|大前|后|大后|昨)(早|朝|晚)|\" +\n        \"(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|后|大后|昨)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:点|时|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst DAY_GROUP_1 = 1;\nconst ZH_AM_PM_HOUR_GROUP_1 = 2;\nconst ZH_AM_PM_HOUR_GROUP_2 = 3;\nconst DAY_GROUP_3 = 4;\nconst ZH_AM_PM_HOUR_GROUP_3 = 5;\nconst HOUR_GROUP = 6;\nconst MINUTE_GROUP = 7;\nconst SECOND_GROUP = 8;\nconst AM_PM_HOUR_GROUP = 9;\n\nexport default class ZHHansTimeExpressionParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // This pattern can be overlaped Ex. [12] AM, 1[2] AM\n        if (match.index > 0 && context.text[match.index - 1].match(/\\w/)) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match[0]);\n        const startMoment = new Date(context.refDate.getTime());\n\n        // ----- Day\n        if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            if (day1 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (context.refDate.getHours() > 1) {\n                    startMoment.setDate(startMoment.getDate() + 1);\n                }\n            } else if (day1 == \"昨\") {\n                startMoment.setDate(startMoment.getDate() - 1);\n            } else if (day1 == \"前\") {\n                startMoment.setDate(startMoment.getDate() - 2);\n            } else if (day1 == \"大前\") {\n                startMoment.setDate(startMoment.getDate() - 3);\n            } else if (day1 == \"后\") {\n                startMoment.setDate(startMoment.getDate() + 2);\n            } else if (day1 == \"大后\") {\n                startMoment.setDate(startMoment.getDate() + 3);\n            }\n            result.start.assign(\"day\", startMoment.getDate());\n            result.start.assign(\"month\", startMoment.getMonth() + 1);\n            result.start.assign(\"year\", startMoment.getFullYear());\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n            if (day3 == \"明\") {\n                startMoment.setDate(startMoment.getDate() + 1);\n            } else if (day3 == \"昨\") {\n                startMoment.setDate(startMoment.getDate() - 1);\n            } else if (day3 == \"前\") {\n                startMoment.setDate(startMoment.getDate() - 2);\n            } else if (day3 == \"大前\") {\n                startMoment.setDate(startMoment.getDate() - 3);\n            } else if (day3 == \"后\") {\n                startMoment.setDate(startMoment.getDate() + 2);\n            } else if (day3 == \"大后\") {\n                startMoment.setDate(startMoment.getDate() + 3);\n            }\n            result.start.assign(\"day\", startMoment.getDate());\n            result.start.assign(\"month\", startMoment.getMonth() + 1);\n            result.start.assign(\"year\", startMoment.getFullYear());\n        } else {\n            result.start.imply(\"day\", startMoment.getDate());\n            result.start.imply(\"month\", startMoment.getMonth() + 1);\n            result.start.imply(\"year\", startMoment.getFullYear());\n        }\n\n        let hour = 0;\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Second\n        if (match[SECOND_GROUP]) {\n            let second = parseInt(match[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(match[SECOND_GROUP]);\n            }\n            if (second >= 60) return null;\n            result.start.assign(\"second\", second);\n        }\n\n        hour = parseInt(match[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(match[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP]) {\n            if (match[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (match[MINUTE_GROUP] == \"正\" || match[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(match[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(match[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            const ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {\n            const zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];\n            const zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {\n            const zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];\n            const zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {\n            const zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];\n            const zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.start.assign(\"hour\", hour);\n        result.start.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            result.start.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                result.start.imply(\"meridiem\", 0);\n            } else {\n                result.start.imply(\"meridiem\", 1);\n            }\n        }\n\n        // ==============================================================\n        //                  Extracting the 'to' chunk\n        // ==============================================================\n\n        const secondMatch = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));\n        if (!secondMatch) {\n            // Not accept number only result\n            if (result.text.match(/^\\d+$/)) {\n                return null;\n            }\n            return result;\n        }\n\n        const endMoment = new Date(startMoment.getTime());\n        result.end = context.createParsingComponents();\n\n        // ----- Day\n        if (secondMatch[DAY_GROUP_1]) {\n            const day1 = secondMatch[DAY_GROUP_1];\n            if (day1 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (context.refDate.getHours() > 1) {\n                    endMoment.setDate(endMoment.getDate() + 1);\n                }\n            } else if (day1 == \"昨\") {\n                endMoment.setDate(endMoment.getDate() - 1);\n            } else if (day1 == \"前\") {\n                endMoment.setDate(endMoment.getDate() - 2);\n            } else if (day1 == \"大前\") {\n                endMoment.setDate(endMoment.getDate() - 3);\n            } else if (day1 == \"后\") {\n                endMoment.setDate(endMoment.getDate() + 2);\n            } else if (day1 == \"大后\") {\n                endMoment.setDate(endMoment.getDate() + 3);\n            }\n            result.end.assign(\"day\", endMoment.getDate());\n            result.end.assign(\"month\", endMoment.getMonth() + 1);\n            result.end.assign(\"year\", endMoment.getFullYear());\n        } else if (secondMatch[DAY_GROUP_3]) {\n            const day3 = secondMatch[DAY_GROUP_3];\n            if (day3 == \"明\") {\n                endMoment.setDate(endMoment.getDate() + 1);\n            } else if (day3 == \"昨\") {\n                endMoment.setDate(endMoment.getDate() - 1);\n            } else if (day3 == \"前\") {\n                endMoment.setDate(endMoment.getDate() - 2);\n            } else if (day3 == \"大前\") {\n                endMoment.setDate(endMoment.getDate() - 3);\n            } else if (day3 == \"后\") {\n                endMoment.setDate(endMoment.getDate() + 2);\n            } else if (day3 == \"大后\") {\n                endMoment.setDate(endMoment.getDate() + 3);\n            }\n            result.end.assign(\"day\", endMoment.getDate());\n            result.end.assign(\"month\", endMoment.getMonth() + 1);\n            result.end.assign(\"year\", endMoment.getFullYear());\n        } else {\n            result.end.imply(\"day\", endMoment.getDate());\n            result.end.imply(\"month\", endMoment.getMonth() + 1);\n            result.end.imply(\"year\", endMoment.getFullYear());\n        }\n\n        hour = 0;\n        minute = 0;\n        meridiem = -1;\n\n        // ----- Second\n        if (secondMatch[SECOND_GROUP]) {\n            let second = parseInt(secondMatch[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(secondMatch[SECOND_GROUP]);\n            }\n\n            if (second >= 60) return null;\n            result.end.assign(\"second\", second);\n        }\n\n        hour = parseInt(secondMatch[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(secondMatch[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (secondMatch[MINUTE_GROUP]) {\n            if (secondMatch[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (secondMatch[MINUTE_GROUP] == \"正\" || secondMatch[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(secondMatch[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(secondMatch[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (secondMatch[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            const ampm = secondMatch[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == 0) {\n                    result.start.imply(\"meridiem\", 0);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", 1);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_1]) {\n            const zhAMPMString1 = secondMatch[ZH_AM_PM_HOUR_GROUP_1];\n            const zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_2]) {\n            const zhAMPMString2 = secondMatch[ZH_AM_PM_HOUR_GROUP_2];\n            const zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_3]) {\n            const zhAMPMString3 = secondMatch[ZH_AM_PM_HOUR_GROUP_3];\n            const zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.text = result.text + secondMatch[0];\n        result.end.assign(\"hour\", hour);\n        result.end.assign(\"minute\", minute);\n        if (meridiem >= 0) {\n            result.end.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"meridiem\") == 1;\n            if (startAtPM && result.start.get(\"hour\") > hour) {\n                // 10pm - 1 (am)\n                result.end.imply(\"meridiem\", 0);\n            } else if (hour > 12) {\n                result.end.imply(\"meridiem\", 1);\n            }\n        }\n\n        if (result.end.date().getTime() < result.start.date().getTime()) {\n            result.end.imply(\"day\", result.end.get(\"day\") + 1);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\"(?:星期|礼拜|周)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\");\n\nexport default class ZHHansWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        const date = new Date(context.refDate.getTime());\n        const startMomentFixed = false;\n        const refOffset = date.getDay();\n\n        let diff = offset - refOffset;\n        if (Math.abs(diff - 7) < Math.abs(diff)) {\n            diff -= 7;\n        }\n        if (Math.abs(diff + 7) < Math.abs(diff)) {\n            diff += 7;\n        }\n\n        date.setDate(date.getDate() + diff);\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", date.getDate());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"year\", date.getFullYear());\n        } else {\n            result.start.imply(\"day\", date.getDate());\n            result.start.imply(\"month\", date.getMonth() + 1);\n            result.start.imply(\"year\", date.getFullYear());\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingComponents, ParsingResult } from \"../../../../results\";\n\nconst NOW_GROUP = 1;\nconst DAY_GROUP_1 = 2;\nconst TIME_GROUP_1 = 3;\nconst TIME_GROUP_2 = 4;\nconst DAY_GROUP_3 = 5;\nconst TIME_GROUP_3 = 6;\n\nexport default class ZHHantCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(\n            \"(而家|立(?:刻|即)|即刻)|\" +\n                \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|\" +\n                \"(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n                \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)\" +\n                \"(?:[\\\\s|,|，]*)\" +\n                \"(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\",\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const index = match.index;\n        const result = context.createParsingResult(index, match[0]);\n\n        const refDate = context.refDate;\n        let date = new Date(refDate.getTime());\n\n        if (match[NOW_GROUP]) {\n            result.start.imply(\"hour\", refDate.getHours());\n            result.start.imply(\"minute\", refDate.getMinutes());\n            result.start.imply(\"second\", refDate.getSeconds());\n            result.start.imply(\"millisecond\", refDate.getMilliseconds());\n        } else if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            const time1 = match[TIME_GROUP_1];\n\n            if (day1 == \"明\" || day1 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (refDate.getHours() > 1) {\n                    date.setDate(date.getDate() + 1);\n                }\n            } else if (day1 == \"昨\" || day1 == \"尋\" || day1 == \"琴\") {\n                date.setDate(date.getDate() - 1);\n            } else if (day1 == \"前\") {\n                date.setDate(date.getDate() - 2);\n            } else if (day1 == \"大前\") {\n                date.setDate(date.getDate() - 3);\n            } else if (day1 == \"後\") {\n                date.setDate(date.getDate() + 2);\n            } else if (day1 == \"大後\") {\n                date.setDate(date.getDate() + 3);\n            }\n\n            if (time1 == \"早\" || time1 == \"朝\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time1 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            }\n        } else if (match[TIME_GROUP_2]) {\n            const timeString2 = match[TIME_GROUP_2];\n            const time2 = timeString2[0];\n            if (time2 == \"早\" || time2 == \"朝\" || time2 == \"上\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time2 == \"下\" || time2 == \"晏\") {\n                result.start.imply(\"hour\", 15);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"中\") {\n                result.start.imply(\"hour\", 12);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"夜\" || time2 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"凌\") {\n                result.start.imply(\"hour\", 0);\n            }\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n\n            if (day3 == \"明\" || day3 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (refDate.getHours() > 1) {\n                    date.setDate(date.getDate() + 1);\n                }\n            } else if (day3 == \"昨\" || day3 == \"尋\" || day3 == \"琴\") {\n                date.setDate(date.getDate() - 1);\n            } else if (day3 == \"前\") {\n                date.setDate(date.getDate() - 2);\n            } else if (day3 == \"大前\") {\n                date.setDate(date.getDate() - 3);\n            } else if (day3 == \"後\") {\n                date.setDate(date.getDate() + 2);\n            } else if (day3 == \"大後\") {\n                date.setDate(date.getDate() + 3);\n            }\n\n            const timeString3 = match[TIME_GROUP_3];\n            if (timeString3) {\n                const time3 = timeString3[0];\n                if (time3 == \"早\" || time3 == \"朝\" || time3 == \"上\") {\n                    result.start.imply(\"hour\", 6);\n                } else if (time3 == \"下\" || time3 == \"晏\") {\n                    result.start.imply(\"hour\", 15);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"中\") {\n                    result.start.imply(\"hour\", 12);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"夜\" || time3 == \"晚\") {\n                    result.start.imply(\"hour\", 22);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"凌\") {\n                    result.start.imply(\"hour\", 0);\n                }\n            }\n        }\n\n        result.start.assign(\"day\", date.getDate());\n        result.start.assign(\"month\", date.getMonth() + 1);\n        result.start.assign(\"year\", date.getFullYear());\n\n        return result;\n    }\n}\n", "export const NUMBER = {\n    \"零\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"兩\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n    \"七\": 7,\n    \"八\": 8,\n    \"九\": 9,\n    \"十\": 10,\n    \"廿\": 20,\n    \"卅\": 30,\n};\n\nexport const WEEKDAY_OFFSET = {\n    \"天\": 0,\n    \"日\": 0,\n    \"一\": 1,\n    \"二\": 2,\n    \"三\": 3,\n    \"四\": 4,\n    \"五\": 5,\n    \"六\": 6,\n};\n\nexport function zhStringToNumber(text: string) {\n    let number = 0;\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        if (char === \"十\") {\n            number = number === 0 ? NUMBER[char] : number * NUMBER[char];\n        } else {\n            number += NUMBER[char];\n        }\n    }\n\n    return number;\n}\n\nexport function zhStringToYear(text: string) {\n    let string = \"\";\n\n    for (let i = 0; i < text.length; i++) {\n        const char = text[i];\n        string = string + NUMBER[char];\n    }\n\n    return parseInt(string);\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber, zhStringToYear } from \"../constants\";\n\nconst YEAR_GROUP = 1;\nconst MONTH_GROUP = 2;\nconst DAY_GROUP = 3;\n\nexport default class ZHHantDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        // prettier-ignore\n        return new RegExp(\n            \"(\" +\n                \"\\\\d{2,4}|\" +\n                \"[\" + Object.keys(NUMBER).join(\"\") + \"]{4}|\" +\n                \"[\" + Object.keys(NUMBER).join(\"\") + \"]{2}\" +\n            \")?\"+\n            \"(?:\\\\s*)\" +\n            \"(?:年)?\" +\n            \"(?:[\\\\s|,|，]*)\" +\n\n            \"(\" +\n                \"\\\\d{1,2}|\"+\n                \"[\" +Object.keys(NUMBER).join(\"\") +\"]{1,2}\"+\n            \")\" +\n            \"(?:\\\\s*)\" +\n            \"(?:月)\" +\n            \"(?:\\\\s*)\" +\n            \"(\" + \n                \"\\\\d{1,2}|\" +\n                \"[\" + Object.keys(NUMBER).join(\"\") + \"]{1,2}\" +\n            \")?\" +\n            \"(?:\\\\s*)\" +\n            \"(?:日|號)?\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        //Month\n        let month = parseInt(match[MONTH_GROUP]);\n        if (isNaN(month)) month = zhStringToNumber(match[MONTH_GROUP]);\n        result.start.assign(\"month\", month);\n\n        //Day\n        if (match[DAY_GROUP]) {\n            let day = parseInt(match[DAY_GROUP]);\n            if (isNaN(day)) day = zhStringToNumber(match[DAY_GROUP]);\n            result.start.assign(\"day\", day);\n        } else {\n            result.start.imply(\"day\", context.refDate.getDate());\n        }\n\n        //Year\n        if (match[YEAR_GROUP]) {\n            let year = parseInt(match[YEAR_GROUP]);\n            if (isNaN(year)) year = zhStringToYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            result.start.imply(\"year\", context.refDate.getFullYear());\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { addDuration, Duration } from \"../../../../calculation/duration\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+|半|幾)(?:\\\\s*)\" +\n        \"(?:個)?\" +\n        \"(秒(?:鐘)?|分鐘|小時|鐘|日|天|星期|禮拜|月|年)\" +\n        \"(?:(?:之|過)?後|(?:之)?內)\",\n    \"i\"\n);\n\nconst NUMBER_GROUP = 1;\nconst UNIT_GROUP = 2;\n\nexport default class ZHHantDeadlineFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        let number = parseInt(match[NUMBER_GROUP]);\n        if (isNaN(number)) {\n            number = zhStringToNumber(match[NUMBER_GROUP]);\n        }\n\n        if (isNaN(number)) {\n            const string = match[NUMBER_GROUP];\n            if (string === \"幾\") {\n                number = 3;\n            } else if (string === \"半\") {\n                number = 0.5;\n            } else {\n                //just in case\n                return null;\n            }\n        }\n\n        const duration: Duration = {};\n        const unit = match[UNIT_GROUP];\n        const unitAbbr = unit[0];\n\n        if (unitAbbr.match(/[日天星禮月年]/)) {\n            if (unitAbbr == \"日\" || unitAbbr == \"天\") {\n                duration.day = number;\n            } else if (unitAbbr == \"星\" || unitAbbr == \"禮\") {\n                duration.week = number;\n            } else if (unitAbbr == \"月\") {\n                duration.month = number;\n            } else if (unitAbbr == \"年\") {\n                duration.year = number;\n            }\n\n            const date = addDuration(context.refDate, duration);\n            result.start.assign(\"year\", date.getFullYear());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"day\", date.getDate());\n            return result;\n        }\n\n        if (unitAbbr == \"秒\") {\n            duration.second = number;\n        } else if (unitAbbr == \"分\") {\n            duration.minute = number;\n        } else if (unitAbbr == \"小\" || unitAbbr == \"鐘\") {\n            duration.hour = number;\n        }\n\n        const date = addDuration(context.refDate, duration);\n        result.start.imply(\"year\", date.getFullYear());\n        result.start.imply(\"month\", date.getMonth() + 1);\n        result.start.imply(\"day\", date.getDate());\n        result.start.assign(\"hour\", date.getHours());\n        result.start.assign(\"minute\", date.getMinutes());\n        result.start.assign(\"second\", date.getSeconds());\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\n    \"(?<prefix>上|今|下|這|呢)(?:個)?(?:星期|禮拜|週)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\"\n);\n\nexport default class ZHHantRelationWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        let modifier = null;\n        const prefix = match.groups.prefix;\n\n        if (prefix == \"上\") {\n            modifier = \"last\";\n        } else if (prefix == \"下\") {\n            modifier = \"next\";\n        } else if (prefix == \"今\" || prefix == \"這\" || prefix == \"呢\") {\n            modifier = \"this\";\n        }\n\n        const date = new Date(context.refDate.getTime());\n        let startMomentFixed = false;\n        const refOffset = date.getDay();\n\n        if (modifier == \"last\" || modifier == \"past\") {\n            date.setDate(date.getDate() + (offset - 7 - refOffset));\n            startMomentFixed = true;\n        } else if (modifier == \"next\") {\n            date.setDate(date.getDate() + (offset + 7 - refOffset));\n            startMomentFixed = true;\n        } else if (modifier == \"this\") {\n            date.setDate(date.getDate() + (offset - refOffset));\n        } else {\n            let diff = offset - refOffset;\n            if (Math.abs(diff - 7) < Math.abs(diff)) {\n                diff -= 7;\n            }\n            if (Math.abs(diff + 7) < Math.abs(diff)) {\n                diff += 7;\n            }\n            date.setDate(date.getDate() + diff);\n        }\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", date.getDate());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"year\", date.getFullYear());\n        } else {\n            result.start.imply(\"day\", date.getDate());\n            result.start.imply(\"month\", date.getMonth() + 1);\n            result.start.imply(\"year\", date.getFullYear());\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { NUMBER, zhStringToNumber } from \"../constants\";\n\nconst FIRST_REG_PATTERN = new RegExp(\n    \"(?:由|從|自)?\" +\n        \"(?:\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|\" +\n        \"(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:點|時|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst SECOND_REG_PATTERN = new RegExp(\n    \"(?:^\\\\s*(?:到|至|\\\\-|\\\\–|\\\\~|\\\\〜)\\\\s*)\" +\n        \"(?:\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(早|朝|晚)|\" +\n        \"(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n        \"(今|明|前|大前|後|大後|聽|昨|尋|琴)(?:日|天)\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\" +\n        \")?\" +\n        \"(?:[\\\\s,，]*)\" +\n        \"(?:(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)(?:\\\\s*)(?:點|時|:|：)\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|半|正|整|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:分|:|：)?\" +\n        \"(?:\\\\s*)\" +\n        \"(\\\\d+|[\" +\n        Object.keys(NUMBER).join(\"\") +\n        \"]+)?(?:\\\\s*)(?:秒)?)\" +\n        \"(?:\\\\s*(A.M.|P.M.|AM?|PM?))?\",\n    \"i\"\n);\n\nconst DAY_GROUP_1 = 1;\nconst ZH_AM_PM_HOUR_GROUP_1 = 2;\nconst ZH_AM_PM_HOUR_GROUP_2 = 3;\nconst DAY_GROUP_3 = 4;\nconst ZH_AM_PM_HOUR_GROUP_3 = 5;\nconst HOUR_GROUP = 6;\nconst MINUTE_GROUP = 7;\nconst SECOND_GROUP = 8;\nconst AM_PM_HOUR_GROUP = 9;\n\nexport default class ZHHantTimeExpressionParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return FIRST_REG_PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        // This pattern can be overlaped Ex. [12] AM, 1[2] AM\n        if (match.index > 0 && context.text[match.index - 1].match(/\\w/)) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match[0]);\n        const startMoment = new Date(context.refDate.getTime());\n\n        // ----- Day\n        if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            if (day1 == \"明\" || day1 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (context.refDate.getHours() > 1) {\n                    startMoment.setDate(startMoment.getDate() + 1);\n                }\n            } else if (day1 == \"昨\" || day1 == \"尋\" || day1 == \"琴\") {\n                startMoment.setDate(startMoment.getDate() - 1);\n            } else if (day1 == \"前\") {\n                startMoment.setDate(startMoment.getDate() - 2);\n            } else if (day1 == \"大前\") {\n                startMoment.setDate(startMoment.getDate() - 3);\n            } else if (day1 == \"後\") {\n                startMoment.setDate(startMoment.getDate() + 2);\n            } else if (day1 == \"大後\") {\n                startMoment.setDate(startMoment.getDate() + 3);\n            }\n            result.start.assign(\"day\", startMoment.getDate());\n            result.start.assign(\"month\", startMoment.getMonth() + 1);\n            result.start.assign(\"year\", startMoment.getFullYear());\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n            if (day3 == \"明\" || day3 == \"聽\") {\n                startMoment.setDate(startMoment.getDate() + 1);\n            } else if (day3 == \"昨\" || day3 == \"尋\" || day3 == \"琴\") {\n                startMoment.setDate(startMoment.getDate() - 1);\n            } else if (day3 == \"前\") {\n                startMoment.setDate(startMoment.getDate() - 2);\n            } else if (day3 == \"大前\") {\n                startMoment.setDate(startMoment.getDate() - 3);\n            } else if (day3 == \"後\") {\n                startMoment.setDate(startMoment.getDate() + 2);\n            } else if (day3 == \"大後\") {\n                startMoment.setDate(startMoment.getDate() + 3);\n            }\n            result.start.assign(\"day\", startMoment.getDate());\n            result.start.assign(\"month\", startMoment.getMonth() + 1);\n            result.start.assign(\"year\", startMoment.getFullYear());\n        } else {\n            result.start.imply(\"day\", startMoment.getDate());\n            result.start.imply(\"month\", startMoment.getMonth() + 1);\n            result.start.imply(\"year\", startMoment.getFullYear());\n        }\n\n        let hour = 0;\n        let minute = 0;\n        let meridiem = -1;\n\n        // ----- Second\n        if (match[SECOND_GROUP]) {\n            var second = parseInt(match[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(match[SECOND_GROUP]);\n            }\n            if (second >= 60) return null;\n            result.start.assign(\"second\", second);\n        }\n\n        hour = parseInt(match[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(match[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (match[MINUTE_GROUP]) {\n            if (match[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (match[MINUTE_GROUP] == \"正\" || match[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(match[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(match[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (match[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            var ampm = match[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_1]) {\n            var zhAMPMString1 = match[ZH_AM_PM_HOUR_GROUP_1];\n            var zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"朝\" || zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_2]) {\n            var zhAMPMString2 = match[ZH_AM_PM_HOUR_GROUP_2];\n            var zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"朝\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晏\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (match[ZH_AM_PM_HOUR_GROUP_3]) {\n            var zhAMPMString3 = match[ZH_AM_PM_HOUR_GROUP_3];\n            var zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"朝\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晏\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.start.assign(\"hour\", hour);\n        result.start.assign(\"minute\", minute);\n\n        if (meridiem >= 0) {\n            result.start.assign(\"meridiem\", meridiem);\n        } else {\n            if (hour < 12) {\n                result.start.imply(\"meridiem\", 0);\n            } else {\n                result.start.imply(\"meridiem\", 1);\n            }\n        }\n\n        // ==============================================================\n        //                  Extracting the 'to' chunk\n        // ==============================================================\n\n        const secondMatch = SECOND_REG_PATTERN.exec(context.text.substring(result.index + result.text.length));\n        if (!secondMatch) {\n            // Not accept number only result\n            if (result.text.match(/^\\d+$/)) {\n                return null;\n            }\n            return result;\n        }\n\n        const endMoment = new Date(startMoment.getTime());\n        result.end = context.createParsingComponents();\n\n        // ----- Day\n        if (secondMatch[DAY_GROUP_1]) {\n            const day1 = secondMatch[DAY_GROUP_1];\n            if (day1 == \"明\" || day1 == \"聽\") {\n                // Check not \"Tomorrow\" on late night\n                if (context.refDate.getHours() > 1) {\n                    endMoment.setDate(endMoment.getDate() + 1);\n                }\n            } else if (day1 == \"昨\" || day1 == \"尋\" || day1 == \"琴\") {\n                endMoment.setDate(endMoment.getDate() - 1);\n            } else if (day1 == \"前\") {\n                endMoment.setDate(endMoment.getDate() - 2);\n            } else if (day1 == \"大前\") {\n                endMoment.setDate(endMoment.getDate() - 3);\n            } else if (day1 == \"後\") {\n                endMoment.setDate(endMoment.getDate() + 2);\n            } else if (day1 == \"大後\") {\n                endMoment.setDate(endMoment.getDate() + 3);\n            }\n            result.end.assign(\"day\", endMoment.getDate());\n            result.end.assign(\"month\", endMoment.getMonth() + 1);\n            result.end.assign(\"year\", endMoment.getFullYear());\n        } else if (secondMatch[DAY_GROUP_3]) {\n            const day3 = secondMatch[DAY_GROUP_3];\n            if (day3 == \"明\" || day3 == \"聽\") {\n                endMoment.setDate(endMoment.getDate() + 1);\n            } else if (day3 == \"昨\" || day3 == \"尋\" || day3 == \"琴\") {\n                endMoment.setDate(endMoment.getDate() - 1);\n            } else if (day3 == \"前\") {\n                endMoment.setDate(endMoment.getDate() - 2);\n            } else if (day3 == \"大前\") {\n                endMoment.setDate(endMoment.getDate() - 3);\n            } else if (day3 == \"後\") {\n                endMoment.setDate(endMoment.getDate() + 2);\n            } else if (day3 == \"大後\") {\n                endMoment.setDate(endMoment.getDate() + 3);\n            }\n            result.end.assign(\"day\", endMoment.getDate());\n            result.end.assign(\"month\", endMoment.getMonth() + 1);\n            result.end.assign(\"year\", endMoment.getFullYear());\n        } else {\n            result.end.imply(\"day\", endMoment.getDate());\n            result.end.imply(\"month\", endMoment.getMonth() + 1);\n            result.end.imply(\"year\", endMoment.getFullYear());\n        }\n\n        hour = 0;\n        minute = 0;\n        meridiem = -1;\n\n        // ----- Second\n        if (secondMatch[SECOND_GROUP]) {\n            let second = parseInt(secondMatch[SECOND_GROUP]);\n            if (isNaN(second)) {\n                second = zhStringToNumber(secondMatch[SECOND_GROUP]);\n            }\n\n            if (second >= 60) return null;\n            result.end.assign(\"second\", second);\n        }\n\n        hour = parseInt(secondMatch[HOUR_GROUP]);\n        if (isNaN(hour)) {\n            hour = zhStringToNumber(secondMatch[HOUR_GROUP]);\n        }\n\n        // ----- Minutes\n        if (secondMatch[MINUTE_GROUP]) {\n            if (secondMatch[MINUTE_GROUP] == \"半\") {\n                minute = 30;\n            } else if (secondMatch[MINUTE_GROUP] == \"正\" || secondMatch[MINUTE_GROUP] == \"整\") {\n                minute = 0;\n            } else {\n                minute = parseInt(secondMatch[MINUTE_GROUP]);\n                if (isNaN(minute)) {\n                    minute = zhStringToNumber(secondMatch[MINUTE_GROUP]);\n                }\n            }\n        } else if (hour > 100) {\n            minute = hour % 100;\n            hour = Math.floor(hour / 100);\n        }\n\n        if (minute >= 60) {\n            return null;\n        }\n\n        if (hour > 24) {\n            return null;\n        }\n        if (hour >= 12) {\n            meridiem = 1;\n        }\n\n        // ----- AM & PM\n        if (secondMatch[AM_PM_HOUR_GROUP]) {\n            if (hour > 12) return null;\n            var ampm = secondMatch[AM_PM_HOUR_GROUP][0].toLowerCase();\n            if (ampm == \"a\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            }\n\n            if (ampm == \"p\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n\n            if (!result.start.isCertain(\"meridiem\")) {\n                if (meridiem == 0) {\n                    result.start.imply(\"meridiem\", 0);\n\n                    if (result.start.get(\"hour\") == 12) {\n                        result.start.assign(\"hour\", 0);\n                    }\n                } else {\n                    result.start.imply(\"meridiem\", 1);\n\n                    if (result.start.get(\"hour\") != 12) {\n                        result.start.assign(\"hour\", result.start.get(\"hour\") + 12);\n                    }\n                }\n            }\n        } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_1]) {\n            const zhAMPMString1 = secondMatch[ZH_AM_PM_HOUR_GROUP_1];\n            var zhAMPM1 = zhAMPMString1[0];\n            if (zhAMPM1 == \"朝\" || zhAMPM1 == \"早\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM1 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_2]) {\n            const zhAMPMString2 = secondMatch[ZH_AM_PM_HOUR_GROUP_2];\n            var zhAMPM2 = zhAMPMString2[0];\n            if (zhAMPM2 == \"上\" || zhAMPM2 == \"朝\" || zhAMPM2 == \"早\" || zhAMPM2 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM2 == \"下\" || zhAMPM2 == \"晏\" || zhAMPM2 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        } else if (secondMatch[ZH_AM_PM_HOUR_GROUP_3]) {\n            const zhAMPMString3 = secondMatch[ZH_AM_PM_HOUR_GROUP_3];\n            var zhAMPM3 = zhAMPMString3[0];\n            if (zhAMPM3 == \"上\" || zhAMPM3 == \"朝\" || zhAMPM3 == \"早\" || zhAMPM3 == \"凌\") {\n                meridiem = 0;\n                if (hour == 12) hour = 0;\n            } else if (zhAMPM3 == \"下\" || zhAMPM3 == \"晏\" || zhAMPM3 == \"晚\") {\n                meridiem = 1;\n                if (hour != 12) hour += 12;\n            }\n        }\n\n        result.text = result.text + secondMatch[0];\n        result.end.assign(\"hour\", hour);\n        result.end.assign(\"minute\", minute);\n        if (meridiem >= 0) {\n            result.end.assign(\"meridiem\", meridiem);\n        } else {\n            const startAtPM = result.start.isCertain(\"meridiem\") && result.start.get(\"meridiem\") == 1;\n            if (startAtPM && result.start.get(\"hour\") > hour) {\n                // 10pm - 1 (am)\n                result.end.imply(\"meridiem\", 0);\n            } else if (hour > 12) {\n                result.end.imply(\"meridiem\", 1);\n            }\n        }\n\n        if (result.end.date().getTime() < result.start.date().getTime()) {\n            result.end.imply(\"day\", result.end.get(\"day\") + 1);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingResult } from \"../../../../results\";\nimport { WEEKDAY_OFFSET } from \"../constants\";\n\nconst PATTERN = new RegExp(\"(?:星期|禮拜|週)(?<weekday>\" + Object.keys(WEEKDAY_OFFSET).join(\"|\") + \")\");\n\nexport default class ZHHantWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const dayOfWeek = match.groups.weekday;\n        const offset = WEEKDAY_OFFSET[dayOfWeek];\n        if (offset === undefined) return null;\n\n        const date = new Date(context.refDate.getTime());\n        const startMomentFixed = false;\n        const refOffset = date.getDay();\n\n        let diff = offset - refOffset;\n        if (Math.abs(diff - 7) < Math.abs(diff)) {\n            diff -= 7;\n        }\n        if (Math.abs(diff + 7) < Math.abs(diff)) {\n            diff += 7;\n        }\n\n        date.setDate(date.getDate() + diff);\n\n        result.start.assign(\"weekday\", offset);\n        if (startMomentFixed) {\n            result.start.assign(\"day\", date.getDate());\n            result.start.assign(\"month\", date.getMonth() + 1);\n            result.start.assign(\"year\", date.getFullYear());\n        } else {\n            result.start.imply(\"day\", date.getDate());\n            result.start.imply(\"month\", date.getMonth() + 1);\n            result.start.imply(\"year\", date.getFullYear());\n        }\n\n        return result;\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\nexport default class ZHHantMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(至|到|\\-|\\~|～|－|ー)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\nexport default class ZHHantMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n}\n", "/**\n * Chrono components for zh support\n * TODO: Complete general zh support (current support only zh-Hant)\n */\n\nimport ExtractTimezoneOffsetRefiner from \"../../../common/refiners/ExtractTimezoneOffsetRefiner\";\nimport { includeCommonConfiguration } from \"../../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../../types\";\nimport ZHHantCasualDateParser from \"./parsers/ZHHantCasualDateParser\";\nimport ZHHantDateParser from \"./parsers/ZHHantDateParser\";\nimport ZHHantDeadlineFormatParser from \"./parsers/ZHHantDeadlineFormatParser\";\nimport ZHHantRelationWeekdayParser from \"./parsers/ZHHantRelationWeekdayParser\";\nimport ZHHantTimeExpressionParser from \"./parsers/ZHHantTimeExpressionParser\";\nimport ZHHantWeekdayParser from \"./parsers/ZHHantWeekdayParser\";\nimport ZHHantMergeDateRangeRefiner from \"./refiners/ZHHantMergeDateRangeRefiner\";\nimport ZHHantMergeDateTimeRefiner from \"./refiners/ZHHantMergeDateTimeRefiner\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const hant = new Chrono(createCasualConfiguration());\n\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new ZHHantCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    const configuration = includeCommonConfiguration({\n        parsers: [\n            new ZHHantDateParser(),\n            new ZHHantRelationWeekdayParser(),\n            new ZHHantWeekdayParser(),\n            new ZHHantTimeExpressionParser(),\n            new ZHHantDeadlineFormatParser(),\n        ],\n        refiners: [new ZHHantMergeDateRangeRefiner(), new ZHHantMergeDateTimeRefiner()],\n    });\n\n    // REMOVE ExtractTimezoneOffsetRefiner\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)\n    );\n\n    return configuration;\n}\n", "/**\n * Chrono components for zh support\n */\n\nimport ExtractTimezoneOffsetRefiner from \"../../../common/refiners/ExtractTimezoneOffsetRefiner\";\nimport { includeCommonConfiguration } from \"../../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../../types\";\nimport ZHHansCasualDateParser from \"./parsers/ZHHansCasualDateParser\";\nimport ZHHansDateParser from \"./parsers/ZHHansDateParser\";\nimport ZHHansDeadlineFormatParser from \"./parsers/ZHHansDeadlineFormatParser\";\nimport ZHHansRelationWeekdayParser from \"./parsers/ZHHansRelationWeekdayParser\";\nimport ZHHansTimeExpressionParser from \"./parsers/ZHHansTimeExpressionParser\";\nimport ZHHansWeekdayParser from \"./parsers/ZHHansWeekdayParser\";\nimport ZHHansMergeDateRangeRefiner from \"./refiners/ZHHansMergeDateRangeRefiner\";\nimport ZHHansMergeDateTimeRefiner from \"./refiners/ZHHansMergeDateTimeRefiner\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const hans = new Chrono(createCasualConfiguration());\n\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration());\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration();\n    option.parsers.unshift(new ZHHansCasualDateParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(): Configuration {\n    const configuration = includeCommonConfiguration({\n        parsers: [\n            new ZHHansDateParser(),\n            new ZHHansRelationWeekdayParser(),\n            new ZHHansWeekdayParser(),\n            new ZHHansTimeExpressionParser(),\n            new ZHHansDeadlineFormatParser(),\n        ],\n        refiners: [new ZHHansMergeDateRangeRefiner(), new ZHHansMergeDateTimeRefiner()],\n    });\n\n    // REMOVE ExtractTimezoneOffsetRefiner\n    configuration.refiners = configuration.refiners.filter(\n        (refiner) => !(refiner instanceof ExtractTimezoneOffsetRefiner)\n    );\n\n    return configuration;\n}\n", "import { ParsingContext } from \"../../../../chrono\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { ParsingComponents, ParsingResult } from \"../../../../results\";\n\nconst NOW_GROUP = 1;\nconst DAY_GROUP_1 = 2;\nconst TIME_GROUP_1 = 3;\nconst TIME_GROUP_2 = 4;\nconst DAY_GROUP_3 = 5;\nconst TIME_GROUP_3 = 6;\n\nexport default class ZHHansCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(\n            \"(现在|立(?:刻|即)|即刻)|\" +\n                \"(今|明|前|大前|后|大后|昨)(早|晚)|\" +\n                \"(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|\" +\n                \"(今|明|前|大前|后|大后|昨)(?:日|天)\" +\n                \"(?:[\\\\s|,|，]*)\" +\n                \"(?:(上(?:午)|早(?:上)|下(?:午)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?\",\n            \"i\"\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const index = match.index;\n        const result = context.createParsingResult(index, match[0]);\n\n        const refDate = context.refDate;\n        let date = new Date(refDate.getTime());\n\n        if (match[NOW_GROUP]) {\n            result.start.imply(\"hour\", refDate.getHours());\n            result.start.imply(\"minute\", refDate.getMinutes());\n            result.start.imply(\"second\", refDate.getSeconds());\n            result.start.imply(\"millisecond\", refDate.getMilliseconds());\n        } else if (match[DAY_GROUP_1]) {\n            const day1 = match[DAY_GROUP_1];\n            const time1 = match[TIME_GROUP_1];\n\n            if (day1 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (refDate.getHours() > 1) {\n                    date.setDate(date.getDate() + 1);\n                }\n            } else if (day1 == \"昨\") {\n                date.setDate(date.getDate() - 1);\n            } else if (day1 == \"前\") {\n                date.setDate(date.getDate() - 2);\n            } else if (day1 == \"大前\") {\n                date.setDate(date.getDate() - 3);\n            } else if (day1 == \"后\") {\n                date.setDate(date.getDate() + 2);\n            } else if (day1 == \"大后\") {\n                date.setDate(date.getDate() + 3);\n            }\n\n            if (time1 == \"早\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time1 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            }\n        } else if (match[TIME_GROUP_2]) {\n            const timeString2 = match[TIME_GROUP_2];\n            const time2 = timeString2[0];\n            if (time2 == \"早\" || time2 == \"上\") {\n                result.start.imply(\"hour\", 6);\n            } else if (time2 == \"下\") {\n                result.start.imply(\"hour\", 15);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"中\") {\n                result.start.imply(\"hour\", 12);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"夜\" || time2 == \"晚\") {\n                result.start.imply(\"hour\", 22);\n                result.start.imply(\"meridiem\", 1);\n            } else if (time2 == \"凌\") {\n                result.start.imply(\"hour\", 0);\n            }\n        } else if (match[DAY_GROUP_3]) {\n            const day3 = match[DAY_GROUP_3];\n\n            if (day3 == \"明\") {\n                // Check not \"Tomorrow\" on late night\n                if (refDate.getHours() > 1) {\n                    date.setDate(date.getDate() + 1);\n                }\n            } else if (day3 == \"昨\") {\n                date.setDate(date.getDate() - 1);\n            } else if (day3 == \"前\") {\n                date.setDate(date.getDate() - 2);\n            } else if (day3 == \"大前\") {\n                date.setDate(date.getDate() - 3);\n            } else if (day3 == \"后\") {\n                date.setDate(date.getDate() + 2);\n            } else if (day3 == \"大后\") {\n                date.setDate(date.getDate() + 3);\n            }\n\n            const timeString3 = match[TIME_GROUP_3];\n            if (timeString3) {\n                const time3 = timeString3[0];\n                if (time3 == \"早\" || time3 == \"上\") {\n                    result.start.imply(\"hour\", 6);\n                } else if (time3 == \"下\") {\n                    result.start.imply(\"hour\", 15);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"中\") {\n                    result.start.imply(\"hour\", 12);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"夜\" || time3 == \"晚\") {\n                    result.start.imply(\"hour\", 22);\n                    result.start.imply(\"meridiem\", 1);\n                } else if (time3 == \"凌\") {\n                    result.start.imply(\"hour\", 0);\n                }\n            }\n        }\n\n        result.start.assign(\"day\", date.getDate());\n        result.start.assign(\"month\", date.getMonth() + 1);\n        result.start.assign(\"year\", date.getFullYear());\n\n        return result;\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\nexport default class ZHHansMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(至|到|-|~|～|－|ー)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\nexport default class ZHHansMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n}\n", "/**\n * Chrono components for Russian support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport RUTimeUnitWithinFormatParser from \"./parsers/RUTimeUnitWithinFormatParser\";\nimport RUMonthNameLittleEndianParser from \"./parsers/RUMonthNameLittleEndianParser\";\nimport RUMonthNameParser from \"./parsers/RUMonthNameParser\";\nimport RUTimeExpressionParser from \"./parsers/RUTimeExpressionParser\";\nimport RUTimeUnitAgoFormatParser from \"./parsers/RUTimeUnitAgoFormatParser\";\nimport RUMergeDateRangeRefiner from \"./refiners/RUMergeDateRangeRefiner\";\nimport RUMergeDateTimeRefiner from \"./refiners/RUMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport RUCasualDateParser from \"./parsers/RUCasualDateParser\";\nimport RUCasualTimeParser from \"./parsers/RUCasualTimeParser\";\nimport RUWeekdayParser from \"./parsers/RUWeekdayParser\";\nimport RURelativeDateFormatParser from \"./parsers/RURelativeDateFormatParser\";\n\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport RUTimeUnitCasualRelativeFormatParser from \"./parsers/RUTimeUnitCasualRelativeFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n/**\n * Chrono object configured for parsing *casual* Russian\n */\nexport const casual = new Chrono(createCasualConfiguration());\n\n/**\n * Chrono object configured for parsing *strict* Russian\n */\nexport const strict = new Chrono(createConfiguration(true));\n\n/**\n * A shortcut for ru.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for ru.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * Create a default *casual* {@Link Configuration} for Russian chrono.\n * It calls {@Link createConfiguration} and includes additional parsers.\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration(false);\n    option.parsers.unshift(new RUCasualDateParser());\n    option.parsers.unshift(new RUCasualTimeParser());\n    option.parsers.unshift(new RUMonthNameParser());\n    option.parsers.unshift(new RURelativeDateFormatParser());\n    option.parsers.unshift(new RUTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * Create a default {@Link Configuration} for Russian chrono\n *\n * @param strictMode If the timeunit mentioning should be strict, not casual\n */\nexport function createConfiguration(strictMode = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(true),\n                new RUTimeUnitWithinFormatParser(),\n                new RUMonthNameLittleEndianParser(),\n                new RUWeekdayParser(),\n                new RUTimeExpressionParser(strictMode),\n                new RUTimeUnitAgoFormatParser(),\n            ],\n            refiners: [new RUMergeDateTimeRefiner(), new RUMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit } from \"../../types\";\n\nexport const REGEX_PARTS = {\n    leftBoundary: \"([^\\\\p{L}\\\\p{N}_]|^)\",\n    rightBoundary: \"(?=[^\\\\p{L}\\\\p{N}_]|$)\",\n    flags: \"iu\",\n};\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    воскресенье: 0,\n    воскресенья: 0,\n    вск: 0,\n    \"вск.\": 0,\n    понедельник: 1,\n    понедельника: 1,\n    пн: 1,\n    \"пн.\": 1,\n    вторник: 2,\n    вторника: 2,\n    вт: 2,\n    \"вт.\": 2,\n    среда: 3,\n    среды: 3,\n    среду: 3,\n    ср: 3,\n    \"ср.\": 3,\n    четверг: 4,\n    четверга: 4,\n    чт: 4,\n    \"чт.\": 4,\n    пятница: 5,\n    пятницу: 5,\n    пятницы: 5,\n    пт: 5,\n    \"пт.\": 5,\n    суббота: 6,\n    субботу: 6,\n    субботы: 6,\n    сб: 6,\n    \"сб.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    январь: 1,\n    января: 1,\n    январе: 1,\n    февраль: 2,\n    февраля: 2,\n    феврале: 2,\n    март: 3,\n    марта: 3,\n    марте: 3,\n    апрель: 4,\n    апреля: 4,\n    апреле: 4,\n    май: 5,\n    мая: 5,\n    мае: 5,\n    июнь: 6,\n    июня: 6,\n    июне: 6,\n    июль: 7,\n    июля: 7,\n    июле: 7,\n    август: 8,\n    августа: 8,\n    августе: 8,\n    сентябрь: 9,\n    сентября: 9,\n    сентябре: 9,\n    октябрь: 10,\n    октября: 10,\n    октябре: 10,\n    ноябрь: 11,\n    ноября: 11,\n    ноябре: 11,\n    декабрь: 12,\n    декабря: 12,\n    декабре: 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    янв: 1,\n    \"янв.\": 1,\n    фев: 2,\n    \"фев.\": 2,\n    мар: 3,\n    \"мар.\": 3,\n    апр: 4,\n    \"апр.\": 4,\n    авг: 8,\n    \"авг.\": 8,\n    сен: 9,\n    \"сен.\": 9,\n    окт: 10,\n    \"окт.\": 10,\n    ноя: 11,\n    \"ноя.\": 11,\n    дек: 12,\n    \"дек.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    один: 1,\n    одна: 1,\n    одной: 1,\n    одну: 1,\n    две: 2,\n    два: 2,\n    двух: 2,\n    три: 3,\n    трех: 3,\n    трёх: 3,\n    четыре: 4,\n    четырех: 4,\n    четырёх: 4,\n    пять: 5,\n    пяти: 5,\n    шесть: 6,\n    шести: 6,\n    семь: 7,\n    семи: 7,\n    восемь: 8,\n    восьми: 8,\n    девять: 9,\n    девяти: 9,\n    десять: 10,\n    десяти: 10,\n    одиннадцать: 11,\n    одиннадцати: 11,\n    двенадцать: 12,\n    двенадцати: 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    первое: 1,\n    первого: 1,\n    второе: 2,\n    второго: 2,\n    третье: 3,\n    третьего: 3,\n    четвертое: 4,\n    четвертого: 4,\n    пятое: 5,\n    пятого: 5,\n    шестое: 6,\n    шестого: 6,\n    седьмое: 7,\n    седьмого: 7,\n    восьмое: 8,\n    восьмого: 8,\n    девятое: 9,\n    девятого: 9,\n    десятое: 10,\n    десятого: 10,\n    одиннадцатое: 11,\n    одиннадцатого: 11,\n    двенадцатое: 12,\n    двенадцатого: 12,\n    тринадцатое: 13,\n    тринадцатого: 13,\n    четырнадцатое: 14,\n    четырнадцатого: 14,\n    пятнадцатое: 15,\n    пятнадцатого: 15,\n    шестнадцатое: 16,\n    шестнадцатого: 16,\n    семнадцатое: 17,\n    семнадцатого: 17,\n    восемнадцатое: 18,\n    восемнадцатого: 18,\n    девятнадцатое: 19,\n    девятнадцатого: 19,\n    двадцатое: 20,\n    двадцатого: 20,\n    \"двадцать первое\": 21,\n    \"двадцать первого\": 21,\n    \"двадцать второе\": 22,\n    \"двадцать второго\": 22,\n    \"двадцать третье\": 23,\n    \"двадцать третьего\": 23,\n    \"двадцать четвертое\": 24,\n    \"двадцать четвертого\": 24,\n    \"двадцать пятое\": 25,\n    \"двадцать пятого\": 25,\n    \"двадцать шестое\": 26,\n    \"двадцать шестого\": 26,\n    \"двадцать седьмое\": 27,\n    \"двадцать седьмого\": 27,\n    \"двадцать восьмое\": 28,\n    \"двадцать восьмого\": 28,\n    \"двадцать девятое\": 29,\n    \"двадцать девятого\": 29,\n    \"тридцатое\": 30,\n    \"тридцатого\": 30,\n    \"тридцать первое\": 31,\n    \"тридцать первого\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    сек: \"second\",\n    секунда: \"second\",\n    секунд: \"second\",\n    секунды: \"second\",\n    секунду: \"second\",\n    секундочка: \"second\",\n    секундочки: \"second\",\n    секундочек: \"second\",\n    секундочку: \"second\",\n    мин: \"minute\",\n    минута: \"minute\",\n    минут: \"minute\",\n    минуты: \"minute\",\n    минуту: \"minute\",\n    минуток: \"minute\",\n    минутки: \"minute\",\n    минутку: \"minute\",\n    минуточек: \"minute\",\n    минуточки: \"minute\",\n    минуточку: \"minute\",\n    час: \"hour\",\n    часов: \"hour\",\n    часа: \"hour\",\n    часу: \"hour\",\n    часиков: \"hour\",\n    часика: \"hour\",\n    часике: \"hour\",\n    часик: \"hour\",\n    день: \"day\",\n    дня: \"day\",\n    дней: \"day\",\n    суток: \"day\",\n    сутки: \"day\",\n    неделя: \"week\",\n    неделе: \"week\",\n    недели: \"week\",\n    неделю: \"week\",\n    недель: \"week\",\n    недельке: \"week\",\n    недельки: \"week\",\n    неделек: \"week\",\n    месяц: \"month\",\n    месяце: \"month\",\n    месяцев: \"month\",\n    месяца: \"month\",\n    квартал: \"quarter\",\n    квартале: \"quarter\",\n    кварталов: \"quarter\",\n    год: \"year\",\n    года: \"year\",\n    году: \"year\",\n    годов: \"year\",\n    лет: \"year\",\n    годик: \"year\",\n    годика: \"year\",\n    годиков: \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|пол|несколько|пар(?:ы|у)|\\\\s{0,3})`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    }\n    if (num.match(/несколько/)) {\n        return 3;\n    } else if (num.match(/пол/)) {\n        return 0.5;\n    } else if (num.match(/пар/)) {\n        return 2;\n    } else if (num === \"\") {\n        return 1;\n    }\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:го|ого|е|ое)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n    return parseInt(num);\n}\n\n//-----------------------------\n\nconst year = \"(?:\\\\s+(?:году|года|год|г|г.))?\";\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\\\s*(?:н.э.|до н.э.|н. э.|до н. э.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;\nexport function parseYear(match: string): number {\n    if (/(год|года|г|г.)/i.test(match)) {\n        match = match.replace(/(год|года|г|г.)/i, \"\");\n    }\n\n    if (/(до н.э.|до н. э.)/i.test(match)) {\n        //Before Common Era\n        match = match.replace(/(до н.э.|до н. э.)/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(н. э.|н.э.)/i.test(match)) {\n        //Common Era\n        match = match.replace(/(н. э.|н.э.)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:около|примерно)\\\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = `(?:(?:около|примерно)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})${REGEX_PARTS.rightBoundary}`;\n\nexport default class RUTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return context.option.forwardDate\n            ? new RegExp(PATTERN, REGEX_PARTS.flags)\n            : new RegExp(`(?:в течение|в течении)\\\\s*${PATTERN}`, REGEX_PARTS.flags);\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport abstract class AbstractParserWithLeftBoundaryChecking extends AbstractParserWithWordBoundaryChecking {\n    abstract innerPatternString(context: ParsingContext): string;\n\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);\n    }\n\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return false;\n    }\n}\n\nexport abstract class AbstractParserWithLeftRightBoundaryChecking extends AbstractParserWithLeftBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class RUMonthNameLittleEndianParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        // prettier-ignore\n        return `(?:с)?\\\\s*(${ORDINAL_NUMBER_PATTERN})` +\n            `(?:` +\n                `\\\\s{0,3}(?:по|-|–|до)?\\\\s{0,3}` +\n                `(${ORDINAL_NUMBER_PATTERN})` +\n            `)?` +\n                `(?:-|\\\\/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n                `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `(?:` +\n                `(?:-|\\\\/|,?\\\\s{0,3})` +\n                `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n            `)?`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - Январь, 2012\n * - Январь 2012\n * - Январь\n */\nexport default class RUMonthNameParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `((?:в)\\\\s*)?` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `\\\\s*` +\n            `(?:` +\n            `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n            `)?` +\n            `(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"янв\", \"фер\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match.index + match[0].length);\n        result.start.imply(\"day\", 1);\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { REGEX_PARTS } from \"../constants\";\n\nexport default class RUTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    patternFlags(): string {\n        return REGEX_PARTS.flags;\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|(?:[^\\\\p{L}\\\\p{N}_]))`;\n    }\n\n    followingPhase(): string {\n        return `\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|до|и|по|\\\\?)\\\\s*`;\n    }\n\n    primaryPrefix(): string {\n        return `(?:(?:в|с)\\\\s*)??`;\n    }\n\n    primarySuffix(): string {\n        return `(?:\\\\s*(?:утра|вечера|после полудня))?(?!\\\\/)${REGEX_PARTS.rightBoundary}`;\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (components) {\n            if (match[0].endsWith(\"вечера\")) {\n                const hour = components.get(\"hour\");\n                if (hour >= 6 && hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                } else if (hour < 6) {\n                    components.assign(\"meridiem\", Meridiem.AM);\n                }\n            }\n\n            if (match[0].endsWith(\"после полудня\")) {\n                components.assign(\"meridiem\", Meridiem.PM);\n                const hour = components.get(\"hour\");\n                if (hour >= 0 && hour <= 6) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                }\n            }\n\n            if (match[0].endsWith(\"утра\")) {\n                components.assign(\"meridiem\", Meridiem.AM);\n                const hour = components.get(\"hour\");\n                if (hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\"));\n                }\n            }\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class RUTimeUnitAgoFormatParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(${TIME_UNITS_PATTERN})\\\\s{0,5}назад(?=(?:\\\\W|$))`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseDuration(match[1]);\n        const outputTimeUnits = reverseDuration(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Russian connecting phases\n * - c 06.09.1989 [до|по] 11.12.1996\n * - c пятницы и до среды\n */\nexport default class RUMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(и до|и по|до|по|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide Russian connecting phases\n * - 2020-02-13 [в] 6:00\n * - Завтра [,] 7:00\n */\nexport default class RUMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(`^\\\\s*(T|в|,|-)?\\\\s*$`);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport * as references from \"../../../common/casualReferences\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class RUCasualDateParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(?:с|со)?\\\\s*(сегодня|вчера|завтра|послезавтра|послепослезавтра|позапозавчера|позавчера)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[1].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"сегодня\":\n                return references.today(context.reference);\n\n            case \"вчера\":\n                return references.yesterday(context.reference);\n\n            case \"завтра\":\n                return references.tomorrow(context.reference);\n\n            case \"послезавтра\":\n                return references.theDayAfter(context.reference, 2);\n\n            case \"послепослезавтра\":\n                return references.theDayAfter(context.reference, 3);\n\n            case \"позавчера\":\n                return references.theDayBefore(context.reference, 2);\n\n            case \"позапозавчера\":\n                return references.theDayBefore(context.reference, 3);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport * as references from \"../../../common/casualReferences\";\nimport { assignSimilarDate } from \"../../../utils/dates\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class RUCasualTimeParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(сейчас|прошлым\\\\s*вечером|прошлой\\\\s*ночью|следующей\\\\s*ночью|сегодня\\\\s*ночью|этой\\\\s*ночью|ночью|этим утром|утром|утра|в\\\\s*полдень|вечером|вечера|в\\\\s*полночь)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let targetDate = context.refDate;\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        if (lowerText === \"сейчас\") {\n            return references.now(context.reference);\n        }\n        if (lowerText === \"вечером\" || lowerText === \"вечера\") {\n            return references.evening(context.reference);\n        }\n        if (lowerText.endsWith(\"утром\") || lowerText.endsWith(\"утра\")) {\n            return references.morning(context.reference);\n        }\n        if (lowerText.match(/в\\s*полдень/)) {\n            return references.noon(context.reference);\n        }\n        if (lowerText.match(/прошлой\\s*ночью/)) {\n            return references.lastNight(context.reference);\n        }\n        if (lowerText.match(/прошлым\\s*вечером/)) {\n            return references.yesterdayEvening(context.reference);\n        }\n        if (lowerText.match(/следующей\\s*ночью/)) {\n            const daysToAdd = targetDate.getHours() < 22 ? 1 : 2;\n            const nextDay = new Date(targetDate.getTime());\n            nextDay.setDate(nextDay.getDate() + daysToAdd);\n            assignSimilarDate(component, nextDay);\n            component.imply(\"hour\", 0);\n        }\n        if (lowerText.match(/в\\s*полночь/) || lowerText.endsWith(\"ночью\")) {\n            return references.midnight(context.reference);\n        }\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class RUWeekdayParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:(?:,|\\\\(|（)\\\\s*)?` +\n            `(?:в\\\\s*?)?` +\n            `(?:(эту|этот|прошлый|прошлую|следующий|следующую|следующего)\\\\s*)?` +\n            `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n            `(?:\\\\s*(?:,|\\\\)|）))?` +\n            `(?:\\\\s*на\\\\s*(этой|прошлой|следующей)\\\\s*неделе)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"прошлый\" || modifierWord == \"прошлую\" || modifierWord == \"прошлой\") {\n            modifier = \"last\";\n        } else if (\n            modifierWord == \"следующий\" ||\n            modifierWord == \"следующую\" ||\n            modifierWord == \"следующей\" ||\n            modifierWord == \"следующего\"\n        ) {\n            modifier = \"next\";\n        } else if (modifierWord == \"этот\" || modifierWord == \"эту\" || modifierWord == \"этой\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class RURelativeDateFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(в прошлом|на прошлой|на следующей|в следующем|на этой|в этом)\\\\s*(${matchAnyPattern(\n            TIME_UNIT_DICTIONARY\n        )})`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"на следующей\" || modifier == \"в следующем\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"в прошлом\" || modifier == \"на прошлой\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = new Date(context.reference.instant.getTime());\n\n        // This week\n        if (timeunit.match(/week/i)) {\n            date.setDate(date.getDate() - date.getDay());\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.imply(\"year\", date.getFullYear());\n        }\n\n        // This month\n        else if (timeunit.match(/month/i)) {\n            date.setDate(1);\n            components.imply(\"day\", date.getDate());\n            components.assign(\"year\", date.getFullYear());\n            components.assign(\"month\", date.getMonth() + 1);\n        }\n\n        // This year\n        else if (timeunit.match(/year/i)) {\n            date.setDate(1);\n            date.setMonth(0);\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.assign(\"year\", date.getFullYear());\n        }\n\n        return components;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class RUTimeUnitCasualRelativeFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(эти|последние|прошлые|следующие|после|спустя|через|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[1].toLowerCase();\n        let timeUnits = parseDuration(match[2]);\n        switch (prefix) {\n            case \"последние\":\n            case \"прошлые\":\n            case \"-\":\n                timeUnits = reverseDuration(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Spanish support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ESWeekdayParser from \"./parsers/ESWeekdayParser\";\nimport ESTimeExpressionParser from \"./parsers/ESTimeExpressionParser\";\nimport ESMergeDateTimeRefiner from \"./refiners/ESMergeDateTimeRefiner\";\nimport ESMergeDateRangeRefiner from \"./refiners/ESMergeDateRangeRefiner\";\nimport ESMonthNameLittleEndianParser from \"./parsers/ESMonthNameLittleEndianParser\";\nimport ESCasualDateParser from \"./parsers/ESCasualDateParser\";\nimport ESCasualTimeParser from \"./parsers/ESCasualTimeParser\";\nimport ESTimeUnitWithinFormatParser from \"./parsers/ESTimeUnitWithinFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.push(new ESCasualDateParser());\n    option.parsers.push(new ESCasualTimeParser());\n    return option;\n}\n\n/**\n * @ignore (to be documented later)\n */\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new ESWeekdayParser(),\n                new ESTimeExpressionParser(),\n                new ESMonthNameLittleEndianParser(),\n                new ESTimeUnitWithinFormatParser(),\n            ],\n            refiners: [new ESMergeDateTimeRefiner(), new ESMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { Timeunit } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"domingo\": 0,\n    \"dom\": 0,\n    \"lunes\": 1,\n    \"lun\": 1,\n    \"martes\": 2,\n    \"mar\": 2,\n    \"miércoles\": 3,\n    \"miercoles\": 3,\n    \"mié\": 3,\n    \"mie\": 3,\n    \"jueves\": 4,\n    \"jue\": 4,\n    \"viernes\": 5,\n    \"vie\": 5,\n    \"sábado\": 6,\n    \"sabado\": 6,\n    \"sáb\": 6,\n    \"sab\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"enero\": 1,\n    \"ene\": 1,\n    \"ene.\": 1,\n    \"febrero\": 2,\n    \"feb\": 2,\n    \"feb.\": 2,\n    \"marzo\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"abril\": 4,\n    \"abr\": 4,\n    \"abr.\": 4,\n    \"mayo\": 5,\n    \"may\": 5,\n    \"may.\": 5,\n    \"junio\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"julio\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"agosto\": 8,\n    \"ago\": 8,\n    \"ago.\": 8,\n    \"septiembre\": 9,\n    \"setiembre\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"octubre\": 10,\n    \"oct\": 10,\n    \"oct.\": 10,\n    \"noviembre\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"diciembre\": 12,\n    \"dic\": 12,\n    \"dic.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"uno\": 1,\n    \"dos\": 2,\n    \"tres\": 3,\n    \"cuatro\": 4,\n    \"cinco\": 5,\n    \"seis\": 6,\n    \"siete\": 7,\n    \"ocho\": 8,\n    \"nueve\": 9,\n    \"diez\": 10,\n    \"once\": 11,\n    \"doce\": 12,\n    \"trece\": 13,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    \"sec\": \"second\",\n    \"segundo\": \"second\",\n    \"segundos\": \"second\",\n    \"min\": \"minute\",\n    \"mins\": \"minute\",\n    \"minuto\": \"minute\",\n    \"minutos\": \"minute\",\n    \"h\": \"hour\",\n    \"hr\": \"hour\",\n    \"hrs\": \"hour\",\n    \"hora\": \"hour\",\n    \"horas\": \"hour\",\n    \"día\": \"day\",\n    \"días\": \"day\",\n    \"semana\": \"week\",\n    \"semanas\": \"week\",\n    \"mes\": \"month\",\n    \"meses\": \"month\",\n    \"cuarto\": \"quarter\",\n    \"cuartos\": \"quarter\",\n    \"año\": \"year\",\n    \"años\": \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|un?|uno?|una?|algunos?|unos?|demi-?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"un\" || num === \"una\" || num === \"uno\") {\n        return 1;\n    } else if (num.match(/algunos?/)) {\n        return 3;\n    } else if (num.match(/unos?/)) {\n        return 3;\n    } else if (num.match(/media?/)) {\n        return 0.5;\n    }\n\n    return parseFloat(num);\n}\n//-----------------------------\n// 88 p. Chr. n.\n// 234 AC\nexport const YEAR_PATTERN = \"[0-9]{1,4}(?![^\\\\s]\\\\d)(?:\\\\s*[a|d]\\\\.?\\\\s*c\\\\.?|\\\\s*a\\\\.?\\\\s*d\\\\.?)?\";\nexport function parseYear(match: string): number {\n    if (match.match(/^[0-9]{1,4}$/)) {\n        let yearNumber = parseInt(match);\n        if (yearNumber < 100) {\n            if (yearNumber > 50) {\n                yearNumber = yearNumber + 1900;\n            } else {\n                yearNumber = yearNumber + 2000;\n            }\n        }\n        return yearNumber;\n    }\n\n    if (match.match(/a\\.?\\s*c\\.?/i)) {\n        match = match.replace(/a\\.?\\s*c\\.?/i, \"\");\n        return -parseInt(match);\n    }\n\n    return parseInt(match);\n}\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\n\nimport { Duration } from \"../../calculation/duration\";\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:(este|esta|pasado|pr[oó]ximo)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(este|esta|pasado|pr[óo]ximo)\\\\s*semana)?\" +\n        \"(?=\\\\W|\\\\d|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ESWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        if (weekday === undefined) {\n            return null;\n        }\n\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let norm = prefix || postfix || \"\";\n        norm = norm.toLowerCase();\n\n        let modifier = null;\n        if (norm == \"pasado\") {\n            modifier = \"this\";\n        } else if (norm == \"próximo\" || norm == \"proximo\") {\n            modifier = \"next\";\n        } else if (norm == \"este\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class ESTimeExpressionParser extends AbstractTimeExpressionParser {\n    primaryPrefix(): string {\n        return \"(?:(?:aslas|deslas|las?|al?|de|del)\\\\s*)?\";\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|a(?:l)?|\\\\?)\\\\s*\";\n    }\n\n    // extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | null {\n    //     // This looks more like a year e.g. 2020\n    //     // if (match[0].match(/^\\s*\\d{4}\\s*$/)) {\n    //     //     return null;\n    //     // }\n    //\n    //     return super.extractPrimaryTimeComponents(context, match);\n    // }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n */\nexport default class ESMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(?:,|de|aslas|a)?\\\\s*$\");\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n *\n */\nexport default class ESMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(?:-)\\s*$/i;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `([0-9]{1,2})(?:º|ª|°)?` +\n        \"(?:\\\\s*(?:desde|de|\\\\-|\\\\–|ao?|\\\\s)\\\\s*([0-9]{1,2})(?:º|ª|°)?)?\\\\s*(?:de)?\\\\s*\" +\n        `(?:-|/|\\\\s*(?:de|,)?\\\\s*)` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:\\\\s*(?:de|,)?\\\\s*(${YEAR_PATTERN}))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ESMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport * as references from \"../../../common/casualReferences\";\n\nexport default class ESCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return /(ahora|hoy|mañana|ayer)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"ahora\":\n                return references.now(context.reference);\n\n            case \"hoy\":\n                return references.today(context.reference);\n\n            case \"mañana\":\n                return references.tomorrow(context.reference);\n\n            case \"ayer\":\n                return references.yesterday(context.reference);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\n\nexport default class ESCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return /(?:esta\\s*)?(mañana|tarde|medianoche|mediodia|mediodía|noche)(?=\\W|$)/i;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = context.refDate;\n        const component = context.createParsingComponents();\n        switch (match[1].toLowerCase()) {\n            case \"tarde\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"noche\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 22);\n                break;\n\n            case \"mañana\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"medianoche\":\n                const nextDay = new Date(targetDate.getTime());\n                nextDay.setDate(nextDay.getDate() + 1);\n                assignSimilarDate(component, nextDay);\n                implySimilarTime(component, nextDay);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"mediodia\":\n            case \"mediodía\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nexport default class ESTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return new RegExp(`(?:en|por|durante|de|dentro de)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`, \"i\");\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Ukrainian support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport UKTimeUnitWithinFormatParser from \"./parsers/UKTimeUnitWithinFormatParser\";\nimport UKMonthNameLittleEndianParser from \"./parsers/UKMonthNameLittleEndianParser\";\nimport UkMonthNameParser from \"./parsers/UKMonthNameParser\";\nimport UKTimeExpressionParser from \"./parsers/UKTimeExpressionParser\";\nimport UKTimeUnitAgoFormatParser from \"./parsers/UKTimeUnitAgoFormatParser\";\nimport UKMergeDateRangeRefiner from \"./refiners/UKMergeDateRangeRefiner\";\nimport UKMergeDateTimeRefiner from \"./refiners/UKMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport UKCasualDateParser from \"./parsers/UKCasualDateParser\";\nimport UKCasualTimeParser from \"./parsers/UKCasualTimeParser\";\nimport UKWeekdayParser from \"./parsers/UKWeekdayParser\";\nimport UKRelativeDateFormatParser from \"./parsers/UKRelativeDateFormatParser\";\n\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport UKTimeUnitCasualRelativeFormatParser from \"./parsers/UKTimeUnitCasualRelativeFormatParser\";\nimport ISOFormatParser from \"../../common/parsers/ISOFormatParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n/**\n * Chrono object configured for parsing *casual* Ukrainian\n */\nexport const casual = new Chrono(createCasualConfiguration());\n\n/**\n * Chrono object configured for parsing *strict* Ukrainian\n */\nexport const strict = new Chrono(createConfiguration(true));\n\n/**\n * Create a default *casual* {@Link Configuration} for Ukrainian chrono.\n * It calls {@Link createConfiguration} and includes additional parsers.\n */\nexport function createCasualConfiguration(): Configuration {\n    const option = createConfiguration(false);\n    option.parsers.unshift(new UKCasualDateParser());\n    option.parsers.unshift(new UKCasualTimeParser());\n    option.parsers.unshift(new UkMonthNameParser());\n    option.parsers.unshift(new UKRelativeDateFormatParser());\n    option.parsers.unshift(new UKTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * Create a default {@Link Configuration} for Ukrainian chrono\n *\n * @param strictMode If the timeunit mentioning should be strict, not casual\n */\nexport function createConfiguration(strictMode: boolean): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new ISOFormatParser(),\n                new SlashDateFormatParser(true),\n                new UKTimeUnitWithinFormatParser(),\n                new UKMonthNameLittleEndianParser(),\n                new UKWeekdayParser(),\n                new UKTimeExpressionParser(strictMode),\n                new UKTimeUnitAgoFormatParser(),\n            ],\n            refiners: [new UKMergeDateTimeRefiner(), new UKMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n\n/**\n * A shortcut for uk.casual.parse()\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for uk.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit } from \"../../types\";\n\nexport const REGEX_PARTS = {\n    leftBoundary: \"([^\\\\p{L}\\\\p{N}_]|^)\",\n    rightBoundary: \"(?=[^\\\\p{L}\\\\p{N}_]|$)\",\n    flags: \"iu\",\n};\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"неділя\": 0,\n    \"неділі\": 0,\n    \"неділю\": 0,\n    \"нд\": 0,\n    \"нд.\": 0,\n    \"понеділок\": 1,\n    \"понеділка\": 1,\n    \"пн\": 1,\n    \"пн.\": 1,\n    \"вівторок\": 2,\n    \"вівторка\": 2,\n    \"вт\": 2,\n    \"вт.\": 2,\n    \"середа\": 3,\n    \"середи\": 3,\n    \"середу\": 3,\n    \"ср\": 3,\n    \"ср.\": 3,\n    \"четвер\": 4,\n    \"четверга\": 4,\n    \"четвергу\": 4,\n    \"чт\": 4,\n    \"чт.\": 4,\n    \"п'ятниця\": 5,\n    \"п'ятниці\": 5,\n    \"п'ятницю\": 5,\n    \"пт\": 5,\n    \"пт.\": 5,\n    \"субота\": 6,\n    \"суботи\": 6,\n    \"суботу\": 6,\n    \"сб\": 6,\n    \"сб.\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {\n    \"січень\": 1,\n    \"січня\": 1,\n    \"січні\": 1,\n    \"лютий\": 2,\n    \"лютого\": 2,\n    \"лютому\": 2,\n    \"березень\": 3,\n    \"березня\": 3,\n    \"березні\": 3,\n    \"квітень\": 4,\n    \"квітня\": 4,\n    \"квітні\": 4,\n    \"травень\": 5,\n    \"травня\": 5,\n    \"травні\": 5,\n    \"червень\": 6,\n    \"червня\": 6,\n    \"червні\": 6,\n    \"липень\": 7,\n    \"липня\": 7,\n    \"липні\": 7,\n    \"серпень\": 8,\n    \"серпня\": 8,\n    \"серпні\": 8,\n    \"вересень\": 9,\n    \"вересня\": 9,\n    \"вересні\": 9,\n    \"жовтень\": 10,\n    \"жовтня\": 10,\n    \"жовтні\": 10,\n    \"листопад\": 11,\n    \"листопада\": 11,\n    \"листопаду\": 11,\n    \"грудень\": 12,\n    \"грудня\": 12,\n    \"грудні\": 12,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    \"січ\": 1,\n    \"січ.\": 1,\n    \"лют\": 2,\n    \"лют.\": 2,\n    \"бер\": 3,\n    \"бер.\": 3,\n    \"квіт\": 4,\n    \"квіт.\": 4,\n    \"трав\": 5,\n    \"трав.\": 5,\n    \"черв\": 6,\n    \"черв.\": 6,\n    \"лип\": 7,\n    \"лип.\": 7,\n    \"серп\": 8,\n    \"серп.\": 8,\n    \"сер\": 8,\n    \"cер.\": 8,\n    \"вер\": 9,\n    \"вер.\": 9,\n    \"верес\": 9,\n    \"верес.\": 9,\n    \"жовт\": 10,\n    \"жовт.\": 10,\n    \"листоп\": 11,\n    \"листоп.\": 11,\n    \"груд\": 12,\n    \"груд.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"один\": 1,\n    \"одна\": 1,\n    \"одної\": 1,\n    \"одну\": 1,\n    \"дві\": 2,\n    \"два\": 2,\n    \"двох\": 2,\n    \"три\": 3,\n    \"трьох\": 3,\n    \"чотири\": 4,\n    \"чотирьох\": 4,\n    \"п'ять\": 5,\n    \"п'яти\": 5,\n    \"шість\": 6,\n    \"шести\": 6,\n    \"сім\": 7,\n    \"семи\": 7,\n    \"вісім\": 8,\n    \"восьми\": 8,\n    \"дев'ять\": 9,\n    \"дев'яти\": 9,\n    \"десять\": 10,\n    \"десяти\": 10,\n    \"одинадцять\": 11,\n    \"одинадцяти\": 11,\n    \"дванадцять\": 12,\n    \"дванадцяти\": 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    \"перше\": 1,\n    \"першого\": 1,\n    \"друге\": 2,\n    \"другого\": 2,\n    \"третє\": 3,\n    \"третього\": 3,\n    \"четверте\": 4,\n    \"четвертого\": 4,\n    \"п'яте\": 5,\n    \"п'ятого\": 5,\n    \"шосте\": 6,\n    \"шостого\": 6,\n    \"сьоме\": 7,\n    \"сьомого\": 7,\n    \"восьме\": 8,\n    \"восьмого\": 8,\n    \"дев'яте\": 9,\n    \"дев'ятого\": 9,\n    \"десяте\": 10,\n    \"десятого\": 10,\n    \"одинадцяте\": 11,\n    \"одинадцятого\": 11,\n    \"дванадцяте\": 12,\n    \"дванадцятого\": 12,\n    \"тринадцяте\": 13,\n    \"тринадцятого\": 13,\n    \"чотирнадцяте\": 14,\n    \"чотинрнадцятого\": 14,\n    \"п'ятнадцяте\": 15,\n    \"п'ятнадцятого\": 15,\n    \"шістнадцяте\": 16,\n    \"шістнадцятого\": 16,\n    \"сімнадцяте\": 17,\n    \"сімнадцятого\": 17,\n    \"вісімнадцяте\": 18,\n    \"вісімнадцятого\": 18,\n    \"дев'ятнадцяте\": 19,\n    \"дев'ятнадцятого\": 19,\n    \"двадцяте\": 20,\n    \"двадцятого\": 20,\n    \"двадцять перше\": 21,\n    \"двадцять першого\": 21,\n    \"двадцять друге\": 22,\n    \"двадцять другого\": 22,\n    \"двадцять третє\": 23,\n    \"двадцять третього\": 23,\n    \"двадцять четверте\": 24,\n    \"двадцять четвертого\": 24,\n    \"двадцять п'яте\": 25,\n    \"двадцять п'ятого\": 25,\n    \"двадцять шосте\": 26,\n    \"двадцять шостого\": 26,\n    \"двадцять сьоме\": 27,\n    \"двадцять сьомого\": 27,\n    \"двадцять восьме\": 28,\n    \"двадцять восьмого\": 28,\n    \"двадцять дев'яте\": 29,\n    \"двадцять дев'ятого\": 29,\n    \"тридцяте\": 30,\n    \"тридцятого\": 30,\n    \"тридцять перше\": 31,\n    \"тридцять першого\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    сек: \"second\",\n    секунда: \"second\",\n    секунд: \"second\",\n    секунди: \"second\",\n    секунду: \"second\",\n    секундочок: \"second\",\n    секундочки: \"second\",\n    секундочку: \"second\",\n    хв: \"minute\",\n    хвилина: \"minute\",\n    хвилин: \"minute\",\n    хвилини: \"minute\",\n    хвилину: \"minute\",\n    хвилинок: \"minute\",\n    хвилинки: \"minute\",\n    хвилинку: \"minute\",\n    хвилиночок: \"minute\",\n    хвилиночки: \"minute\",\n    хвилиночку: \"minute\",\n    год: \"hour\",\n    година: \"hour\",\n    годин: \"hour\",\n    години: \"hour\",\n    годину: \"hour\",\n    годинка: \"hour\",\n    годинок: \"hour\",\n    годинки: \"hour\",\n    годинку: \"hour\",\n    день: \"day\",\n    дня: \"day\",\n    днів: \"day\",\n    дні: \"day\",\n    доба: \"day\",\n    добу: \"day\",\n    тиждень: \"week\",\n    тижню: \"week\",\n    тижня: \"week\",\n    тижні: \"week\",\n    тижнів: \"week\",\n    місяць: \"month\",\n    місяців: \"month\",\n    місяці: \"month\",\n    місяця: \"month\",\n    квартал: \"quarter\",\n    кварталу: \"quarter\",\n    квартала: \"quarter\",\n    кварталів: \"quarter\",\n    кварталі: \"quarter\",\n    рік: \"year\",\n    року: \"year\",\n    році: \"year\",\n    років: \"year\",\n    роки: \"year\",\n};\n\n//--------------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|пів|декілька|пар(?:у)|\\\\s{0,3})`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    }\n    if (num.match(/декілька/)) {\n        return 2;\n    } else if (num.match(/пів/)) {\n        return 0.5;\n    } else if (num.match(/пар/)) {\n        return 2;\n    } else if (num === \"\") {\n        return 1;\n    }\n    return parseFloat(num);\n}\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_WORD_DICTIONARY)}|[0-9]{1,2}(?:го|ого|е)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n    return parseInt(num);\n}\n\nconst year = \"(?:\\\\s+(?:року|рік|р|р.))?\";\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}${year}\\\\s*(?:н.е.|до н.е.|н. е.|до н. е.)|[1-2][0-9]{3}${year}|[5-9][0-9]${year})`;\nexport function parseYearPattern(match: string): number {\n    if (/(рік|року|р|р.)/i.test(match)) {\n        match = match.replace(/(рік|року|р|р.)/i, \"\");\n    }\n\n    if (/(до н.е.|до н. е.)/i.test(match)) {\n        //Before Common Era\n        match = match.replace(/(до н.е.|до н. е.)/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(н. е.|н.е.)/i.test(match)) {\n        //Common Era\n        match = match.replace(/(н. е.|н.е.)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\n    `(?:(?:близько|приблизно)\\\\s{0,3})?`,\n    SINGLE_TIME_UNIT_PATTERN\n);\n\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = `(?:(?:приблизно|орієнтовно)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})${REGEX_PARTS.rightBoundary}`;\n\nexport default class UKTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return context.option.forwardDate\n            ? new RegExp(PATTERN, \"i\")\n            : new RegExp(`(?:протягом|на протязі|протягом|упродовж|впродовж)\\\\s*${PATTERN}`, REGEX_PARTS.flags);\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "// noinspection DuplicatedCode\n\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\n\nexport abstract class AbstractParserWithLeftBoundaryChecking extends AbstractParserWithWordBoundaryChecking {\n    abstract innerPatternString(context: ParsingContext): string;\n\n    patternLeftBoundary(): string {\n        return REGEX_PARTS.leftBoundary;\n    }\n\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(this.innerPatternString(context), REGEX_PARTS.flags);\n    }\n\n    innerPatternHasChange(context: ParsingContext, currentInnerPattern: RegExp): boolean {\n        return false;\n    }\n}\n\nexport abstract class AbstractParserWithLeftRightBoundaryChecking extends AbstractParserWithLeftBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return new RegExp(`${this.innerPatternString(context)}${REGEX_PARTS.rightBoundary}`, REGEX_PARTS.flags);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYearPattern } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class UKMonthNameLittleEndianParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:з|із)?\\\\s*(${ORDINAL_NUMBER_PATTERN})` +\n            `(?:` +\n            `\\\\s{0,3}(?:по|-|–|до)?\\\\s{0,3}` +\n            `(${ORDINAL_NUMBER_PATTERN})` +\n            `)?` +\n            `(?:-|\\\\/|\\\\s{0,3}(?:of)?\\\\s{0,3})` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `(?:` +\n            `(?:-|\\\\/|,?\\\\s{0,3})` +\n            `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n            `)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYearPattern(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.reference.instant, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYearPattern } from \"../constants\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - Cічень, 2012\n * - Січень 2012\n * - Січень\n */\nexport default class UkMonthNameParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `((?:в|у)\\\\s*)?` +\n            `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n            `\\\\s*` +\n            `(?:` +\n            `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n            `)?` +\n            `(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"січ\", \"лют\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(match.index, match.index + match[0].length);\n        result.start.imply(\"day\", 1);\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYearPattern(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.reference.instant, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { Meridiem } from \"../../../types\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\nimport { REGEX_PARTS } from \"../constants\";\n\nexport default class UKTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    patternFlags(): string {\n        return REGEX_PARTS.flags;\n    }\n\n    primaryPatternLeftBoundary(): string {\n        return `(^|\\\\s|T|(?:[^\\\\p{L}\\\\p{N}_]))`;\n    }\n\n    followingPhase(): string {\n        return `\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|до|і|по|\\\\?)\\\\s*`;\n    }\n\n    primaryPrefix(): string {\n        return `(?:(?:в|у|о|об|з|із|від)\\\\s*)??`;\n    }\n\n    primarySuffix(): string {\n        return `(?:\\\\s*(?:ранку|вечора|по обіді|після обіду))?(?!\\\\/)${REGEX_PARTS.rightBoundary}`;\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (components) {\n            if (match[0].endsWith(\"вечора\")) {\n                const hour = components.get(\"hour\");\n                if (hour >= 6 && hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                } else if (hour < 6) {\n                    components.assign(\"meridiem\", Meridiem.AM);\n                }\n            }\n\n            if (match[0].endsWith(\"по обіді\") || match[0].endsWith(\"після обіду\")) {\n                components.assign(\"meridiem\", Meridiem.PM);\n                const hour = components.get(\"hour\");\n                if (hour >= 0 && hour <= 6) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                }\n            }\n\n            if (match[0].endsWith(\"ранку\")) {\n                components.assign(\"meridiem\", Meridiem.AM);\n                const hour = components.get(\"hour\");\n                if (hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\"));\n                }\n            }\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithLeftBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class UKTimeUnitAgoFormatParser extends AbstractParserWithLeftBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(${TIME_UNITS_PATTERN})\\\\s{0,5}тому(?=(?:\\\\W|$))`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseDuration(match[1]);\n        const outputTimeUnits = reverseDuration(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide Russian connecting phases\n * - [з|із] 06.09.1989 [до|по] 11.12.1996\n * - [з|із] п'ятниці і до середи\n */\nexport default class UKMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(і до|і по|до|по|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide Ukrainian connecting phases\n * - 2020-02-13 [в/у/о] 6:00\n * - Завтра [,] 7:00\n */\nexport default class UKMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(`^\\\\s*(T|в|у|о|,|-)?\\\\s*$`);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport * as references from \"../../../common/casualReferences\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class UKCasualDateParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(?:з|із|від)?\\\\s*(сьогодні|вчора|завтра|післязавтра|післяпіслязавтра|позапозавчора|позавчора)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const lowerText = match[1].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"сьогодні\":\n                return references.today(context.reference);\n\n            case \"вчора\":\n                return references.yesterday(context.reference);\n\n            case \"завтра\":\n                return references.tomorrow(context.reference);\n\n            case \"післязавтра\":\n                return references.theDayAfter(context.reference, 2);\n\n            case \"післяпіслязавтра\":\n                return references.theDayAfter(context.reference, 3);\n\n            case \"позавчора\":\n                return references.theDayBefore(context.reference, 2);\n\n            case \"позапозавчора\":\n                return references.theDayBefore(context.reference, 3);\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport * as references from \"../../../common/casualReferences\";\nimport { assignSimilarDate } from \"../../../utils/dates\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nexport default class UKCasualTimeParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(зараз|минулого\\\\s*вечора|минулої\\\\s*ночі|наступної\\\\s*ночі|сьогодні\\\\s*вночі|цієї\\\\s*ночі|цього ранку|вранці|ранку|зранку|опівдні|ввечері|вечора|опівночі|вночі)`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        let targetDate = context.refDate;\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        if (lowerText === \"зараз\") {\n            return references.now(context.reference);\n        }\n        if (lowerText === \"ввечері\" || lowerText === \"вечора\") {\n            return references.evening(context.reference);\n        }\n        if (lowerText.endsWith(\"вранці\") || lowerText.endsWith(\"ранку\") || lowerText.endsWith(\"зранку\")) {\n            return references.morning(context.reference);\n        }\n        if (lowerText.endsWith(\"опівдні\")) {\n            return references.noon(context.reference);\n        }\n        if (lowerText.match(/минулої\\s*ночі/)) {\n            return references.lastNight(context.reference);\n        }\n        if (lowerText.match(/минулого\\s*вечора/)) {\n            return references.yesterdayEvening(context.reference);\n        }\n        if (lowerText.match(/наступної\\s*ночі/)) {\n            const daysToAdd = targetDate.getHours() < 22 ? 1 : 2;\n            const nextDay = new Date(targetDate.getTime());\n            nextDay.setDate(nextDay.getDate() + daysToAdd);\n            assignSimilarDate(component, nextDay);\n            component.imply(\"hour\", 1);\n        }\n        if (lowerText.match(/цієї\\s*ночі/)) {\n            return references.midnight(context.reference);\n        }\n        if (lowerText.endsWith(\"опівночі\") || lowerText.endsWith(\"вночі\")) {\n            return references.midnight(context.reference);\n        }\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\n// TODO: ADD REGEX_PARTS below\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class UKWeekdayParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(?:(?:,|\\\\(|（)\\\\s*)?` +\n            `(?:в\\\\s*?)?` +\n            `(?:у\\\\s*?)?` +\n            `(?:(цей|минулого|минулий|попередній|попереднього|наступного|наступний|наступному)\\\\s*)?` +\n            `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n            `(?:\\\\s*(?:,|\\\\)|）))?` +\n            `(?:\\\\s*(на|у|в)\\\\s*(цьому|минулому|наступному)\\\\s*тижні)?`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLocaleLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLocaleLowerCase();\n\n        let modifier = null;\n        if (\n            modifierWord == \"минулого\" ||\n            modifierWord == \"минулий\" ||\n            modifierWord == \"попередній\" ||\n            modifierWord == \"попереднього\"\n        ) {\n            modifier = \"last\";\n        } else if (modifierWord == \"наступного\" || modifierWord == \"наступний\") {\n            modifier = \"next\";\n        } else if (modifierWord == \"цей\" || modifierWord == \"цього\" || modifierWord == \"цьому\") {\n            modifier = \"this\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class UKRelativeDateFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return (\n            `(в минулому|у минулому|на минулому|минулого|на наступному|в наступному|у наступному|наступного|на цьому|в цьому|у цьому|цього)\\\\s*` +\n            `(${matchAnyPattern(TIME_UNIT_DICTIONARY)})(?=\\\\s*)`\n        );\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (\n            modifier == \"на наступному\" ||\n            modifier == \"в наступному\" ||\n            modifier == \"у наступному\" ||\n            modifier == \"наступного\"\n        ) {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (\n            modifier == \"на минулому\" ||\n            modifier == \"в минулому\" ||\n            modifier == \"у минулому\" ||\n            modifier == \"минулого\"\n        ) {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = new Date(context.reference.instant.getTime());\n\n        // This week\n        if (timeunit.match(/week/i)) {\n            date.setDate(date.getDate() - date.getDay());\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.imply(\"year\", date.getFullYear());\n        }\n\n        // This month\n        else if (timeunit.match(/month/i)) {\n            date.setDate(1);\n            components.imply(\"day\", date.getDate());\n            components.assign(\"year\", date.getFullYear());\n            components.assign(\"month\", date.getMonth() + 1);\n        }\n\n        // This year\n        else if (timeunit.match(/year/i)) {\n            date.setDate(1);\n            date.setMonth(0);\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.assign(\"year\", date.getFullYear());\n        }\n\n        return components;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, REGEX_PARTS } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithLeftRightBoundaryChecking } from \"./AbstractParserWithWordBoundaryChecking\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nexport default class UKTimeUnitCasualRelativeFormatParser extends AbstractParserWithLeftRightBoundaryChecking {\n    innerPatternString(context: ParsingContext): string {\n        return `(ці|останні|минулі|майбутні|наступні|після|через|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})`;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[1].toLowerCase();\n        let timeUnits = parseDuration(match[3]);\n        switch (prefix) {\n            case \"останні\":\n            case \"минулі\":\n            case \"-\":\n                timeUnits = reverseDuration(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "/**\n * Chrono components for Italian support (*parsers*, *refiners*, and *configuration*)\n *\n * @module\n */\n\nimport ENTimeUnitWithinFormatParser from \"./parsers/ITTimeUnitWithinFormatParser\";\nimport ENMonthNameLittleEndianParser from \"./parsers/ITMonthNameLittleEndianParser\";\nimport ENMonthNameMiddleEndianParser from \"./parsers/ITMonthNameMiddleEndianParser\";\nimport ENMonthNameParser from \"./parsers/ITMonthNameParser\";\nimport ENCasualYearMonthDayParser from \"./parsers/ITCasualYearMonthDayParser\";\nimport ENSlashMonthFormatParser from \"./parsers/ITSlashMonthFormatParser\";\nimport ENTimeExpressionParser from \"./parsers/ITTimeExpressionParser\";\nimport ENTimeUnitAgoFormatParser from \"./parsers/ITTimeUnitAgoFormatParser\";\nimport ENTimeUnitLaterFormatParser from \"./parsers/ITTimeUnitLaterFormatParser\";\nimport ENMergeDateRangeRefiner from \"./refiners/ITMergeDateRangeRefiner\";\nimport ENMergeDateTimeRefiner from \"./refiners/ITMergeDateTimeRefiner\";\n\nimport { includeCommonConfiguration } from \"../../configurations\";\nimport ENCasualDateParser from \"./parsers/ITCasualDateParser\";\nimport ENCasualTimeParser from \"./parsers/ITCasualTimeParser\";\nimport ENWeekdayParser from \"./parsers/ITWeekdayParser\";\nimport ITRelativeDateFormatParser from \"./parsers/ITRelativeDateFormatParser\";\n\nimport { ParsedResult, ParsingOption } from \"../../index\";\nimport { Chrono, Configuration } from \"../../chrono\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ENTimeUnitCasualRelativeFormatParser from \"./parsers/ITTimeUnitCasualRelativeFormatParser\";\nimport ENMergeRelativeDateRefiner from \"./refiners/ITMergeRelativeDateRefiner\";\n\n/**\n * Chrono object configured for parsing *casual* Italian\n */\nexport const casual = new Chrono(createCasualConfiguration(false));\n\n/**\n * Chrono object configured for parsing *strict* Italian\n */\nexport const strict = new Chrono(createConfiguration(true, false));\n\n/**\n * Chrono object configured for parsing Italian\n */\nexport const GB = new Chrono(createConfiguration(false, true));\n\n/**\n * A shortcut for en.casual.parse()\n */\nexport function parse(text: string, ref?: Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for en.casual.parseDate()\n */\nexport function parseDate(text: string, ref?: Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\n/**\n * Create a default *casual* {@Link Configuration} for Italian chrono.\n * It calls {@Link createConfiguration} and includes additional parsers.\n */\nexport function createCasualConfiguration(littleEndian = false): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new ENCasualDateParser());\n    option.parsers.unshift(new ENCasualTimeParser());\n    option.parsers.unshift(new ENMonthNameParser());\n    option.parsers.unshift(new ITRelativeDateFormatParser());\n    option.parsers.unshift(new ENTimeUnitCasualRelativeFormatParser());\n    return option;\n}\n\n/**\n * Create a default {@Link Configuration} for Italian chrono\n *\n * @param strictMode If the timeunit mentioning should be strict, not casual\n * @param littleEndian If format should be date-first/littleEndian (e.g. en_UK), not month-first/middleEndian (e.g. en_US)\n */\nexport function createConfiguration(strictMode = true, littleEndian = false): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new SlashDateFormatParser(littleEndian),\n                new ENTimeUnitWithinFormatParser(),\n                new ENMonthNameLittleEndianParser(),\n                new ENMonthNameMiddleEndianParser(),\n                new ENWeekdayParser(),\n                new ENCasualYearMonthDayParser(),\n                new ENSlashMonthFormatParser(),\n                new ENTimeExpressionParser(strictMode),\n                new ENTimeUnitAgoFormatParser(strictMode),\n                new ENTimeUnitLaterFormatParser(strictMode),\n            ],\n            refiners: [new ENMergeRelativeDateRefiner(), new ENMergeDateTimeRefiner(), new ENMergeDateRangeRefiner()],\n        },\n        strictMode\n    );\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"domenica\": 0,\n    \"dom\": 0,\n    \"lunedì\": 1,\n    \"lun\": 1,\n    \"martedì\": 2,\n    \"mar\": 2,\n    \"mercoledì\": 3,\n    \"merc\": 3,\n    \"giovedì\": 4,\n    \"giov\": 4,\n    \"venerdì\": 5,\n    \"ven\": 5,\n    \"sabato\": 6,\n    \"sab\": 6,\n};\n\nexport const FULL_MONTH_NAME_DICTIONARY: { [word: string]: number } = {};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    ...FULL_MONTH_NAME_DICTIONARY,\n    \"gennaio\": 1,\n    \"gen\": 1,\n    \"gen.\": 1,\n    \"febbraio\": 2,\n    \"feb\": 2,\n    \"feb.\": 2,\n    \"febraio\": 2,\n    \"febb\": 2,\n    \"febb.\": 2,\n    \"marzo\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"aprile\": 4,\n    \"apr\": 4,\n    \"apr.\": 4,\n    \"maggio\": 5,\n    \"mag\": 5,\n    \"giugno\": 6,\n    \"giu\": 6,\n    \"luglio\": 7,\n    \"lug\": 7,\n    \"lugl\": 7,\n    \"lug.\": 7,\n    \"agosto\": 8,\n    \"ago\": 8,\n    \"settembre\": 9,\n    \"set\": 9,\n    \"set.\": 9,\n    \"sett\": 9,\n    \"sett.\": 9,\n    \"ottobre\": 10,\n    \"ott\": 10,\n    \"ott.\": 10,\n    \"novembre\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"dicembre\": 12,\n    \"dic\": 12,\n    \"dice\": 12,\n    \"dic.\": 12,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"uno\": 1,\n    \"due\": 2,\n    \"tre\": 3,\n    \"quattro\": 4,\n    \"cinque\": 5,\n    \"sei\": 6,\n    \"sette\": 7,\n    \"otto\": 8,\n    \"nove\": 9,\n    \"dieci\": 10,\n    \"undici\": 11,\n    \"dodici\": 12,\n};\n\nexport const ORDINAL_WORD_DICTIONARY: { [word: string]: number } = {\n    \"primo\": 1,\n    \"secondo\": 2,\n    \"terzo\": 3,\n    \"quarto\": 4,\n    \"quinto\": 5,\n    \"sesto\": 6,\n    \"settimo\": 7,\n    \"ottavo\": 8,\n    \"nono\": 9,\n    \"decimo\": 10,\n    \"undicesimo\": 11,\n    \"dodicesimo\": 12,\n    \"tredicesimo\": 13,\n    \"quattordicesimo\": 14,\n    \"quindicesimo\": 15,\n    \"sedicesimo\": 16,\n    \"diciassettesimo\": 17,\n    \"diciottesimo\": 18,\n    \"diciannovesimo\": 19,\n    \"ventesimo\": 20,\n    \"ventunesimo\": 21,\n    \"ventiduesimo\": 22,\n    \"ventitreesimo\": 23,\n    \"ventiquattresimo\": 24,\n    \"venticinquesimo\": 25,\n    \"ventiseiesimo\": 26,\n    \"ventisettesimo\": 27,\n    \"ventottesimo\": 28,\n    \"ventinovesimo\": 29,\n    \"trentesimo\": 30,\n    \"trentunesimo\": 31,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    \"sec\": \"second\",\n    \"secondo\": \"second\",\n    \"secondi\": \"second\",\n    \"min\": \"minute\",\n    \"mins\": \"minute\",\n    \"minuti\": \"minute\",\n    \"h\": \"hour\",\n    \"hr\": \"hour\",\n    \"o\": \"hour\",\n    \"ora\": \"hour\",\n    \"ore\": \"hour\",\n    \"giorno\": \"day\",\n    \"giorni\": \"day\",\n    \"settimana\": \"week\",\n    \"settimane\": \"week\",\n    \"mese\": \"month\",\n    \"trimestre\": \"quarter\",\n    \"trimestri\": \"quarter\",\n    \"anni\": \"year\",\n    \"anno\": \"year\",\n};\n\n//-----------------------------\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(\n    INTEGER_WORD_DICTIONARY\n)}|[0-9]+|[0-9]+\\\\.[0-9]+|half(?:\\\\s{0,2}un?)?|un?\\\\b(?:\\\\s{0,2}qualcuno)?|qualcuno|molti|a?\\\\s{0,2}alcuni\\\\s{0,2}(?:of)?)`;\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    } else if (num === \"un\" || num === \"una\") {\n        return 1;\n    } else if (num.match(/alcuni/)) {\n        return 3;\n    } else if (num.match(/metá/)) {\n        return 0.5;\n    } else if (num.match(/paio/)) {\n        return 2;\n    } else if (num.match(/molti/)) {\n        return 7;\n    }\n\n    return parseFloat(num);\n}\n\n//-----------------------------\n\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(\n    ORDINAL_WORD_DICTIONARY\n)}|[0-9]{1,2}(?:mo|ndo|rzo|simo|esimo)?)`;\nexport function parseOrdinalNumberPattern(match: string): number {\n    let num = match.toLowerCase();\n    if (ORDINAL_WORD_DICTIONARY[num] !== undefined) {\n        return ORDINAL_WORD_DICTIONARY[num];\n    }\n\n    num = num.replace(/(?:imo|ndo|rzo|rto|nto|sto|tavo|nono|cimo|timo|esimo)$/i, \"\");\n    return parseInt(num);\n}\n\n//-----------------------------\n\nexport const YEAR_PATTERN = `(?:[1-9][0-9]{0,3}\\\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9])`;\nexport function parseYear(match: string): number {\n    if (/BE/i.test(match)) {\n        // Buddhist Era\n        match = match.replace(/BE/i, \"\");\n        return parseInt(match) - 543;\n    }\n\n    if (/BCE?/i.test(match)) {\n        // Before Christ, Before Common Era\n        match = match.replace(/BCE?/i, \"\");\n        return -parseInt(match);\n    }\n\n    if (/(AD|CE)/i.test(match)) {\n        // Anno Domini, Common Era\n        match = match.replace(/(AD|CE)/i, \"\");\n        return parseInt(match);\n    }\n\n    const rawYearNumber = parseInt(match);\n    return findMostLikelyADYear(rawYearNumber);\n}\n\n//-----------------------------\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,3}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(`(?:(?:about|around)\\\\s{0,3})?`, SINGLE_TIME_UNIT_PATTERN);\n\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length).trim();\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN_WITH_PREFIX = new RegExp(\n    `(?:within|in|for)\\\\s*` +\n        `(?:(?:più o meno|intorno|approssimativamente|verso|verso le)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst PATTERN_WITHOUT_PREFIX = new RegExp(\n    `(?:(?:più o meno|intorno|approssimativamente|verso|verso le)\\\\s*(?:~\\\\s*)?)?(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitWithinFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return context.option.forwardDate ? PATTERN_WITHOUT_PREFIX : PATTERN_WITH_PREFIX;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const timeUnits = parseDuration(match[1]);\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n// prettier-ignore\nconst PATTERN = new RegExp(\n    `(?:on\\\\s{0,3})?` +\n        `(${ORDINAL_NUMBER_PATTERN})` +\n        `(?:` +\n            `\\\\s{0,3}(?:al|\\\\-|\\\\–|fino|alle|allo)?\\\\s{0,3}` +\n            `(${ORDINAL_NUMBER_PATTERN})` +\n        \")?\" +\n        `(?:-|/|\\\\s{0,3}(?:dal)?\\\\s{0,3})` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:\" +\n            `(?:-|/|,?\\\\s{0,3})` +\n            `(${YEAR_PATTERN}(?![^\\\\s]\\\\d))` +\n        \")?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class ENMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { ORDINAL_NUMBER_PATTERN, parseOrdinalNumberPattern } from \"../constants\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${ORDINAL_NUMBER_PATTERN})(?!\\\\s*(?:am|pm))\\\\s*` +\n        \"(?:\" +\n        \"(?:al|\\\\-|\\\\alle|\\\\del|\\\\s)\\\\s*\" +\n        `(${ORDINAL_NUMBER_PATTERN})\\\\s*` +\n        \")?\" +\n        \"(?:\" +\n        \"(?:-|/|\\\\s*,?\\\\s*)\" +\n        `(${YEAR_PATTERN})` +\n        \")?\" +\n        \"(?=\\\\W|$)(?!\\\\:\\\\d)\",\n    \"i\"\n);\n\nconst MONTH_NAME_GROUP = 1;\nconst DATE_GROUP = 2;\nconst DATE_TO_GROUP = 3;\nconst YEAR_GROUP = 4;\n\n/**\n * The parser for parsing US's date format that begin with month's name.\n *  - January 13\n *  - January 13, 2012\n *  - January 13 - 15, 2012\n * Note: Watch out for:\n *  - January 12:00\n *  - January 12.44\n *  - January 1222344\n */\nexport default class ENMonthNameMiddleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseOrdinalNumberPattern(match[DATE_GROUP]);\n        if (day > 31) {\n            return null;\n        }\n\n        const components = context.createParsingComponents({\n            day: day,\n            month: month,\n        });\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            components.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            components.imply(\"year\", year);\n        }\n\n        if (!match[DATE_TO_GROUP]) {\n            return components;\n        }\n\n        // Text can be 'range' value. Such as 'January 12 - 13, 2012'\n        const endDate = parseOrdinalNumberPattern(match[DATE_TO_GROUP]);\n        const result = context.createParsingResult(match.index, match[0]);\n        result.start = components;\n        result.end = components.clone();\n        result.end.assign(\"day\", endDate);\n\n        return result;\n    }\n}\n", "import { FULL_MONTH_NAME_DICTIONARY, MONTH_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { YEAR_PATTERN, parseYear } from \"../constants\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `((?:in)\\\\s*)?` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `\\\\s*` +\n        `(?:` +\n        `[,-]?\\\\s*(${YEAR_PATTERN})?` +\n        \")?\" +\n        \"(?=[^\\\\s\\\\w]|\\\\s+[^0-9]|\\\\s+$|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst YEAR_GROUP = 3;\n\n/**\n * The parser for parsing month name and year.\n * - January, 2012\n * - January 2012\n * - January\n * (in) Jan\n */\nexport default class ENMonthNameParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const monthName = match[MONTH_NAME_GROUP].toLowerCase();\n\n        // skip some unlikely words \"jan\", \"mar\", ..\n        if (match[0].length <= 3 && !FULL_MONTH_NAME_DICTIONARY[monthName]) {\n            return null;\n        }\n\n        const result = context.createParsingResult(\n            match.index + (match[PREFIX_GROUP] || \"\").length,\n            match.index + match[0].length\n        );\n        result.start.imply(\"day\", 1);\n\n        const month = MONTH_DICTIONARY[monthName];\n        result.start.assign(\"month\", month);\n\n        if (match[YEAR_GROUP]) {\n            const year = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", year);\n        } else {\n            const year = findYearClosestToRef(context.refDate, 1, month);\n            result.start.imply(\"year\", year);\n        }\n\n        return result;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\n/*\n    Date format with slash \"/\" between numbers like ENSlashDateFormatParser,\n    but this parser expect year before month and date.\n    - YYYY/MM/DD\n    - YYYY-MM-DD\n    - YYYY.MM.DD\n*/\nconst PATTERN = new RegExp(\n    `([0-9]{4})[\\\\.\\\\/\\\\s]` +\n        `(?:(${matchAnyPattern(MONTH_DICTIONARY)})|([0-9]{1,2}))[\\\\.\\\\/\\\\s]` +\n        `([0-9]{1,2})` +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst YEAR_NUMBER_GROUP = 1;\nconst MONTH_NAME_GROUP = 2;\nconst MONTH_NUMBER_GROUP = 3;\nconst DATE_NUMBER_GROUP = 4;\n\nexport default class ENCasualYearMonthDayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const month = match[MONTH_NUMBER_GROUP]\n            ? parseInt(match[MONTH_NUMBER_GROUP])\n            : MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n\n        if (month < 1 || month > 12) {\n            return null;\n        }\n\n        const year = parseInt(match[YEAR_NUMBER_GROUP]);\n        const day = parseInt(match[DATE_NUMBER_GROUP]);\n\n        return {\n            day: day,\n            month: month,\n            year: year,\n        };\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\"([0-9]|0[1-9]|1[012])/([0-9]{4})\" + \"\", \"i\");\n\nconst MONTH_GROUP = 1;\nconst YEAR_GROUP = 2;\n\n/**\n * Month/Year date format with slash \"/\" (also \"-\" and \".\") between numbers\n * - 11/05\n * - 06/2005\n */\nexport default class ENSlashMonthFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const year = parseInt(match[YEAR_GROUP]);\n        const month = parseInt(match[MONTH_GROUP]);\n\n        return context.createParsingComponents().imply(\"day\", 1).assign(\"month\", month).assign(\"year\", year);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { Meridiem } from \"../../../index\";\nimport { AbstractTimeExpressionParser } from \"../../../common/parsers/AbstractTimeExpressionParser\";\n\nexport default class ENTimeExpressionParser extends AbstractTimeExpressionParser {\n    constructor(strictMode) {\n        super(strictMode);\n    }\n\n    followingPhase(): string {\n        return \"\\\\s*(?:\\\\-|\\\\–|\\\\~|\\\\〜|to|\\\\?)\\\\s*\";\n    }\n\n    primaryPrefix(): string {\n        return \"(?:(?:alle|dalle)\\\\s*)??\";\n    }\n\n    primarySuffix(): string {\n        return \"(?:\\\\s*(?:o\\\\W*in punto|alle\\\\s*sera|in\\\\s*del\\\\s*(?:mattina|pomeriggio)))?(?!/)(?=\\\\W|$)\";\n    }\n\n    extractPrimaryTimeComponents(context: ParsingContext, match: RegExpMatchArray): null | ParsingComponents {\n        const components = super.extractPrimaryTimeComponents(context, match);\n        if (components) {\n            if (match[0].endsWith(\"sera\")) {\n                const hour = components.get(\"hour\");\n                if (hour >= 6 && hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                    components.assign(\"meridiem\", Meridiem.PM);\n                } else if (hour < 6) {\n                    components.assign(\"meridiem\", Meridiem.AM);\n                }\n            }\n\n            if (match[0].endsWith(\"pomeriggio\")) {\n                components.assign(\"meridiem\", Meridiem.PM);\n                const hour = components.get(\"hour\");\n                if (hour >= 0 && hour <= 6) {\n                    components.assign(\"hour\", components.get(\"hour\") + 12);\n                }\n            }\n\n            if (match[0].endsWith(\"mattina\")) {\n                components.assign(\"meridiem\", Meridiem.AM);\n                const hour = components.get(\"hour\");\n                if (hour < 12) {\n                    components.assign(\"hour\", components.get(\"hour\"));\n                }\n            }\n        }\n\n        return components;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(`(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:fa|prima|precedente)(?=(?:\\\\W|$))`, \"i\");\nconst STRICT_PATTERN = new RegExp(`(${TIME_UNITS_PATTERN})\\\\s{0,5}fa(?=(?:\\\\W|$))`, \"i\");\n\nexport default class ENTimeUnitAgoFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const timeUnits = parseDuration(match[1]);\n        const outputTimeUnits = reverseDuration(timeUnits);\n\n        return ParsingComponents.createRelativeFromReference(context.reference, outputTimeUnits);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { parseDuration, TIME_UNITS_PATTERN } from \"../constants\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    `(${TIME_UNITS_PATTERN})\\\\s{0,5}(?:dopo|più tardi|da adesso|avanti|oltre|a seguire)` + \"(?=(?:\\\\W|$))\",\n    \"i\"\n);\n\nconst STRICT_PATTERN = new RegExp(\"\" + \"(\" + TIME_UNITS_PATTERN + \")\" + \"(dopo|più tardi)\" + \"(?=(?:\\\\W|$))\", \"i\");\nconst GROUP_NUM_TIMEUNITS = 1;\n\nexport default class ENTimeUnitLaterFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private strictMode: boolean) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.strictMode ? STRICT_PATTERN : PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const fragments = parseDuration(match[GROUP_NUM_TIMEUNITS]);\n        return ParsingComponents.createRelativeFromReference(context.reference, fragments);\n    }\n}\n", "/*\n  \n*/\n\nimport AbstractMergeDateRangeRefiner from \"../../../common/refiners/AbstractMergeDateRangeRefiner\";\n\n/**\n * Merging before and after results (see. AbstractMergeDateRangeRefiner)\n * This implementation should provide English connecting phases\n * - 2020-02-13 [to] 2020-02-13\n * - Wednesday [-] Friday\n */\nexport default class ENMergeDateRangeRefiner extends AbstractMergeDateRangeRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*(to|-)\\s*$/i;\n    }\n}\n", "import AbstractMergeDateTimeRefiner from \"../../../common/refiners/AbstractMergeDateTimeRefiner\";\n\n/**\n * Merging date-only result and time-only result (see. AbstractMergeDateTimeRefiner).\n * This implementation should provide English connecting phases\n * - 2020-02-13 [at] 6pm\n * - Tomorrow [after] 7am\n */\nexport default class ENMergeDateTimeRefiner extends AbstractMergeDateTimeRefiner {\n    patternBetween(): RegExp {\n        return new RegExp(\"^\\\\s*(T|alle|dopo|prima|il|di|del|delle|,|-)?\\\\s*$\");\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate } from \"../../../utils/dates\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = /(ora|oggi|stasera|questa sera|domani|dmn|ieri\\s*sera)(?=\\W|$)/i;\n\nexport default class ITCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        let targetDate = context.refDate;\n        const lowerText = match[0].toLowerCase();\n        const component = context.createParsingComponents();\n\n        switch (lowerText) {\n            case \"ora\":\n                return references.now(context.reference);\n\n            case \"oggi\":\n                return references.today(context.reference);\n\n            case \"ieri\":\n                return references.yesterday(context.reference);\n\n            case \"domani\":\n            case \"dmn\":\n                return references.tomorrow(context.reference);\n\n            case \"stasera\":\n            case \"questa sera\":\n                return references.tonight(context.reference);\n\n            default:\n                if (lowerText.match(/ieri\\s*sera/)) {\n                    if (targetDate.getHours() > 6) {\n                        const previousDay = new Date(targetDate.getTime());\n                        previousDay.setDate(previousDay.getDate() - 1);\n                        targetDate = previousDay;\n                    }\n\n                    assignSimilarDate(component, targetDate);\n                    component.imply(\"hour\", 0);\n                }\n\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { Meridiem } from \"../../../index\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\n\nconst PATTERN = /(?:questo|questa)?\\s{0,3}(mattina|pomeriggio|sera|notte|mezzanotte|mezzogiorno)(?=\\W|$)/i;\n\nexport default class ITCasualTimeParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern() {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const targetDate = context.refDate;\n        const component = context.createParsingComponents();\n\n        switch (match[1].toLowerCase()) {\n            case \"pomeriggio\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 15);\n                break;\n\n            case \"sera\":\n            case \"notte\":\n                component.imply(\"meridiem\", Meridiem.PM);\n                component.imply(\"hour\", 20);\n                break;\n\n            case \"mezzanotte\":\n                const nextDay = new Date(targetDate.getTime());\n                nextDay.setDate(nextDay.getDate() + 1);\n                assignSimilarDate(component, nextDay);\n                implySimilarTime(component, nextDay);\n                component.imply(\"hour\", 0);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                break;\n\n            case \"mattina\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 6);\n                break;\n\n            case \"mezzogiorno\":\n                component.imply(\"meridiem\", Meridiem.AM);\n                component.imply(\"hour\", 12);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:il\\\\s*?)?\" +\n        \"(?:(questa|l'ultima|scorsa|prossima)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(questa|l'ultima|scorsa|prossima)\\\\s*settimana)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst WEEKDAY_GROUP = 2;\nconst POSTFIX_GROUP = 3;\n\nexport default class ITWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const weekday = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[POSTFIX_GROUP];\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord == \"ultima\" || modifierWord == \"scorsa\") {\n            modifier = \"ultima\";\n        } else if (modifierWord == \"prossima\") {\n            modifier = \"prossima\";\n        } else if (modifierWord == \"questa\") {\n            modifier = \"questa\";\n        }\n        return createParsingComponentsAtWeekday(context.reference, weekday, modifier);\n    }\n}\n", "import { TIME_UNIT_DICTIONARY } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\n\nconst PATTERN = new RegExp(\n    `(questo|ultimo|scorso|prossimo|dopo\\\\s*questo|questa|ultima|scorsa|prossima\\\\s*questa)\\\\s*(${matchAnyPattern(\n        TIME_UNIT_DICTIONARY\n    )})(?=\\\\s*)` + \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst MODIFIER_WORD_GROUP = 1;\nconst RELATIVE_WORD_GROUP = 2;\n\nexport default class ITRelativeDateFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const modifier = match[MODIFIER_WORD_GROUP].toLowerCase();\n        const unitWord = match[RELATIVE_WORD_GROUP].toLowerCase();\n        const timeunit = TIME_UNIT_DICTIONARY[unitWord];\n\n        if (modifier == \"prossimo\" || modifier.startsWith(\"dopo\")) {\n            const timeUnits = {};\n            timeUnits[timeunit] = 1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        if (modifier == \"prima\" || modifier == \"precedente\") {\n            const timeUnits = {};\n            timeUnits[timeunit] = -1;\n            return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n        }\n\n        const components = context.createParsingComponents();\n        let date = new Date(context.reference.instant.getTime());\n\n        // This week\n        if (unitWord.match(/settimana/i)) {\n            date.setDate(date.getDate() - date.getDay());\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.imply(\"year\", date.getFullYear());\n        }\n\n        // This month\n        else if (unitWord.match(/mese/i)) {\n            date.setDate(1);\n            components.imply(\"day\", date.getDate());\n            components.assign(\"year\", date.getFullYear());\n            components.assign(\"month\", date.getMonth() + 1);\n        }\n\n        // This year\n        else if (unitWord.match(/anno/i)) {\n            date.setDate(1);\n            date.setMonth(0);\n            components.imply(\"day\", date.getDate());\n            components.imply(\"month\", date.getMonth() + 1);\n            components.assign(\"year\", date.getFullYear());\n        }\n\n        return components;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(\n    `(questo|ultimo|passato|prossimo|dopo|questa|ultima|passata|prossima|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class ENTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const prefix = match[1].toLowerCase();\n        let timeUnits = parseDuration(match[2]);\n        switch (prefix) {\n            case \"last\":\n            case \"past\":\n            case \"-\":\n                timeUnits = reverseDuration(timeUnits);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, timeUnits);\n    }\n}\n", "import { MergingRefiner } from \"../../../common/abstractRefiners\";\nimport { ParsingComponents, ParsingResult, ReferenceWithTimezone } from \"../../../results\";\nimport { parseDuration } from \"../constants\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nfunction hasImpliedEarlierReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(prima|dal)$/i) != null;\n}\n\nfunction hasImpliedLaterReferenceDate(result: ParsingResult): boolean {\n    return result.text.match(/\\s+(dopo|dal|fino)$/i) != null;\n}\n\n/**\n * Merges an absolute date with a relative date.\n * - 2 weeks before 2020-02-13\n * - 2 days after next Friday\n */\nexport default class ENMergeRelativeDateRefiner extends MergingRefiner {\n    patternBetween(): RegExp {\n        return /^\\s*$/i;\n    }\n\n    shouldMergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): boolean {\n        // Dates need to be next to each other to get merged\n        if (!textBetween.match(this.patternBetween())) {\n            return false;\n        }\n\n        // Check if any relative tokens were swallowed by the first date.\n        // E.g. [<relative_date1> from] [<date2>]\n        if (!hasImpliedEarlierReferenceDate(currentResult) && !hasImpliedLaterReferenceDate(currentResult)) {\n            return false;\n        }\n\n        // make sure that <date2> implies an absolute date\n        return !!nextResult.start.get(\"day\") && !!nextResult.start.get(\"month\") && !!nextResult.start.get(\"year\");\n    }\n\n    mergeResults(textBetween: string, currentResult: ParsingResult, nextResult: ParsingResult): ParsingResult {\n        let timeUnits = parseDuration(currentResult.text);\n        if (hasImpliedEarlierReferenceDate(currentResult)) {\n            timeUnits = reverseDuration(timeUnits);\n        }\n\n        const components = ParsingComponents.createRelativeFromReference(\n            ReferenceWithTimezone.fromDate(nextResult.start.date()),\n            timeUnits\n        );\n\n        return new ParsingResult(\n            nextResult.reference,\n            currentResult.index,\n            `${currentResult.text}${textBetween}${nextResult.text}`,\n            components\n        );\n    }\n}\n", "import { includeCommonConfiguration } from \"../../configurations\";\nimport { Chrono, Configuration, Parser, Refiner } from \"../../chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"../../results\";\nimport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"../../types\";\nimport SlashDateFormatParser from \"../../common/parsers/SlashDateFormatParser\";\nimport ISOFormatParser from \"../../common/parsers/ISOFormatParser\";\nimport SVWeekdayParser from \"./parsers/SVWeekdayParser\";\nimport SVMonthNameLittleEndianParser from \"./parsers/SVMonthNameLittleEndianParser\";\nimport SVTimeUnitCasualRelativeFormatParser from \"./parsers/SVTimeUnitCasualRelativeFormatParser\";\nimport SVCasualDateParser from \"./parsers/SVCasualDateParser\";\n\nexport { Chrono, Parser, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Shortcuts\nexport const casual = new Chrono(createCasualConfiguration());\nexport const strict = new Chrono(createConfiguration(true));\n\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date {\n    return casual.parseDate(text, ref, option);\n}\n\nexport function createCasualConfiguration(littleEndian = true): Configuration {\n    const option = createConfiguration(false, littleEndian);\n    option.parsers.unshift(new SVCasualDateParser());\n    return option;\n}\n\nexport function createConfiguration(strictMode = true, littleEndian = true): Configuration {\n    return includeCommonConfiguration(\n        {\n            parsers: [\n                new ISOFormatParser(),\n                new SlashDateFormatParser(littleEndian),\n                new SVMonthNameLittleEndianParser(),\n                new SVWeekdayParser(),\n                new SVTimeUnitCasualRelativeFormatParser(),\n            ],\n            refiners: [],\n        },\n        strictMode\n    );\n}\n", "import { matchAnyPattern, repeatedTimeunitPattern } from \"../../utils/pattern\";\nimport { findMostLikelyADYear } from \"../../calculation/years\";\nimport { Duration } from \"../../calculation/duration\";\nimport { Timeunit } from \"../../types\";\n\nexport const WEEKDAY_DICTIONARY: { [word: string]: number } = {\n    \"söndag\": 0,\n    \"sön\": 0,\n    \"so\": 0,\n    \"måndag\": 1,\n    \"mån\": 1,\n    \"må\": 1,\n    \"tisdag\": 2,\n    \"tis\": 2,\n    \"ti\": 2,\n    \"onsdag\": 3,\n    \"ons\": 3,\n    \"on\": 3,\n    \"torsdag\": 4,\n    \"tors\": 4,\n    \"to\": 4,\n    \"fredag\": 5,\n    \"fre\": 5,\n    \"fr\": 5,\n    \"lördag\": 6,\n    \"lör\": 6,\n    \"lö\": 6,\n};\n\nexport const MONTH_DICTIONARY: { [word: string]: number } = {\n    \"januari\": 1,\n    \"jan\": 1,\n    \"jan.\": 1,\n    \"februari\": 2,\n    \"feb\": 2,\n    \"feb.\": 2,\n    \"mars\": 3,\n    \"mar\": 3,\n    \"mar.\": 3,\n    \"april\": 4,\n    \"apr\": 4,\n    \"apr.\": 4,\n    \"maj\": 5,\n    \"juni\": 6,\n    \"jun\": 6,\n    \"jun.\": 6,\n    \"juli\": 7,\n    \"jul\": 7,\n    \"jul.\": 7,\n    \"augusti\": 8,\n    \"aug\": 8,\n    \"aug.\": 8,\n    \"september\": 9,\n    \"sep\": 9,\n    \"sep.\": 9,\n    \"sept\": 9,\n    \"oktober\": 10,\n    \"okt\": 10,\n    \"okt.\": 10,\n    \"november\": 11,\n    \"nov\": 11,\n    \"nov.\": 11,\n    \"december\": 12,\n    \"dec\": 12,\n    \"dec.\": 12,\n};\n\nexport const ORDINAL_NUMBER_DICTIONARY: { [word: string]: number } = {\n    \"första\": 1,\n    \"andra\": 2,\n    \"tredje\": 3,\n    \"fjärde\": 4,\n    \"femte\": 5,\n    \"sjätte\": 6,\n    \"sjunde\": 7,\n    \"åttonde\": 8,\n    \"nionde\": 9,\n    \"tionde\": 10,\n    \"elfte\": 11,\n    \"tolfte\": 12,\n    \"trettonde\": 13,\n    \"fjortonde\": 14,\n    \"femtonde\": 15,\n    \"sextonde\": 16,\n    \"sjuttonde\": 17,\n    \"artonde\": 18,\n    \"nittonde\": 19,\n    \"tjugonde\": 20,\n    \"tjugoförsta\": 21,\n    \"tjugoandra\": 22,\n    \"tjugotredje\": 23,\n    \"tjugofjärde\": 24,\n    \"tjugofemte\": 25,\n    \"tjugosjätte\": 26,\n    \"tjugosjunde\": 27,\n    \"tjugoåttonde\": 28,\n    \"tjugonionde\": 29,\n    \"trettionde\": 30,\n    \"trettioförsta\": 31,\n};\n\nexport const INTEGER_WORD_DICTIONARY: { [word: string]: number } = {\n    \"en\": 1,\n    \"ett\": 1,\n    \"två\": 2,\n    \"tre\": 3,\n    \"fyra\": 4,\n    \"fem\": 5,\n    \"sex\": 6,\n    \"sju\": 7,\n    \"åtta\": 8,\n    \"nio\": 9,\n    \"tio\": 10,\n    \"elva\": 11,\n    \"tolv\": 12,\n    \"tretton\": 13,\n    \"fjorton\": 14,\n    \"femton\": 15,\n    \"sexton\": 16,\n    \"sjutton\": 17,\n    \"arton\": 18,\n    \"nitton\": 19,\n    \"tjugo\": 20,\n    \"trettiо\": 30,\n    \"fyrtio\": 40,\n    \"femtio\": 50,\n    \"sextio\": 60,\n    \"sjuttio\": 70,\n    \"åttio\": 80,\n    \"nittio\": 90,\n    \"hundra\": 100,\n    \"tusen\": 1000,\n};\n\nexport const TIME_UNIT_DICTIONARY: { [word: string]: Timeunit } = {\n    \"sek\": \"second\",\n    \"sekund\": \"second\",\n    \"sekunder\": \"second\",\n    \"min\": \"minute\",\n    \"minut\": \"minute\",\n    \"minuter\": \"minute\",\n    \"tim\": \"hour\",\n    \"timme\": \"hour\",\n    \"timmar\": \"hour\",\n    \"dag\": \"day\",\n    \"dagar\": \"day\",\n    \"vecka\": \"week\",\n    \"veckor\": \"week\",\n    \"mån\": \"month\",\n    \"månad\": \"month\",\n    \"månader\": \"month\",\n    \"år\": \"year\",\n    \"kvartаl\": \"quarter\",\n    \"kvartal\": \"quarter\",\n};\n\nexport const TIME_UNIT_NO_ABBR_DICTIONARY: { [word: string]: Timeunit } = {\n    \"sekund\": \"second\",\n    \"sekunder\": \"second\",\n    \"minut\": \"minute\",\n    \"minuter\": \"minute\",\n    \"timme\": \"hour\",\n    \"timmar\": \"hour\",\n    \"dag\": \"day\",\n    \"dagar\": \"day\",\n    \"vecka\": \"week\",\n    \"veckor\": \"week\",\n    \"månad\": \"month\",\n    \"månader\": \"month\",\n    \"år\": \"year\",\n    \"kvartal\": \"quarter\",\n};\n\nexport function parseDuration(timeunitText): Duration {\n    const fragments = {};\n    let remainingText = timeunitText;\n    let match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    while (match) {\n        collectDateTimeFragment(fragments, match);\n        remainingText = remainingText.substring(match[0].length);\n        match = SINGLE_TIME_UNIT_REGEX.exec(remainingText);\n    }\n    return fragments as Duration;\n}\n\nfunction collectDateTimeFragment(fragments, match) {\n    const num = parseNumberPattern(match[1]);\n    const unit = TIME_UNIT_DICTIONARY[match[2].toLowerCase()];\n    fragments[unit] = num;\n}\n\nexport const NUMBER_PATTERN = `(?:${matchAnyPattern(INTEGER_WORD_DICTIONARY)}|\\\\d+)`;\nexport const ORDINAL_NUMBER_PATTERN = `(?:${matchAnyPattern(ORDINAL_NUMBER_DICTIONARY)}|\\\\d{1,2}(?:e|:e))`;\nexport const TIME_UNIT_PATTERN = `(?:${matchAnyPattern(TIME_UNIT_DICTIONARY)})`;\n\nconst SINGLE_TIME_UNIT_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(TIME_UNIT_DICTIONARY)})\\\\s{0,5}`;\nconst SINGLE_TIME_UNIT_REGEX = new RegExp(SINGLE_TIME_UNIT_PATTERN, \"i\");\n\nconst SINGLE_TIME_UNIT_NO_ABBR_PATTERN = `(${NUMBER_PATTERN})\\\\s{0,5}(${matchAnyPattern(\n    TIME_UNIT_NO_ABBR_DICTIONARY\n)})\\\\s{0,5}`;\n\nexport const TIME_UNITS_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_PATTERN);\nexport const TIME_UNITS_NO_ABBR_PATTERN = repeatedTimeunitPattern(\"\", SINGLE_TIME_UNIT_NO_ABBR_PATTERN);\n\nexport function parseNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    }\n    return parseInt(num);\n}\n\nexport function parseOrdinalNumberPattern(match: string): number {\n    const num = match.toLowerCase();\n    if (ORDINAL_NUMBER_DICTIONARY[num] !== undefined) {\n        return ORDINAL_NUMBER_DICTIONARY[num];\n    }\n    return parseInt(num);\n}\n\nexport function parseYear(match: string): number {\n    if (/\\d+/.test(match)) {\n        let yearNumber = parseInt(match);\n        if (yearNumber < 100) {\n            yearNumber = findMostLikelyADYear(yearNumber);\n        }\n        return yearNumber;\n    }\n\n    const num = match.toLowerCase();\n    if (INTEGER_WORD_DICTIONARY[num] !== undefined) {\n        return INTEGER_WORD_DICTIONARY[num];\n    }\n\n    return parseInt(match);\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { WEEKDAY_DICTIONARY } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { createParsingComponentsAtWeekday } from \"../../../calculation/weekdays\";\n\nconst PATTERN = new RegExp(\n    \"(?:(?:\\\\,|\\\\(|\\\\（)\\\\s*)?\" +\n        \"(?:på\\\\s*?)?\" +\n        \"(?:(förra|senaste|nästa|kommande)\\\\s*)?\" +\n        `(${matchAnyPattern(WEEKDAY_DICTIONARY)})` +\n        \"(?:\\\\s*(?:\\\\,|\\\\)|\\\\）))?\" +\n        \"(?:\\\\s*(förra|senaste|nästa|kommande)\\\\s*vecka)?\" +\n        \"(?=\\\\W|$)\",\n    \"i\"\n);\n\nconst PREFIX_GROUP = 1;\nconst SUFFIX_GROUP = 3;\nconst WEEKDAY_GROUP = 2;\n\nexport default class SVWeekdayParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents {\n        const dayOfWeek = match[WEEKDAY_GROUP].toLowerCase();\n        const offset = WEEKDAY_DICTIONARY[dayOfWeek];\n        const prefix = match[PREFIX_GROUP];\n        const postfix = match[SUFFIX_GROUP];\n\n        let modifierWord = prefix || postfix;\n        modifierWord = modifierWord || \"\";\n        modifierWord = modifierWord.toLowerCase();\n\n        let modifier = null;\n        if (modifierWord.match(/förra|senaste/)) {\n            modifier = \"last\";\n        } else if (modifierWord.match(/nästa|kommande/)) {\n            modifier = \"next\";\n        }\n\n        return createParsingComponentsAtWeekday(context.reference, offset, modifier);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingResult } from \"../../../results\";\nimport { findYearClosestToRef } from \"../../../calculation/years\";\nimport { MONTH_DICTIONARY } from \"../constants\";\nimport { parseYear } from \"../constants\";\nimport { matchAnyPattern } from \"../../../utils/pattern\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\n\nconst PATTERN = new RegExp(\n    \"(?:den\\\\s*?)?\" +\n        `([0-9]{1,2})` +\n        `(?:\\\\s*(?:till|\\\\-|\\\\–|\\\\s)\\\\s*([0-9]{1,2}))?\\\\s*` +\n        `(${matchAnyPattern(MONTH_DICTIONARY)})` +\n        `(?:(?:-|/|,?\\\\s*)([0-9]{4}(?![^\\\\s]\\\\d)))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst DATE_TO_GROUP = 2;\nconst MONTH_NAME_GROUP = 3;\nconst YEAR_GROUP = 4;\n\nexport default class SVMonthNameLittleEndianParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingResult {\n        const result = context.createParsingResult(match.index, match[0]);\n\n        const month = MONTH_DICTIONARY[match[MONTH_NAME_GROUP].toLowerCase()];\n        const day = parseInt(match[DATE_GROUP]);\n        if (day > 31) {\n            // e.g. \"[96 Aug]\" => \"9[6 Aug]\", we need to shift away from the next number\n            match.index = match.index + match[DATE_GROUP].length;\n            return null;\n        }\n\n        result.start.assign(\"month\", month);\n        result.start.assign(\"day\", day);\n\n        if (match[YEAR_GROUP]) {\n            const yearNumber = parseYear(match[YEAR_GROUP]);\n            result.start.assign(\"year\", yearNumber);\n        } else {\n            const year = findYearClosestToRef(context.refDate, day, month);\n            result.start.imply(\"year\", year);\n        }\n\n        if (match[DATE_TO_GROUP]) {\n            const endDate = parseInt(match[DATE_TO_GROUP]);\n            result.end = result.start.clone();\n            result.end.assign(\"day\", endDate);\n        }\n\n        return result;\n    }\n}\n", "import { TIME_UNITS_PATTERN, parseDuration, TIME_UNITS_NO_ABBR_PATTERN } from \"../constants\";\nimport { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { reverseDuration } from \"../../../calculation/duration\";\n\nconst PATTERN = new RegExp(\n    `(denna|den här|förra|passerade|nästa|kommande|efter|\\\\+|-)\\\\s*(${TIME_UNITS_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\nconst PATTERN_NO_ABBR = new RegExp(\n    `(denna|den här|förra|passerade|nästa|kommande|efter|\\\\+|-)\\\\s*(${TIME_UNITS_NO_ABBR_PATTERN})(?=\\\\W|$)`,\n    \"i\"\n);\n\nexport default class SVTimeUnitCasualRelativeFormatParser extends AbstractParserWithWordBoundaryChecking {\n    constructor(private allowAbbreviations: boolean = true) {\n        super();\n    }\n\n    innerPattern(): RegExp {\n        return this.allowAbbreviations ? PATTERN : PATTERN_NO_ABBR;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray) {\n        const prefix = match[1].toLowerCase();\n        let duration = parseDuration(match[2]);\n        if (!duration) {\n            return null;\n        }\n\n        switch (prefix) {\n            case \"förra\":\n            case \"passerade\":\n            case \"-\":\n                duration = reverseDuration(duration);\n                break;\n        }\n\n        return ParsingComponents.createRelativeFromReference(context.reference, duration);\n    }\n}\n", "import { ParsingContext } from \"../../../chrono\";\nimport { ParsingComponents, ParsingResult } from \"../../../results\";\nimport { AbstractParserWithWordBoundaryChecking } from \"../../../common/parsers/AbstractParserWithWordBoundary\";\nimport { assignSimilarDate, implySimilarTime } from \"../../../utils/dates\";\nimport * as references from \"../../../common/casualReferences\";\n\nconst PATTERN = new RegExp(\n    `(nu|idag|imorgon|övermorgon|igår|förrgår|i\\\\s*förrgår)` +\n        `(?:\\\\s*(?:på\\\\s*)?(morgonen?|förmiddagen?|middagen?|eftermiddagen?|kvällen?|natten?|midnatt))?` +\n        `(?=\\\\W|$)`,\n    \"i\"\n);\n\nconst DATE_GROUP = 1;\nconst TIME_GROUP = 2;\n\nexport default class SVCasualDateParser extends AbstractParserWithWordBoundaryChecking {\n    innerPattern(context: ParsingContext): RegExp {\n        return PATTERN;\n    }\n\n    innerExtract(context: ParsingContext, match: RegExpMatchArray): ParsingComponents | ParsingResult {\n        const targetDate = context.refDate;\n        const dateKeyword = (match[DATE_GROUP] || \"\").toLowerCase();\n        const timeKeyword = (match[TIME_GROUP] || \"\").toLowerCase();\n\n        let component = context.createParsingComponents();\n        switch (dateKeyword) {\n            case \"nu\":\n                component = references.now(context.reference);\n                break;\n\n            case \"idag\":\n                component = references.today(context.reference);\n                break;\n\n            case \"imorgon\":\n            case \"imorn\":\n                const nextDay = new Date(targetDate.getTime());\n                nextDay.setDate(nextDay.getDate() + 1);\n                assignSimilarDate(component, nextDay);\n                implySimilarTime(component, nextDay);\n                break;\n\n            case \"igår\":\n                const previousDay = new Date(targetDate.getTime());\n                previousDay.setDate(previousDay.getDate() - 1);\n                assignSimilarDate(component, previousDay);\n                implySimilarTime(component, previousDay);\n                break;\n\n            case \"förrgår\":\n            case \"i förrgår\":\n                const twoDaysAgo = new Date(targetDate.getTime());\n                twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);\n                assignSimilarDate(component, twoDaysAgo);\n                implySimilarTime(component, twoDaysAgo);\n                break;\n        }\n\n        switch (timeKeyword) {\n            case \"morgon\":\n            case \"morgonen\":\n                component.imply(\"hour\", 6);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"millisecond\", 0);\n                break;\n\n            case \"förmiddag\":\n            case \"förmiddagen\":\n                component.imply(\"hour\", 9);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"millisecond\", 0);\n                break;\n\n            case \"middag\":\n            case \"middagen\":\n                component.imply(\"hour\", 12);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"millisecond\", 0);\n                break;\n\n            case \"eftermiddag\":\n            case \"eftermiddagen\":\n                component.imply(\"hour\", 15);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"millisecond\", 0);\n                break;\n\n            case \"kväll\":\n            case \"kvällen\":\n                component.imply(\"hour\", 20);\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"millisecond\", 0);\n                break;\n\n            case \"natt\":\n            case \"natten\":\n            case \"midnatt\":\n                if (timeKeyword === \"midnatt\") {\n                    component.imply(\"hour\", 0);\n                } else {\n                    component.imply(\"hour\", 2);\n                }\n                component.imply(\"minute\", 0);\n                component.imply(\"second\", 0);\n                component.imply(\"millisecond\", 0);\n                break;\n        }\n\n        return component;\n    }\n}\n", "import * as en from \"./locales/en\";\nimport { Chrono, Parser, ParsingContext, Refiner } from \"./chrono\";\nimport { ParsingResult, ParsingComponents, ReferenceWithTimezone } from \"./results\";\nimport { Component, ParsedComponents, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday } from \"./types\";\n\nexport { en, Chrono, Parser, ParsingContext, Refiner, ParsingResult, ParsingComponents, ReferenceWithTimezone };\nexport { Component, ParsedComponents, ParsedResult, ParsingOption, ParsingReference, Meridiem, Weekday };\n\n// Export all locales\nimport * as de from \"./locales/de\";\nimport * as fr from \"./locales/fr\";\nimport * as ja from \"./locales/ja\";\nimport * as pt from \"./locales/pt\";\nimport * as nl from \"./locales/nl\";\nimport * as zh from \"./locales/zh\";\nimport * as ru from \"./locales/ru\";\nimport * as es from \"./locales/es\";\nimport * as uk from \"./locales/uk\";\nimport * as it from \"./locales/it\";\nimport * as sv from \"./locales/sv\";\n\nexport { de, fr, ja, pt, nl, zh, ru, es, uk, it, sv };\n\n/**\n * A shortcut for {@link en | chrono.en.strict}\n */\nexport const strict = en.strict;\n\n/**\n * A shortcut for {@link en | chrono.en.casual}\n */\nexport const casual = en.casual;\n\n/**\n * A shortcut for {@link en | chrono.en.casual.parse()}\n */\nexport function parse(text: string, ref?: ParsingReference | Date, option?: ParsingOption): ParsedResult[] {\n    return casual.parse(text, ref, option);\n}\n\n/**\n * A shortcut for {@link en | chrono.en.casual.parseDate()}\n */\nexport function parseDate(text: string, ref?: ParsingReference | Date, option?: ParsingOption): Date | null {\n    return casual.parseDate(text, ref, option);\n}\n"],
  "mappings": "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",
  "names": ["Meridiem", "Weekday", "Month", "year", "year", "PATTERN", "MONTH_NAME_GROUP", "DATE_GROUP", "DATE_TO_GROUP", "YEAR_GROUP", "year", "PATTERN", "MONTH_NAME_GROUP", "YEAR_GROUP", "year", "PATTERN", "MONTH_NAME_GROUP", "year", "PATTERN", "YEAR_GROUP", "year", "strict", "PATTERN", "PATTERN", "STRICT_PATTERN", "refDate", "daysToAdd", "PATTERN", "YEAR_NUMBER_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "configuration", "PATTERN", "PATTERN", "PATTERN", "PREFIX_GROUP", "PATTERN", "PATTERN", "YEAR_GROUP", "year", "PATTERN", "YEAR_GROUP", "year", "configuration", "casual", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "PATTERN", "DATE_GROUP", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "NUMBER_PATTERN", "TIME_UNIT_DICTIONARY", "parseNumberPattern", "TIME_UNITS_PATTERN", "parseDuration", "casual", "strict", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "PATTERN", "WEEKDAY_DICTIONARY", "WEEKDAY_GROUP", "POSTFIX_GROUP", "FIRST_REG_PATTERN", "SECOND_REG_PATTERN", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "PATTERN", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseOrdinalNumberPattern", "parseYear", "year", "TIME_UNITS_PATTERN", "parseDuration", "TIME_UNITS_PATTERN", "parseDuration", "FRTimeUnitAgoFormatParser", "NUMBER_PATTERN", "TIME_UNIT_DICTIONARY", "parseNumberPattern", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "FRTimeUnitAgoFormatParser", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "PATTERN", "YEAR_NUMBER_GROUP", "MONTH_GROUP", "year", "PATTERN", "PATTERN", "PATTERN", "YEAR_GROUP", "MONTH_GROUP", "DAY_GROUP", "year", "FIRST_REG_PATTERN", "SECOND_REG_PATTERN", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "PATTERN", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "YEAR_PATTERN", "parseYear", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "DAY_GROUP", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "TIME_UNITS_PATTERN", "parseDuration", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "MONTH_NAME_GROUP", "DATE_GROUP", "DATE_TO_GROUP", "YEAR_GROUP", "parseOrdinalNumberPattern", "year", "parseYear", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "MONTH_NAME_GROUP", "YEAR_GROUP", "year", "parseYear", "PATTERN", "MONTH_GROUP", "YEAR_GROUP", "year", "PATTERN", "MONTH_DICTIONARY", "YEAR_NUMBER_GROUP", "MONTH_NAME_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "year", "DATE_GROUP", "PATTERN", "TIME_UNITS_PATTERN", "parseDuration", "PATTERN", "TIME_UNIT_DICTIONARY", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "parseDuration", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "GROUP_NUM_TIMEUNITS", "parseDuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "NUMBER", "WEEKDAY_OFFSET", "YEAR_GROUP", "MONTH_GROUP", "DAY_GROUP", "NUMBER", "year", "PATTERN", "NUMBER", "date", "PATTERN", "WEEKDAY_OFFSET", "FIRST_REG_PATTERN", "NUMBER", "SECOND_REG_PATTERN", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "PATTERN", "WEEKDAY_OFFSET", "DAY_GROUP_1", "DAY_GROUP_3", "NUMBER", "WEEKDAY_OFFSET", "zhStringToNumber", "zhStringToYear", "YEAR_GROUP", "MONTH_GROUP", "DAY_GROUP", "NUMBER", "zhStringToNumber", "year", "zhStringToYear", "PATTERN", "NUMBER", "NUMBER_GROUP", "UNIT_GROUP", "zhStringToNumber", "date", "PATTERN", "WEEKDAY_OFFSET", "FIRST_REG_PATTERN", "NUMBER", "SECOND_REG_PATTERN", "DAY_GROUP_1", "ZH_AM_PM_HOUR_GROUP_1", "ZH_AM_PM_HOUR_GROUP_2", "DAY_GROUP_3", "ZH_AM_PM_HOUR_GROUP_3", "HOUR_GROUP", "MINUTE_GROUP", "SECOND_GROUP", "AM_PM_HOUR_GROUP", "zhStringToNumber", "second", "zhAMPMString1", "zhAMPMString2", "zhAMPMString3", "PATTERN", "WEEKDAY_OFFSET", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "createCasualConfiguration", "casual", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "NOW_GROUP", "DAY_GROUP_1", "TIME_GROUP_1", "TIME_GROUP_2", "DAY_GROUP_3", "TIME_GROUP_3", "createCasualConfiguration", "casual", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "configuration", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "FULL_MONTH_NAME_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "PATTERN", "TIME_UNITS_PATTERN", "parseDuration", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "parseOrdinalNumberPattern", "parseYear", "year", "MONTH_NAME_GROUP", "YEAR_GROUP", "MONTH_DICTIONARY", "YEAR_PATTERN", "FULL_MONTH_NAME_DICTIONARY", "year", "parseYear", "TIME_UNITS_PATTERN", "parseDuration", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "WEEKDAY_DICTIONARY", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "TIME_UNIT_DICTIONARY", "TIME_UNITS_PATTERN", "parseDuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "TIME_UNITS_PATTERN", "parseDuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "REGEX_PARTS", "WEEKDAY_DICTIONARY", "FULL_MONTH_NAME_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "year", "YEAR_PATTERN", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "PATTERN", "TIME_UNITS_PATTERN", "REGEX_PARTS", "parseDuration", "AbstractParserWithLeftBoundaryChecking", "REGEX_PARTS", "AbstractParserWithLeftRightBoundaryChecking", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "AbstractParserWithLeftRightBoundaryChecking", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "parseOrdinalNumberPattern", "year", "MONTH_NAME_GROUP", "YEAR_GROUP", "AbstractParserWithLeftBoundaryChecking", "MONTH_DICTIONARY", "YEAR_PATTERN", "FULL_MONTH_NAME_DICTIONARY", "year", "REGEX_PARTS", "AbstractParserWithLeftBoundaryChecking", "TIME_UNITS_PATTERN", "parseDuration", "AbstractParserWithLeftRightBoundaryChecking", "AbstractParserWithLeftRightBoundaryChecking", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "AbstractParserWithLeftRightBoundaryChecking", "WEEKDAY_DICTIONARY", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "AbstractParserWithLeftRightBoundaryChecking", "TIME_UNIT_DICTIONARY", "AbstractParserWithLeftRightBoundaryChecking", "TIME_UNITS_PATTERN", "parseDuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "GB", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "FULL_MONTH_NAME_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "ORDINAL_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "NUMBER_PATTERN", "parseNumberPattern", "ORDINAL_NUMBER_PATTERN", "parseOrdinalNumberPattern", "YEAR_PATTERN", "parseYear", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_REGEX", "TIME_UNITS_PATTERN", "parseDuration", "collectDateTimeFragment", "PATTERN_WITH_PREFIX", "TIME_UNITS_PATTERN", "ENTimeUnitWithinFormatParser", "parseDuration", "PATTERN", "ORDINAL_NUMBER_PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "ENMonthNameLittleEndianParser", "parseOrdinalNumberPattern", "parseYear", "year", "PATTERN", "MONTH_DICTIONARY", "ORDINAL_NUMBER_PATTERN", "YEAR_PATTERN", "MONTH_NAME_GROUP", "DATE_GROUP", "DATE_TO_GROUP", "YEAR_GROUP", "ENMonthNameMiddleEndianParser", "parseOrdinalNumberPattern", "year", "parseYear", "PATTERN", "MONTH_DICTIONARY", "YEAR_PATTERN", "PREFIX_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "ENMonthNameParser", "FULL_MONTH_NAME_DICTIONARY", "year", "parseYear", "PATTERN", "MONTH_DICTIONARY", "YEAR_NUMBER_GROUP", "MONTH_NAME_GROUP", "MONTH_NUMBER_GROUP", "DATE_NUMBER_GROUP", "year", "PATTERN", "MONTH_GROUP", "YEAR_GROUP", "ENSlashMonthFormatParser", "year", "ENTimeExpressionParser", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "ENTimeUnitAgoFormatParser", "parseDuration", "PATTERN", "TIME_UNITS_PATTERN", "STRICT_PATTERN", "GROUP_NUM_TIMEUNITS", "ENTimeUnitLaterFormatParser", "parseDuration", "ENMergeDateRangeRefiner", "ENMergeDateTimeRefiner", "PATTERN", "PATTERN", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "WEEKDAY_GROUP", "POSTFIX_GROUP", "PATTERN", "TIME_UNIT_DICTIONARY", "MODIFIER_WORD_GROUP", "RELATIVE_WORD_GROUP", "PATTERN", "TIME_UNITS_PATTERN", "ENTimeUnitCasualRelativeFormatParser", "parseDuration", "hasImpliedEarlierReferenceDate", "hasImpliedLaterReferenceDate", "parseDuration", "casual", "createCasualConfiguration", "strict", "createConfiguration", "GB", "parse", "parseDate", "ENMonthNameParser", "ENTimeUnitCasualRelativeFormatParser", "ENTimeUnitWithinFormatParser", "ENMonthNameLittleEndianParser", "ENMonthNameMiddleEndianParser", "ENSlashMonthFormatParser", "ENTimeExpressionParser", "ENTimeUnitAgoFormatParser", "ENTimeUnitLaterFormatParser", "ENMergeDateTimeRefiner", "ENMergeDateRangeRefiner", "casual", "createCasualConfiguration", "createConfiguration", "parse", "parseDate", "strict", "WEEKDAY_DICTIONARY", "MONTH_DICTIONARY", "INTEGER_WORD_DICTIONARY", "TIME_UNIT_DICTIONARY", "parseDuration", "SINGLE_TIME_UNIT_REGEX", "collectDateTimeFragment", "parseNumberPattern", "NUMBER_PATTERN", "ORDINAL_NUMBER_PATTERN", "SINGLE_TIME_UNIT_PATTERN", "SINGLE_TIME_UNIT_NO_ABBR_PATTERN", "TIME_UNITS_PATTERN", "TIME_UNITS_NO_ABBR_PATTERN", "parseYear", "INTEGER_WORD_DICTIONARY", "PATTERN", "WEEKDAY_DICTIONARY", "PREFIX_GROUP", "SUFFIX_GROUP", "WEEKDAY_GROUP", "PATTERN", "MONTH_DICTIONARY", "DATE_GROUP", "DATE_TO_GROUP", "MONTH_NAME_GROUP", "YEAR_GROUP", "parseYear", "year", "PATTERN", "TIME_UNITS_PATTERN", "PATTERN_NO_ABBR", "TIME_UNITS_NO_ABBR_PATTERN", "parseDuration", "PATTERN", "DATE_GROUP", "TIME_GROUP", "casual", "createCasualConfiguration", "strict", "createConfiguration", "parse", "parseDate", "strict", "casual", "parse", "parseDate"]
}
